{"version":3,"file":"WMSCapabilitiesLoader-DbLeYQEW.js","sources":["../src/three/plugins/images/ImageFormatPlugin.js","../src/three/plugins/images/utils/getCartographicToMeterDerivative.js","../src/three/plugins/images/EllipsoidProjectionTilesPlugin.js","../src/three/plugins/images/utils/ProjectionScheme.js","../src/three/plugins/images/utils/DataCache.js","../src/three/plugins/images/utils/TilingScheme.js","../src/three/plugins/images/sources/TiledImageSource.js","../src/three/plugins/images/sources/XYZImageSource.js","../src/three/plugins/images/sources/TMSImageSource.js","../src/three/plugins/images/sources/WMTSImageSource.js","../src/three/plugins/images/sources/WMSImageSource.js","../src/three/plugins/images/EPSGTilesPlugin.js","../src/three/plugins/loaders/QuantizedMeshLoader.js","../src/three/plugins/utilities/GeometryClipper.js","../src/three/plugins/utilities/QuantizedMeshClipper.js","../src/three/plugins/QuantizedMeshPlugin.js","../src/three/plugins/CesiumIonAuthPlugin.js","../src/three/plugins/UpdateOnChangePlugin.js","../src/three/plugins/TileCompressionPlugin.js","../src/three/plugins/gltf/metadata/utilities/ClassPropertyHelpers.js","../src/three/plugins/gltf/metadata/classes/ClassProperty.js","../src/three/plugins/gltf/metadata/classes/PropertySetAccessor.js","../src/three/plugins/gltf/metadata/classes/PropertyAttributeAccessor.js","../src/three/plugins/gltf/metadata/classes/PropertyTableAccessor.js","../src/three/plugins/gltf/metadata/utilities/TextureReadUtility.js","../src/three/plugins/gltf/metadata/utilities/TexCoordUtilities.js","../src/three/plugins/gltf/metadata/classes/PropertyTextureAccessor.js","../src/three/plugins/gltf/metadata/classes/StructuralMetadata.js","../src/three/plugins/gltf/GLTFStructuralMetadataExtension.js","../src/three/plugins/gltf/metadata/classes/MeshFeatures.js","../src/three/plugins/gltf/GLTFMeshFeaturesExtension.js","../src/three/plugins/gltf/GLTFCesiumRTCExtension.js","../src/three/plugins/GLTFExtensionsPlugin.js","../src/three/plugins/ReorientationPlugin.js","../src/three/plugins/UnloadTilesPlugin.js","../src/three/plugins/fade/FadeManager.js","../src/three/plugins/fade/wrapFadeMaterial.js","../src/three/plugins/fade/FadeMaterialManager.js","../src/three/plugins/fade/PassThroughBatchedMesh.js","../src/three/plugins/fade/FadeBatchedMesh.js","../src/three/plugins/fade/TilesFadePlugin.js","../src/three/plugins/batched/ModelViewBatchedMesh.js","../src/three/plugins/batched/ExpandingBatchedMesh.js","../src/three/plugins/batched/utilities.js","../src/three/plugins/batched/BatchedTilesPlugin.js","../src/three/plugins/TileFlatteningPlugin.js","../src/three/plugins/images/overlays/TiledTextureComposer.js","../src/three/plugins/images/sources/QuadKeyImageSource.js","../src/three/plugins/images/overlays/utils.js","../src/three/plugins/images/overlays/wrapOverlaysMaterial.js","../src/three/plugins/images/sources/GeoJSONImageSource.js","../src/three/plugins/images/ImageOverlayPlugin.js","../src/three/plugins/LoadRegionPlugin.js","../src/three/plugins/objects/SphereHelper.js","../src/three/plugins/objects/EllipsoidRegionHelper.js","../src/three/plugins/DebugTilesPlugin.js","../src/three/plugins/images/sources/DeepZoomImageSource.js","../src/three/plugins/images/DeepZoomImagePlugin.js","../src/three/plugins/loaders/WMTSCapabilitiesLoader.js","../src/three/plugins/loaders/WMSCapabilitiesLoader.js"],"sourcesContent":["import { Mesh, MeshBasicMaterial, PlaneGeometry, MathUtils, Vector2 } from 'three';\n\nconst _uv = /* @__PURE__ */ new Vector2();\n\nexport const TILE_X = Symbol( 'TILE_X' );\nexport const TILE_Y = Symbol( 'TILE_Y' );\nexport const TILE_LEVEL = Symbol( 'TILE_LEVEL' );\n\n// Base class for supporting tiled images with a consistent size / resolution per tile\nexport class ImageFormatPlugin {\n\n\tget tiling() {\n\n\t\treturn this.imageSource.tiling;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tpixelSize = null,\n\t\t\tcenter = false,\n\t\t\tuseRecommendedSettings = true,\n\t\t\timageSource = null,\n\t\t} = options;\n\n\t\tthis.priority = - 10;\n\t\tthis.tiles = null;\n\n\t\t// tiling scheme\n\t\tthis.imageSource = imageSource;\n\n\t\t// options\n\t\tthis.pixelSize = pixelSize;\n\t\tthis.center = center;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\n\t\tif ( pixelSize !== null ) {\n\n\t\t\tconsole.warn( 'ImageFormatPlugin: \"pixelSize\" has been deprecated in favor of scaling the tiles root.' );\n\n\t\t}\n\n\t}\n\n\t// Plugin functions\n\tinit( tiles ) {\n\n\t\tif ( this.useRecommendedSettings ) {\n\n\t\t\ttiles.errorTarget = 1;\n\t\t\t// TODO: apply skip traversal settings here once supported, as well, for faster loading\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\n\t\tthis.imageSource.fetchOptions = tiles.fetchOptions;\n\t\tthis.imageSource.fetchData = ( url, options ) => {\n\n\t\t\ttiles.invokeAllPlugins( plugin => url = plugin.preprocessURL ? plugin.preprocessURL( url, null ) : url );\n\t\t\treturn tiles.invokeOnePlugin( plugin => plugin !== this && plugin.fetchData && plugin.fetchData( url, options ) );\n\n\t\t};\n\n\t}\n\n\tasync loadRootTileset() {\n\n\t\tconst { tiles, imageSource } = this;\n\t\timageSource.url = imageSource.url || tiles.rootURL;\n\t\ttiles.invokeAllPlugins( plugin => imageSource.url = plugin.preprocessURL ? plugin.preprocessURL( imageSource.url, null ) : imageSource.url );\n\t\tawait imageSource.init();\n\n\t\ttiles.rootURL = imageSource.url;\n\t\treturn this.getTileset( imageSource.url );\n\n\t}\n\n\tasync parseToMesh( buffer, tile, extension, uri, abortSignal ) {\n\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Construct texture\n\t\tconst { imageSource } = this;\n\t\tconst tx = tile[ TILE_X ];\n\t\tconst ty = tile[ TILE_Y ];\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst texture = await imageSource.processBufferToTexture( buffer );\n\n\t\t// clean up the texture if it's not going to be used.\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\ttexture.dispose();\n\t\t\ttexture.image.close();\n\t\t\treturn null;\n\n\t\t}\n\n\t\timageSource.setData( tx, ty, level, texture );\n\n\t\t// Construct mesh\n\t\tlet sx = 1, sy = 1;\n\t\tlet x = 0, y = 0, z = 0;\n\n\t\tconst boundingBox = tile.boundingVolume.box;\n\t\tif ( boundingBox ) {\n\n\t\t\t[ x, y, z ] = boundingBox;\n\t\t\tsx = boundingBox[ 3 ];\n\t\t\tsy = boundingBox[ 7 ];\n\n\t\t}\n\n\t\t// adjust the geometry transform itself rather than the mesh because it reduces the artifact errors\n\t\t// when using batched mesh rendering.\n\t\tconst geometry = new PlaneGeometry( 2 * sx, 2 * sy );\n\t\tconst mesh = new Mesh( geometry, new MeshBasicMaterial( { map: texture, transparent: true } ) );\n\t\tmesh.position.set( x, y, z );\n\n\t\tconst tiling = imageSource.tiling;\n\t\tconst uvRange = tiling.getTileContentUVBounds( tx, ty, level );\n\t\tconst { uv } = geometry.attributes;\n\t\tfor ( let i = 0; i < uv.count; i ++ ) {\n\n\t\t\t_uv.fromBufferAttribute( uv, i );\n\t\t\t_uv.x = MathUtils.mapLinear( _uv.x, 0, 1, uvRange[ 0 ], uvRange[ 2 ] );\n\t\t\t_uv.y = MathUtils.mapLinear( _uv.y, 0, 1, uvRange[ 1 ], uvRange[ 3 ] );\n\t\t\tuv.setXY( i, _uv.x, _uv.y );\n\n\t\t}\n\n\t\treturn mesh;\n\n\t}\n\n\tpreprocessNode( tile ) {\n\n\t\t// generate children\n\t\tconst { tiling } = this;\n\t\tconst maxLevel = tiling.maxLevel;\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tif ( level < maxLevel && tile.parent !== null ) {\n\n\t\t\tthis.expandChildren( tile );\n\n\t\t}\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tconst tx = tile[ TILE_X ];\n\t\tconst ty = tile[ TILE_Y ];\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst { imageSource } = this;\n\t\tif ( imageSource.has( tx, ty, level ) ) {\n\n\t\t\t// only dispose of the image data if it hasn't been aborted\n\t\t\timageSource.release( tx, ty, level );\n\n\t\t}\n\n\t}\n\n\t// Local functions\n\tgetTileset( baseUrl ) {\n\n\t\tconst { tiling, tiles } = this;\n\t\tconst minLevel = tiling.minLevel;\n\t\tconst { tileCountX, tileCountY } = tiling.getLevel( minLevel );\n\n\t\t// generate all children for the root\n\t\tconst children = [];\n\t\tfor ( let x = 0; x < tileCountX; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < tileCountY; y ++ ) {\n\n\t\t\t\tconst child = this.createChild( x, y, minLevel );\n\t\t\t\tif ( child !== null ) {\n\n\t\t\t\t\tchildren.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate tileset\n\t\tconst tileset = {\n\t\t\tasset: {\n\t\t\t\tversion: '1.1'\n\t\t\t},\n\t\t\tgeometricError: 1e5,\n\t\t\troot: {\n\t\t\t\trefine: 'REPLACE',\n\t\t\t\tgeometricError: 1e5,\n\t\t\t\tboundingVolume: this.createBoundingVolume( 0, 0, - 1 ),\n\t\t\t\tchildren,\n\n\t\t\t\t[ TILE_LEVEL ]: - 1,\n\t\t\t\t[ TILE_X ]: 0,\n\t\t\t\t[ TILE_Y ]: 0,\n\t\t\t}\n\t\t};\n\n\t\ttiles.preprocessTileset( tileset, baseUrl );\n\n\t\treturn tileset;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.imageSource.getUrl( x, y, level );\n\n\t}\n\n\tcreateBoundingVolume( x, y, level ) {\n\n\t\tconst { center, pixelSize, tiling } = this;\n\t\tconst { pixelWidth, pixelHeight } = tiling.getLevel( tiling.maxLevel );\n\n\t\t// calculate the world space bounds position from the range\n\t\tconst [ minX, minY, maxX, maxY ] = level === - 1 ? tiling.getContentBounds( true ) : tiling.getTileBounds( x, y, level, true );\n\t\tlet extentsX = ( maxX - minX ) / 2;\n\t\tlet extentsY = ( maxY - minY ) / 2;\n\t\tlet centerX = minX + extentsX;\n\t\tlet centerY = minY + extentsY;\n\t\tif ( center ) {\n\n\t\t\tcenterX -= 0.5;\n\t\t\tcenterY -= 0.5;\n\n\t\t}\n\n\t\t// scale the fields\n\t\tif ( pixelSize ) {\n\n\t\t\tcenterX *= pixelWidth * pixelSize;\n\t\t\textentsX *= pixelWidth * pixelSize;\n\n\t\t\tcenterY *= pixelHeight * pixelSize;\n\t\t\textentsY *= pixelHeight * pixelSize;\n\n\t\t} else {\n\n\t\t\tcenterX *= tiling.aspectRatio;\n\t\t\textentsX *= tiling.aspectRatio;\n\n\t\t}\n\n\t\t// return bounding box\n\t\treturn {\n\t\t\tbox: [\n\t\t\t\t// center\n\t\t\t\tcenterX, centerY, 0,\n\n\t\t\t\t// x, y, z half vectors\n\t\t\t\textentsX, 0.0, 0.0,\n\t\t\t\t0.0, extentsY, 0.0,\n\t\t\t\t0.0, 0.0, 0.0,\n\t\t\t],\n\t\t};\n\n\t}\n\n\tcreateChild( x, y, level ) {\n\n\t\tconst { pixelSize, tiling } = this;\n\t\tif ( ! tiling.getTileExists( x, y, level ) ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Calculate geometric error: size of one pixel in world space.\n\t\t// The tile contents span [0, 1] along Y and [0, aspectRatio] along X.\n\t\tconst { pixelWidth, pixelHeight } = tiling.getLevel( level );\n\t\tlet geometricError = Math.max( tiling.aspectRatio / pixelWidth, 1 / pixelHeight );\n\n\t\t// apply deprecated pixelSize scaling if specified\n\t\tif ( pixelSize ) {\n\n\t\t\tconst maxLevelInfo = tiling.getLevel( tiling.maxLevel );\n\t\t\tgeometricError *= pixelSize * Math.max( maxLevelInfo.pixelWidth, maxLevelInfo.pixelHeight );\n\n\t\t}\n\n\t\t// Generate the node\n\t\treturn {\n\t\t\trefine: 'REPLACE',\n\t\t\tgeometricError: geometricError,\n\t\t\tboundingVolume: this.createBoundingVolume( x, y, level ),\n\t\t\tcontent: {\n\t\t\t\turi: this.getUrl( x, y, level ),\n\t\t\t},\n\t\t\tchildren: [],\n\n\t\t\t// save the tile params so we can expand later\n\t\t\t[ TILE_X ]: x,\n\t\t\t[ TILE_Y ]: y,\n\t\t\t[ TILE_LEVEL ]: level,\n\t\t};\n\n\t}\n\n\texpandChildren( tile ) {\n\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst x = tile[ TILE_X ];\n\t\tconst y = tile[ TILE_Y ];\n\n\t\tfor ( let cx = 0; cx < 2; cx ++ ) {\n\n\t\t\tfor ( let cy = 0; cy < 2; cy ++ ) {\n\n\t\t\t\tconst child = this.createChild( 2 * x + cx, 2 * y + cy, level + 1 );\n\t\t\t\tif ( child ) {\n\n\t\t\t\t\ttile.children.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\n\nexport function getCartographicToMeterDerivative( ellipsoid, lat, lon ) {\n\n\tconst EPS = 1e-5;\n\tconst lonp = lon + EPS;\n\tlet latp = lat + EPS;\n\tif ( Math.abs( latp ) > Math.PI / 2 ) {\n\n\t\tlatp = latp - EPS;\n\n\t}\n\n\tellipsoid.getCartographicToPosition( lat, lon, 0, _v0 );\n\n\tellipsoid.getCartographicToPosition( latp, lon, 0, _v1 );\n\tconst dy = _v0.distanceTo( _v1 ) / EPS;\n\n\tellipsoid.getCartographicToPosition( lat, lonp, 0, _v1 );\n\tconst dx = _v0.distanceTo( _v1 ) / EPS;\n\n\treturn [ dx, dy ];\n\n}\n","import { ImageFormatPlugin, TILE_LEVEL, TILE_X, TILE_Y } from './ImageFormatPlugin.js';\nimport { MathUtils, PlaneGeometry, Sphere, Vector2, Vector3 } from 'three';\nimport { getCartographicToMeterDerivative } from './utils/getCartographicToMeterDerivative.js';\n\nconst MIN_LON_VERTS = 30;\nconst MIN_LAT_VERTS = 15;\n\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _uv = /* @__PURE__ */ new Vector2();\nconst _sphere = /* @__PURE__ */ new Sphere();\n\nexport class EllipsoidProjectionTilesPlugin extends ImageFormatPlugin {\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tshape = 'planar',\n\t\t\tendCaps = true,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\t// options\n\t\tthis.shape = shape;\n\t\tthis.endCaps = endCaps;\n\n\t}\n\n\t// override the parse to mesh logic to support a region mesh\n\tasync parseToMesh( buffer, tile, ...args ) {\n\n\t\tconst mesh = await super.parseToMesh( buffer, tile, ...args );\n\n\t\t// if displaying the tiles as an ellipsoid\n\t\tconst { shape, projection, tiles, tiling } = this;\n\t\tif ( shape === 'ellipsoid' ) {\n\n\t\t\tconst ellipsoid = tiles.ellipsoid;\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\t// new geometry\n\t\t\t// default to a minimum number of vertices per degree on each axis\n\t\t\tconst [ west, south, east, north ] = tile.boundingVolume.region;\n\t\t\tconst latVerts = Math.ceil( ( north - south ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst lonVerts = Math.ceil( ( east - west ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst yVerts = Math.max( MIN_LAT_VERTS, latVerts );\n\t\t\tconst xVerts = Math.max( MIN_LON_VERTS, lonVerts );\n\t\t\tconst geometry = new PlaneGeometry( 1, 1, xVerts, yVerts );\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true, true );\n\t\t\tconst uvRange = tiling.getTileContentUVBounds( x, y, level );\n\n\t\t\t// adjust the geometry to position it at the region\n\t\t\tconst { position, normal, uv } = geometry.attributes;\n\t\t\tconst vertCount = position.count;\n\t\t\ttile.cached.boundingVolume.getSphere( _sphere );\n\t\t\tfor ( let i = 0; i < vertCount; i ++ ) {\n\n\t\t\t\t// retrieve attributes\n\t\t\t\t_pos.fromBufferAttribute( position, i );\n\t\t\t\t_uv.fromBufferAttribute( uv, i );\n\n\t\t\t\t// convert the plane position to lat / lon\n\t\t\t\tconst lon = projection.convertProjectionToLongitude( MathUtils.mapLinear( _uv.x, 0, 1, minU, maxU ) );\n\t\t\t\tlet lat = projection.convertProjectionToLatitude( MathUtils.mapLinear( _uv.y, 0, 1, minV, maxV ) );\n\n\t\t\t\t// snap the edges to the poles if using mercator projection and end caps are enabled\n\t\t\t\tif ( projection.isMercator && this.endCaps ) {\n\n\t\t\t\t\tif ( maxV === 1 && _uv.y === 1 ) {\n\n\t\t\t\t\t\tlat = Math.PI / 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( minV === 0 && _uv.y === 0 ) {\n\n\t\t\t\t\t\tlat = - Math.PI / 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// ensure we have an edge loop positioned at the mercator limit to avoid UV distortion\n\t\t\t\t// as much as possible at low LoDs.\n\t\t\t\tif ( projection.isMercator && _uv.y !== 0 && _uv.y !== 1 ) {\n\n\t\t\t\t\tconst latLimit = projection.convertProjectionToLatitude( 1 );\n\t\t\t\t\tconst vStep = 1 / yVerts;\n\n\t\t\t\t\tconst prevLat = MathUtils.mapLinear( _uv.y - vStep, 0, 1, south, north );\n\t\t\t\t\tconst nextLat = MathUtils.mapLinear( _uv.y + vStep, 0, 1, south, north );\n\t\t\t\t\tif ( lat > latLimit && prevLat < latLimit ) {\n\n\t\t\t\t\t\tlat = latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( lat < - latLimit && nextLat > - latLimit ) {\n\n\t\t\t\t\t\tlat = - latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// get the position and normal\n\t\t\t\tellipsoid.getCartographicToPosition( lat, lon, 0, _pos ).sub( _sphere.center );\n\t\t\t\tellipsoid.getCartographicToNormal( lat, lon, _norm );\n\n\t\t\t\t// map from the uvs for the tile into the uv range\n\t\t\t\tconst u = MathUtils.mapLinear( projection.convertLongitudeToProjection( lon ), minU, maxU, uvRange[ 0 ], uvRange[ 2 ] );\n\t\t\t\tconst v = MathUtils.mapLinear( projection.convertLatitudeToProjection( lat ), minV, maxV, uvRange[ 1 ], uvRange[ 3 ] );\n\n\t\t\t\t// update the geometry\n\t\t\t\tuv.setXY( i, u, v );\n\t\t\t\tposition.setXYZ( i, ..._pos );\n\t\t\t\tnormal.setXYZ( i, ..._norm );\n\n\t\t\t}\n\n\t\t\tmesh.geometry = geometry;\n\t\t\tmesh.position.copy( _sphere.center );\n\n\t\t}\n\n\t\treturn mesh;\n\n\t}\n\n\tcreateBoundingVolume( x, y, level ) {\n\n\t\tif ( this.shape === 'ellipsoid' ) {\n\n\t\t\tconst { tiling, endCaps } = this;\n\t\t\tconst isRoot = level === - 1;\n\t\t\tconst normalizedBounds = isRoot ? tiling.getContentBounds( true ) : tiling.getTileBounds( x, y, level, true, true );\n\t\t\tconst cartBounds = isRoot ? tiling.getContentBounds() : tiling.getTileBounds( x, y, level, false, true );\n\n\t\t\tif ( endCaps ) {\n\n\t\t\t\t// if the north side is at the edge\n\t\t\t\tif ( normalizedBounds[ 3 ] === 1 ) {\n\n\t\t\t\t\tcartBounds[ 3 ] = Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t\t// if the south side is at the edge\n\t\t\t\tif ( normalizedBounds[ 1 ] === 0 ) {\n\n\t\t\t\t\tcartBounds[ 1 ] = - Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tregion: [ ...cartBounds, - 1, 1 ],\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn super.createBoundingVolume( x, y, level );\n\n\t\t}\n\n\t}\n\n\tcreateChild( ...args ) {\n\n\t\tconst tile = super.createChild( ...args );\n\n\t\tconst { shape, projection, tiling } = this;\n\t\tif ( tile && shape === 'ellipsoid' ) {\n\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\t// if this is the root node then skip calculating the geometric error\n\t\t\tif ( level === - 1 ) {\n\n\t\t\t\ttile.geometricError = 1e50;\n\t\t\t\treturn parent;\n\n\t\t\t}\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true );\n\t\t\tconst { tilePixelWidth, tilePixelHeight } = tiling.getLevel( level );\n\n\t\t\t// one pixel width in uv space\n\t\t\tconst tileUWidth = ( maxU - minU ) / tilePixelWidth;\n\t\t\tconst tileVWidth = ( maxV - minV ) / tilePixelHeight;\n\n\t\t\t// calculate the region ranges\n\t\t\tconst [ /* west */, south, east, north ] = tiling.getTileBounds( x, y, level );\n\n\t\t\t// calculate the changes in lat / lon at the given point\n\t\t\t// find the most bowed point of the latitude range since the amount that latitude changes is\n\t\t\t// dependent on the Y value of the image\n\t\t\tconst midLat = ( south > 0 ) !== ( north > 0 ) ? 0 : Math.min( Math.abs( south ), Math.abs( north ) );\n\t\t\tconst midV = projection.convertLatitudeToProjection( midLat );\n\t\t\tconst lonFactor = projection.getLongitudeDerivativeAtProjection( minU );\n\t\t\tconst latFactor = projection.getLatitudeDerivativeAtProjection( midV );\n\n\t\t\t// calculate the size of a pixel on the surface\n\t\t\tconst [ xDeriv, yDeriv ] = getCartographicToMeterDerivative( this.tiles.ellipsoid, midLat, east );\n\t\t\tconst projectedPixelWidth = Math.max( tileUWidth * lonFactor * xDeriv, tileVWidth * latFactor * yDeriv );\n\t\t\ttile.geometricError = projectedPixelWidth;\n\n\t\t}\n\n\t\treturn tile;\n\n\t}\n\n}\n\n","import { MathUtils } from 'three';\n\n// Class for storing and querying a certain projection scheme for an image and converting\n// between the [0, 1] image range to cartographic longitude / latitude values.\nexport class ProjectionScheme {\n\n\tget isMercator() {\n\n\t\treturn this.scheme === 'EPSG:3857';\n\n\t}\n\n\tconstructor( scheme = 'EPSG:4326' ) {\n\n\t\tthis.scheme = scheme;\n\t\tthis.tileCountX = 1;\n\t\tthis.tileCountY = 1;\n\n\t\tthis.setScheme( scheme );\n\n\t}\n\n\tsetScheme( scheme ) {\n\n\t\tthis.scheme = scheme;\n\t\tswitch ( scheme ) {\n\n\t\t\t// equirect\n\t\t\tcase 'CRS:84':\n\t\t\tcase 'EPSG:4326':\n\t\t\t\tthis.tileCountX = 2;\n\t\t\t\tthis.tileCountY = 1;\n\t\t\t\tbreak;\n\n\t\t\t// mercator\n\t\t\tcase 'EPSG:3857':\n\t\t\t\tthis.tileCountX = 1;\n\t\t\t\tthis.tileCountY = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( `ProjectionScheme: Unknown projection scheme \"${ scheme }\"` );\n\n\t\t}\n\n\t}\n\n\tconvertProjectionToLatitude( v ) {\n\n\t\tif ( this.isMercator ) {\n\n\t\t\t// https://gis.stackexchange.com/questions/447421/convert-a-point-on-a-flat-2d-web-mercator-map-image-to-a-coordinate\n\t\t\tconst ratio = MathUtils.mapLinear( v, 0, 1, - 1, 1 );\n\t\t\treturn 2 * Math.atan( Math.exp( ratio * Math.PI ) ) - Math.PI / 2;\n\n\t\t} else {\n\n\t\t\treturn MathUtils.mapLinear( v, 0, 1, - Math.PI / 2, Math.PI / 2 );\n\n\t\t}\n\n\t}\n\n\tconvertProjectionToLongitude( v ) {\n\n\t\treturn MathUtils.mapLinear( v, 0, 1, - Math.PI, Math.PI );\n\n\t}\n\n\tconvertLatitudeToProjection( lat ) {\n\n\t\tif ( this.isMercator ) {\n\n\t\t\t// https://stackoverflow.com/questions/14329691/convert-latitude-longitude-point-to-a-pixels-x-y-on-mercator-projection\n\t\t\tconst mercatorN = Math.log( Math.tan( ( Math.PI / 4 ) + ( lat / 2 ) ) );\n\t\t\treturn ( 1 / 2 ) + ( 1 * mercatorN / ( 2 * Math.PI ) );\n\n\t\t} else {\n\n\t\t\treturn MathUtils.mapLinear( lat, - Math.PI / 2, Math.PI / 2, 0, 1 );\n\n\t\t}\n\n\t}\n\n\tconvertLongitudeToProjection( lon ) {\n\n\t\treturn ( lon + Math.PI ) / ( 2 * Math.PI );\n\n\t}\n\n\tgetLongitudeDerivativeAtProjection( value ) {\n\n\t\treturn 2 * Math.PI;\n\n\t}\n\n\tgetLatitudeDerivativeAtProjection( value ) {\n\n\t\tconst EPS = 1e-5;\n\t\tlet yp = value - EPS;\n\t\tif ( yp < 0 ) {\n\n\t\t\typ = value + EPS;\n\n\t\t}\n\n\t\tif ( this.isMercator ) {\n\n\t\t\t// TODO: why is this 2 * Math.PI rather than Math.PI?\n\t\t\treturn Math.abs( this.convertProjectionToLatitude( value ) - this.convertProjectionToLatitude( yp ) ) / EPS;\n\n\t\t} else {\n\n\t\t\treturn Math.PI;\n\n\t\t}\n\n\t}\n\n\tgetBounds() {\n\n\t\treturn [\n\t\t\tthis.convertProjectionToLongitude( 0 ), this.convertProjectionToLatitude( 0 ),\n\t\t\tthis.convertProjectionToLongitude( 1 ), this.convertProjectionToLatitude( 1 ),\n\t\t];\n\n\t}\n\n}\n","function hash( ...args ) {\n\n\treturn args.join( '_' );\n\n}\n\n// class for retrieving and locking data being requested\n// \"fetchItem\" and \"disposeItem\" should be implemented\nexport class DataCache {\n\n\tconstructor() {\n\n\t\tthis.cache = {};\n\t\tthis.count = 0;\n\t\tthis.cachedBytes = 0;\n\t\tthis.active = 0;\n\n\t}\n\n\t// overridable\n\tfetchItem() {}\n\tdisposeItem() {}\n\tgetMemoryUsage( item ) {\n\n\t\treturn 0;\n\n\t}\n\n\t// sets the data in the cache explicitly without need to load\n\tsetData( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst data = args.pop();\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tthrow new Error( `DataCache: \"${ key }\" is already present.` );\n\n\t\t} else {\n\n\t\t\tthis.cache[ key ] = {\n\t\t\t\tabortController: new AbortController(),\n\t\t\t\tresult: data,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: this.getMemoryUsage( data ),\n\t\t\t};\n\t\t\tthis.count ++;\n\t\t\tthis.cachedBytes += this.cache[ key ].bytes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t// fetches the associated data if it doesn't exist and increments the lock counter\n\tlock( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tcache[ key ].count ++;\n\n\t\t} else {\n\n\t\t\tconst abortController = new AbortController();\n\t\t\tconst info = {\n\t\t\t\tabortController,\n\t\t\t\tresult: null,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: 0,\n\t\t\t};\n\n\t\t\tthis.active ++;\n\t\t\tinfo.result = this.fetchItem( args, abortController.signal );\n\t\t\tif ( info.result instanceof Promise ) {\n\n\t\t\t\tinfo.result.then( res => {\n\n\t\t\t\t\tinfo.result = res;\n\t\t\t\t\tinfo.bytes = this.getMemoryUsage( res );\n\t\t\t\t\tthis.cachedBytes += info.bytes;\n\t\t\t\t\treturn res;\n\n\t\t\t\t} ).finally( () => {\n\n\t\t\t\t\tthis.active --;\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\t// error logging and handling can be handled elsewhere\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tthis.active --;\n\t\t\t\tinfo.bytes = this.getMemoryUsage( info.result );\n\t\t\t\tthis.cachedBytes += info.bytes;\n\n\t\t\t}\n\n\t\t\tthis.cache[ key ] = info;\n\t\t\tthis.count ++;\n\n\t\t}\n\n\t\treturn cache[ key ].result;\n\n\t}\n\n\t// decrements the lock counter for the item and deletes the item if it has reached zero\n\trelease( ...args ) {\n\n\t\tconst key = hash( ...args );\n\t\tthis.releaseViaFullKey( key );\n\n\t}\n\n\t// get the loaded item\n\tget( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\treturn cache[ key ].result;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\thas( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\treturn key in cache;\n\n\t}\n\n\t// dispose all items\n\tdispose() {\n\n\t\tconst { cache } = this;\n\t\tfor ( const key in cache ) {\n\n\t\t\tconst { abortController } = cache[ key ];\n\t\t\tabortController.abort();\n\n\t\t\tthis.releaseViaFullKey( key, true );\n\n\t\t}\n\n\t\tthis.cache = {};\n\n\t}\n\n\t// releases an item with an optional force flag\n\treleaseViaFullKey( key, force = false ) {\n\n\t\tconst { cache } = this;\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\t// decrement the lock\n\t\t\tconst info = cache[ key ];\n\t\t\tinfo.count --;\n\n\t\t\t// if the item is no longer being used\n\t\t\tif ( info.count === 0 || force ) {\n\n\t\t\t\tconst disposeCallback = () => {\n\n\t\t\t\t\t// if the object isn't in the cache anymore then exit early because it's been disposed elsewhere\n\t\t\t\t\tif ( cache[ key ] !== info ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// abort any loads\n\t\t\t\t\tconst { result, abortController } = info;\n\t\t\t\t\tabortController.abort();\n\n\t\t\t\t\t// dispose of the object even if it still is in progress\n\t\t\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\t\t\t// \"disposeItem\" will throw potentially if fetch, etc are cancelled using the abort signal\n\t\t\t\t\t\tresult.then( item => {\n\n\t\t\t\t\t\t\tthis.disposeItem( item );\n\t\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t\t} ).catch( () => {} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disposeItem( result );\n\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t};\n\n\t\t\t\tif ( force ) {\n\n\t\t\t\t\t// if we're forcing disposal then dispose immediately\n\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// queue for disposal in a frame here - we need to make sure we're not disposing of something twice\n\t\t\t\t\t// this can get called multiple times in a row to increment then decrement again.\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\tif ( info.count === 0 ) {\n\n\t\t\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tthrow new Error( 'DataCache: Attempting to release key that does not exist' );\n\n\t}\n\n}\n","import { MathUtils } from 'three';\n\nfunction doBoundsIntersect( a, b ) {\n\n\tconst [ aMinX, aMinY, aMaxX, aMaxY ] = a;\n\tconst [ bMinX, bMinY, bMaxX, bMaxY ] = b;\n\n\treturn ! ( aMinX >= bMaxX || aMaxX <= bMinX || aMinY >= bMaxY || aMaxY <= bMinY );\n\n}\n\n// Class for storing and querying a tiling scheme including a bounds, origin, and negative tile indices.\n// Assumes that tiles are split into four child tiles at each level.\n\n// Projection Bounds: The full extent of content representable by the projection.\n// Content Bounds: The range within the content bounds contains relevant, loadable, and renderable data.\n// Tile Bounds: The per-layer extent covered by the tiles to be loaded. This range may be larger than\n// both the projection and content bounds.\nexport class TilingScheme {\n\n\tget levelCount() {\n\n\t\treturn this._levels.length;\n\n\t}\n\n\tget maxLevel() {\n\n\t\treturn this.levelCount - 1;\n\n\t}\n\n\tget minLevel() {\n\n\t\tconst levels = this._levels;\n\t\tfor ( let i = 0; i < levels.length; i ++ ) {\n\n\t\t\tif ( levels[ i ] !== null ) {\n\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t// prioritize user-set bounds over projection bounds if present\n\tget contentBounds() {\n\n\t\treturn this._contentBounds ?? this.projection?.getBounds() ?? [ 0, 0, 1, 1 ];\n\n\t}\n\n\tget aspectRatio() {\n\n\t\tconst { pixelWidth, pixelHeight } = this.getLevel( this.maxLevel );\n\t\treturn pixelWidth / pixelHeight;\n\n\t}\n\n\tconstructor() {\n\n\t\tthis.flipY = false;\n\t\tthis.pixelOverlap = 0;\n\n\t\t// The origin and bounds\n\t\tthis._contentBounds = null;\n\t\tthis.projection = null;\n\n\t\tthis._levels = [];\n\n\t}\n\n\t// build the zoom levels\n\tsetLevel( level, options = {} ) {\n\n\t\tconst levels = this._levels;\n\t\twhile ( levels.length < level ) {\n\n\t\t\tlevels.push( null );\n\n\t\t}\n\n\t\tconst {\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t\ttileCountX = 2 ** level,\n\t\t\ttileCountY = 2 ** level,\n\t\t\ttileBounds = null,\n\t\t} = options;\n\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * tileCountX,\n\t\t\tpixelHeight = tilePixelHeight * tileCountY,\n\t\t} = options;\n\n\t\tlevels[ level ] = {\n\t\t\t// The pixel resolution of each tile.\n\t\t\ttilePixelWidth,\n\t\t\ttilePixelHeight,\n\n\t\t\t// The total pixel resolution of the final image at this level. These numbers\n\t\t\t// may not be a round multiple of the tile width.\n\t\t\tpixelWidth,\n\t\t\tpixelHeight,\n\n\t\t\t// Or the total number of tiles that can be loaded at this level.\n\t\t\ttileCountX,\n\t\t\ttileCountY,\n\n\t\t\t// The bounds covered by the extent of the tiles at this loaded. The actual content covered by the overall tileset\n\t\t\t// may be a subset of this range (eg there may be unused space).\n\t\t\ttileBounds,\n\t\t};\n\n\t}\n\n\tgenerateLevels( levels, rootTileX, rootTileY, options = {} ) {\n\n\t\tconst {\n\t\t\tminLevel = 0,\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t} = options;\n\n\t\tconst maxLevel = levels - 1;\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * rootTileX * ( 2 ** maxLevel ),\n\t\t\tpixelHeight = tilePixelHeight * rootTileY * ( 2 ** maxLevel ),\n\t\t} = options;\n\t\tfor ( let level = minLevel; level < levels; level ++ ) {\n\n\t\t\tconst invLevel = levels - level - 1;\n\t\t\tconst levelPixelWidth = Math.ceil( pixelWidth * ( 2 ** - invLevel ) );\n\t\t\tconst levelPixelHeight = Math.ceil( pixelHeight * ( 2 ** - invLevel ) );\n\t\t\tconst tileCountX = Math.ceil( levelPixelWidth / tilePixelWidth );\n\t\t\tconst tileCountY = Math.ceil( levelPixelHeight / tilePixelHeight );\n\n\t\t\tthis.setLevel( level, {\n\t\t\t\ttilePixelWidth,\n\t\t\t\ttilePixelHeight,\n\t\t\t\tpixelWidth: levelPixelWidth,\n\t\t\t\tpixelHeight: levelPixelHeight,\n\t\t\t\ttileCountX,\n\t\t\t\ttileCountY,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tgetLevel( level ) {\n\n\t\treturn this._levels[ level ];\n\n\t}\n\n\t// bounds representing the contentful region of the image\n\tsetContentBounds( minX, minY, maxX, maxY ) {\n\n\t\tthis._contentBounds = [ minX, minY, maxX, maxY ];\n\n\t}\n\n\tsetProjection( projection ) {\n\n\t\tthis.projection = projection;\n\n\t}\n\n\t// query functions\n\tgetTileAtPoint( bx, by, level, normalized = false ) {\n\n\t\tconst { flipY } = this;\n\t\tconst { tileCountX, tileCountY, tileBounds } = this.getLevel( level );\n\t\tconst xStride = 1 / tileCountX;\n\t\tconst yStride = 1 / tileCountY;\n\n\t\tif ( ! normalized ) {\n\n\t\t\t[ bx, by ] = this.toNormalizedPoint( bx, by );\n\n\t\t}\n\n\t\tif ( tileBounds ) {\n\n\t\t\tconst normalizedBounds = this.toNormalizedRange( tileBounds );\n\t\t\tbx = MathUtils.mapLinear( bx, normalizedBounds[ 0 ], normalizedBounds[ 2 ], 0, 1 );\n\t\t\tby = MathUtils.mapLinear( by, normalizedBounds[ 1 ], normalizedBounds[ 3 ], 0, 1 );\n\n\t\t}\n\n\t\tconst tx = Math.floor( bx / xStride );\n\t\tlet ty = Math.floor( by / yStride );\n\n\t\tif ( flipY ) {\n\n\t\t\tty = tileCountY - 1 - ty;\n\n\t\t}\n\n\t\treturn [ tx, ty ];\n\n\t}\n\n\tgetTilesInRange( minX, minY, maxX, maxY, level, normalized = false ) {\n\n\t\t// check if the range is outside the content bounds\n\t\tconst range = [ minX, minY, maxX, maxY ];\n\t\tconst contentBounds = this.getContentBounds( normalized );\n\t\tlet tileBounds = this.getLevel( level ).tileBounds;\n\t\tif ( ! doBoundsIntersect( range, contentBounds ) ) {\n\n\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t}\n\n\t\t// check if the range is outside the tile bounds\n\t\tif ( tileBounds ) {\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ttileBounds = this.toNormalizedRange( tileBounds );\n\n\t\t\t}\n\n\t\t\tif ( ! doBoundsIntersect( range, contentBounds ) ) {\n\n\t\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst [ clampedMinX, clampedMinY, clampedMaxX, clampedMaxY ] = this.clampToContentBounds( range, normalized );\n\t\tconst minTile = this.getTileAtPoint( clampedMinX, clampedMinY, level, normalized );\n\t\tconst maxTile = this.getTileAtPoint( clampedMaxX, clampedMaxY, level, normalized );\n\n\t\tif ( this.flipY ) {\n\n\t\t\t[ minTile[ 1 ], maxTile[ 1 ] ] = [ maxTile[ 1 ], minTile[ 1 ] ];\n\n\t\t}\n\n\t\tconst { tileCountX, tileCountY } = this.getLevel( level );\n\t\tconst [ minTileX, minTileY ] = minTile;\n\t\tconst [ maxTileX, maxTileY ] = maxTile;\n\n\t\tif ( maxTileX < 0 || maxTileY < 0 || minTileX >= tileCountX || minTileY >= tileCountY ) {\n\n\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t}\n\n\t\treturn [\n\t\t\tMathUtils.clamp( minTileX, 0, tileCountX - 1 ),\n\t\t\tMathUtils.clamp( minTileY, 0, tileCountY - 1 ),\n\t\t\tMathUtils.clamp( maxTileX, 0, tileCountX - 1 ),\n\t\t\tMathUtils.clamp( maxTileY, 0, tileCountY - 1 ),\n\t\t];\n\n\t}\n\n\tgetTileExists( x, y, level ) {\n\n\t\tconst [ rminx, rminy, rmaxx, rmaxy ] = this.contentBounds;\n\t\tconst [ tminx, tminy, tmaxx, tmaxy ] = this.getTileBounds( x, y, level );\n\t\tconst isDegenerate = tminx >= tmaxx || tminy >= tmaxy;\n\n\t\t// TODO: is supporting \"just touch\" correct?\n\t\treturn ! isDegenerate && tminx <= rmaxx && tminy <= rmaxy && tmaxx >= rminx && tmaxy >= rminy;\n\n\t}\n\n\tgetContentBounds( normalized = false ) {\n\n\t\tconst { projection } = this;\n\t\tconst bounds = [ ...this.contentBounds ];\n\t\tif ( projection && normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertLongitudeToProjection( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertLatitudeToProjection( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertLongitudeToProjection( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertLatitudeToProjection( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\t// returns the UV range associated with the content in the given tile\n\tgetTileContentUVBounds( x, y, level ) {\n\n\t\tconst [ minU, minV, maxU, maxV ] = this.getTileBounds( x, y, level, true, true );\n\t\tconst [ fullMinU, fullMinV, fullMaxU, fullMaxV ] = this.getTileBounds( x, y, level, true, false );\n\t\treturn [\n\t\t\tMathUtils.mapLinear( minU, fullMinU, fullMaxU, 0, 1 ),\n\t\t\tMathUtils.mapLinear( minV, fullMinV, fullMaxV, 0, 1 ),\n\t\t\tMathUtils.mapLinear( maxU, fullMinU, fullMaxU, 0, 1 ),\n\t\t\tMathUtils.mapLinear( maxV, fullMinV, fullMaxV, 0, 1 ),\n\t\t];\n\n\t}\n\n\tgetTileBounds( x, y, level, normalized = false, clampToProjection = true ) {\n\n\t\tconst { flipY, pixelOverlap, projection } = this;\n\t\tconst { tilePixelWidth, tilePixelHeight, pixelWidth, pixelHeight, tileBounds } = this.getLevel( level );\n\n\t\tlet tileLeft = tilePixelWidth * x - pixelOverlap;\n\t\tlet tileTop = tilePixelHeight * y - pixelOverlap;\n\t\tlet tileRight = tileLeft + tilePixelWidth + pixelOverlap * 2;\n\t\tlet tileBottom = tileTop + tilePixelHeight + pixelOverlap * 2;\n\n\t\t// clamp\n\t\ttileLeft = Math.max( tileLeft, 0 );\n\t\ttileTop = Math.max( tileTop, 0 );\n\t\ttileRight = Math.min( tileRight, pixelWidth );\n\t\ttileBottom = Math.min( tileBottom, pixelHeight );\n\n\t\t// normalized\n\t\ttileLeft = tileLeft / pixelWidth;\n\t\ttileRight = tileRight / pixelWidth;\n\t\ttileTop = tileTop / pixelHeight;\n\t\ttileBottom = tileBottom / pixelHeight;\n\n\t\t// invert y\n\t\tif ( flipY ) {\n\n\t\t\tconst extents = ( tileBottom - tileTop ) / 2;\n\t\t\tconst centerY = ( tileTop + tileBottom ) / 2;\n\t\t\tconst invCenterY = 1.0 - centerY;\n\n\t\t\ttileTop = invCenterY - extents;\n\t\t\ttileBottom = invCenterY + extents;\n\n\t\t}\n\n\t\tlet bounds = [ tileLeft, tileTop, tileRight, tileBottom ];\n\t\tif ( tileBounds ) {\n\n\t\t\tconst normBounds = this.toNormalizedRange( tileBounds );\n\t\t\tbounds[ 0 ] = MathUtils.mapLinear( bounds[ 0 ], 0, 1, normBounds[ 0 ], normBounds[ 2 ] );\n\t\t\tbounds[ 2 ] = MathUtils.mapLinear( bounds[ 2 ], 0, 1, normBounds[ 0 ], normBounds[ 2 ] );\n\t\t\tbounds[ 1 ] = MathUtils.mapLinear( bounds[ 1 ], 0, 1, normBounds[ 1 ], normBounds[ 3 ] );\n\t\t\tbounds[ 3 ] = MathUtils.mapLinear( bounds[ 3 ], 0, 1, normBounds[ 1 ], normBounds[ 3 ] );\n\n\t\t}\n\n\t\tif ( clampToProjection ) {\n\n\t\t\tbounds = this.clampToProjectionBounds( bounds, true );\n\n\t\t}\n\n\t\tif ( projection && ! normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertProjectionToLongitude( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertProjectionToLatitude( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertProjectionToLongitude( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertProjectionToLatitude( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\ttoNormalizedPoint( x, y ) {\n\n\t\tconst { projection } = this;\n\t\tconst result = [ x, y ];\n\t\tif ( this.projection ) {\n\n\t\t\tresult[ 0 ] = projection.convertLongitudeToProjection( result[ 0 ] );\n\t\t\tresult[ 1 ] = projection.convertLatitudeToProjection( result[ 1 ] );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\ttoNormalizedRange( range ) {\n\n\t\treturn [\n\t\t\t...this.toNormalizedPoint( range[ 0 ], range[ 1 ] ),\n\t\t\t...this.toNormalizedPoint( range[ 2 ], range[ 3 ] ),\n\t\t];\n\n\t}\n\n\ttoCartographicPoint( x, y ) {\n\n\t\tconst { projection } = this;\n\t\tconst result = [ x, y ];\n\t\tif ( this.projection ) {\n\n\t\t\tresult[ 0 ] = projection.convertProjectionToLongitude( result[ 0 ] );\n\t\t\tresult[ 1 ] = projection.convertProjectionToLatitude( result[ 1 ] );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'TilingScheme: Projection not available.' );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\ttoCartographicRange( range ) {\n\n\t\treturn [\n\t\t\t...this.toCartographicPoint( range[ 0 ], range[ 1 ] ),\n\t\t\t...this.toCartographicPoint( range[ 2 ], range[ 3 ] ),\n\t\t];\n\n\t}\n\n\tclampToContentBounds( range, normalized = false ) {\n\n\t\tconst result = [ ...range ];\n\t\tconst [ minX, minY, maxX, maxY ] = this.getContentBounds( normalized );\n\t\tresult[ 0 ] = MathUtils.clamp( result[ 0 ], minX, maxX );\n\t\tresult[ 1 ] = MathUtils.clamp( result[ 1 ], minY, maxY );\n\t\tresult[ 2 ] = MathUtils.clamp( result[ 2 ], minX, maxX );\n\t\tresult[ 3 ] = MathUtils.clamp( result[ 3 ], minY, maxY );\n\n\t\treturn result;\n\n\t}\n\n\tclampToProjectionBounds( range, normalized = false ) {\n\n\t\tconst result = [ ...range ];\n\t\tconst { projection } = this;\n\t\tlet clampBounds;\n\n\t\tif ( normalized || ! projection ) {\n\n\t\t\tclampBounds = [ 0, 0, 1, 1 ];\n\n\t\t} else {\n\n\t\t\tclampBounds = projection.getBounds();\n\n\t\t}\n\n\t\tconst [ minX, minY, maxX, maxY ] = clampBounds;\n\t\tresult[ 0 ] = MathUtils.clamp( result[ 0 ], minX, maxX );\n\t\tresult[ 1 ] = MathUtils.clamp( result[ 1 ], minY, maxY );\n\t\tresult[ 2 ] = MathUtils.clamp( result[ 2 ], minX, maxX );\n\t\tresult[ 3 ] = MathUtils.clamp( result[ 3 ], minY, maxY );\n\n\t\treturn result;\n\n\t}\n\n}\n\n","import { DataCache } from '../utils/DataCache.js';\nimport { TilingScheme } from '../utils/TilingScheme.js';\nimport { SRGBColorSpace, Texture, TextureUtils } from 'three';\n\n// TODO: support queries for detail at level - ie projected pixel size for geometric error mapping\n// Goes here or in \"TilingScheme\"?\nexport class TiledImageSource extends DataCache {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\tfetchOptions = {}\n\t\t} = options;\n\n\t\tthis.tiling = new TilingScheme();\n\t\tthis.fetchOptions = fetchOptions;\n\t\tthis.fetchData = ( ...args ) => fetch( ...args );\n\n\t}\n\n\t// async function for initializing the tiled image set\n\tinit() {}\n\n\t// helper for processing the buffer into a texture\n\tasync processBufferToTexture( buffer ) {\n\n\t\tconst blob = new Blob( [ buffer ] );\n\t\tconst imageBitmap = await createImageBitmap( blob, {\n\t\t\tpremultiplyAlpha: 'none',\n\t\t\tcolorSpaceConversion: 'none',\n\t\t\timageOrientation: 'flipY',\n\t\t} );\n\t\tconst texture = new Texture( imageBitmap );\n\t\ttexture.generateMipmaps = false;\n\t\ttexture.colorSpace = SRGBColorSpace;\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n\tgetMemoryUsage( tex ) {\n\n\t\tconst { format, type, image, generateMipmaps } = tex;\n\t\tconst { width, height } = image;\n\t\tconst bytes = TextureUtils.getByteLength( width, height, format, type );\n\t\treturn generateMipmaps ? bytes * 4 / 3 : bytes;\n\n\t}\n\n\t// fetch the item with the given key fields\n\tfetchItem( tokens, signal ) {\n\n\t\tconst fetchOptions = {\n\t\t\t...this.fetchOptions,\n\t\t\tsignal,\n\t\t};\n\t\tconst url = this.getUrl( ...tokens );\n\t\treturn this\n\t\t\t.fetchData( url, fetchOptions )\n\t\t\t.then( res => res.arrayBuffer() )\n\t\t\t.then( buffer => this.processBufferToTexture( buffer ) );\n\n\t}\n\n\t// dispose of the item that was fetched\n\tdisposeItem( texture ) {\n\n\t\ttexture.dispose();\n\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\ttexture.image.close();\n\n\t\t}\n\n\t}\n\n\tgetUrl( ...args ) {\n\n\t}\n\n}\n","import { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { TiledImageSource } from './TiledImageSource.js';\n\nexport class XYZImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tlevels = 20,\n\t\t\ttileDimension = 256,\n\t\t\turl = null,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.tileDimension = tileDimension;\n\t\tthis.levels = levels;\n\t\tthis.url = url;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.url\n\t\t\t.replace( /{\\s*z\\s*}/gi, level )\n\t\t\t.replace( /{\\s*x\\s*}/gi, x )\n\t\t\t.replace( /{\\s*(y|reverseY|-\\s*y)\\s*}/gi, y );\n\n\t}\n\n\tinit() {\n\n\t\t// transform the url\n\t\tconst { tiling, tileDimension, levels, url } = this;\n\n\t\ttiling.flipY = ! /{\\s*reverseY|-\\s*y\\s*}/g.test( url );\n\t\ttiling.setProjection( new ProjectionScheme( 'EPSG:3857' ) );\n\t\ttiling.setContentBounds( ...tiling.projection.getBounds() );\n\t\ttiling.generateLevels( levels, tiling.projection.tileCountX, tiling.projection.tileCountY, {\n\t\t\ttilePixelWidth: tileDimension,\n\t\t\ttilePixelHeight: tileDimension,\n\t\t} );\n\n\t\tthis.url = url;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n","import { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { TiledImageSource } from './TiledImageSource.js';\nimport { MathUtils } from 'three';\n\nexport class TMSImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\turl = null,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.tileSets = null;\n\t\tthis.extension = null;\n\t\tthis.url = url;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\tconst { url, extension, tileSets, tiling } = this;\n\t\treturn new URL( `${ parseInt( tileSets[ level - tiling.minLevel ].href ) }/${ x }/${ y }.${ extension }`, url ).toString();\n\n\t}\n\n\tinit() {\n\n\t\tconst { url } = this;\n\n\t\treturn this\n\t\t\t.fetchData( new URL( 'tilemapresource.xml', url ), this.fetchOptions )\n\t\t\t.then( res => res.text() )\n\t\t\t.then( text => {\n\n\t\t\t\tconst { tiling } = this;\n\n\t\t\t\t// elements\n\t\t\t\tconst xml = new DOMParser().parseFromString( text, 'text/xml' );\n\t\t\t\tconst boundingBox = xml.querySelector( 'BoundingBox' );\n\t\t\t\tconst tileFormat = xml.querySelector( 'TileFormat' );\n\t\t\t\tconst tileSets = xml.querySelector( 'TileSets' ).querySelectorAll( 'TileSet' );\n\n\t\t\t\t// tileset definitions\n\t\t\t\tconst tileSetList = [ ...tileSets ]\n\t\t\t\t\t.map( ts => ( {\n\t\t\t\t\t\thref: parseInt( ts.getAttribute( 'href' ) ),\n\t\t\t\t\t\tunitsPerPixel: parseFloat( ts.getAttribute( 'units-per-pixel' ) ),\n\t\t\t\t\t\torder: parseInt( ts.getAttribute( 'order' ) ),\n\t\t\t\t\t} ) )\n\t\t\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\t\t\treturn a.order - b.order;\n\n\t\t\t\t\t} );\n\n\t\t\t\t// bounding box\n\t\t\t\tconst minX = parseFloat( boundingBox.getAttribute( 'minx' ) ) * MathUtils.DEG2RAD;\n\t\t\t\tconst maxX = parseFloat( boundingBox.getAttribute( 'maxx' ) ) * MathUtils.DEG2RAD;\n\t\t\t\tconst minY = parseFloat( boundingBox.getAttribute( 'miny' ) ) * MathUtils.DEG2RAD;\n\t\t\t\tconst maxY = parseFloat( boundingBox.getAttribute( 'maxy' ) ) * MathUtils.DEG2RAD;\n\n\t\t\t\t// origin in lat / lon\n\t\t\t\t// Note: The \"origin\" value in TMS is documented but otherwise not used in any data set as\n\t\t\t\t// defined by the spec so ignore it here.\n\t\t\t\t// const origin = xml.querySelector( 'Origin' );\n\t\t\t\t// const originX = parseFloat( origin.getAttribute( 'x' ) ) * MathUtils.DEG2RAD;\n\t\t\t\t// const originY = parseFloat( origin.getAttribute( 'y' ) ) * MathUtils.DEG2RAD;\n\n\t\t\t\t// image dimensions in pixels\n\t\t\t\tconst tileWidth = parseInt( tileFormat.getAttribute( 'width' ) );\n\t\t\t\tconst tileHeight = parseInt( tileFormat.getAttribute( 'height' ) );\n\t\t\t\tconst extension = tileFormat.getAttribute( 'extension' );\n\t\t\t\tconst srs = xml.querySelector( 'SRS' ).textContent;\n\n\t\t\t\t// assign settings\n\t\t\t\tthis.extension = extension;\n\t\t\t\tthis.url = url;\n\t\t\t\tthis.tileSets = tileSetList;\n\n\t\t\t\t// initialize tiling and projection schemes\n\t\t\t\ttiling.setProjection( new ProjectionScheme( srs ) );\n\t\t\t\ttiling.setContentBounds( minX, minY, maxX, maxY );\n\n\t\t\t\ttileSetList.forEach( ( { order } ) => {\n\n\t\t\t\t\ttiling.setLevel( order, {\n\t\t\t\t\t\ttileCountX: tiling.projection.tileCountX * 2 ** order,\n\t\t\t\t\t\ttilePixelWidth: tileWidth,\n\t\t\t\t\t\ttilePixelHeight: tileHeight,\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t}\n\n}\n","import { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\n\nfunction isCRS84( crs ) {\n\n\treturn /(:84|:crs84)$/i.test( crs );\n\n}\n\nexport class WMTSImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tcapabilities = null,\n\t\t\tlayer = null,\n\t\t\ttileMatrixSet = null,\n\t\t\tstyle = null,\n\t\t\turl = null,\n\t\t\tdimensions = {},\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.capabilities = capabilities;\n\t\tthis.layer = layer;\n\t\tthis.tileMatrixSet = tileMatrixSet;\n\t\tthis.style = style;\n\t\tthis.dimensions = dimensions;\n\t\tthis.url = url;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.url\n\t\t\t.replace( /{\\s*TileMatrix\\s*}/gi, level )\n\t\t\t.replace( /{\\s*TileCol\\s*}/gi, x )\n\t\t\t.replace( /{\\s*TileRow\\s*}/gi, y );\n\n\t}\n\n\tinit() {\n\n\t\tconst { tiling, dimensions, capabilities } = this;\n\t\tlet { layer, tileMatrixSet, style, url } = this;\n\n\t\t// extract the layer to use\n\t\tif ( ! layer ) {\n\n\t\t\tlayer = capabilities.layers[ 0 ];\n\n\t\t} else if ( typeof layer === 'string' ) {\n\n\t\t\tlayer = capabilities.layers.find( l => l.identifier === layer );\n\n\t\t}\n\n\t\t// extract the tile matrix set\n\t\tif ( ! tileMatrixSet ) {\n\n\t\t\ttileMatrixSet = layer.tileMatrixSets[ 0 ];\n\n\t\t} else if ( typeof tileMatrixSet === 'string' ) {\n\n\t\t\ttileMatrixSet = layer.tileMatrixSets.find( tms => tms.identifier === tileMatrixSet );\n\n\t\t}\n\n\t\t// extract the style\n\t\tif ( ! style ) {\n\n\t\t\tstyle = layer.styles.find( style => style.isDefault ).identifier;\n\n\t\t}\n\n\t\t// extract the url template\n\t\tif ( ! url ) {\n\n\t\t\turl = layer.resourceUrls[ 0 ].template;\n\n\t\t}\n\n\t\t// determine the projection\n\t\tconst supportedCRS = tileMatrixSet.supportedCRS;\n\t\tconst projection = ( supportedCRS.includes( '4326' ) || isCRS84( supportedCRS ) ) ? 'EPSG:4326' : 'EPSG:3857';\n\n\t\t// generate the tiling scheme\n\t\ttiling.flipY = true;\n\t\ttiling.setProjection( new ProjectionScheme( projection ) );\n\n\t\tif ( layer.boundingBox !== null ) {\n\n\t\t\ttiling.setContentBounds( ...layer.boundingBox.bounds );\n\n\t\t} else {\n\n\t\t\ttiling.setContentBounds( ...tiling.projection.getBounds() );\n\n\t\t}\n\n\t\ttileMatrixSet.tileMatrices.forEach( ( tm, i ) => {\n\n\t\t\t// TODO: needs to set tileCountX from matrix width?\n\t\t\t// TODO: How does bounds and tile count work together here?\n\t\t\t// Can one typically be generated from the other?\n\n\t\t\tconst { tileWidth, tileHeight, matrixWidth, matrixHeight } = tm;\n\t\t\ttiling.setLevel( i, {\n\t\t\t\ttilePixelWidth: tileWidth,\n\t\t\t\ttilePixelHeight: tileHeight,\n\t\t\t\ttileCountX: matrixWidth || tiling.projection.tileCountX * 2 ** i,\n\t\t\t\ttileCountY: matrixHeight || tiling.projection.tileCountY * 2 ** i,\n\t\t\t\ttileBounds: tm.bounds,\n\t\t\t} );\n\n\t\t} );\n\n\t\t// construct the url\n\t\turl = url\n\t\t\t.replace( /{\\s*TileMatrixSet\\s*}/g, tileMatrixSet.identifier )\n\t\t\t.replace( /{\\s*Style\\s*}/g, style );\n\n\t\t// fill in the dimension values\n\t\tfor ( const key in dimensions ) {\n\n\t\t\turl = url.replace( new RegExp( `{\\\\s*${ key }\\\\s*}` ), dimensions[ key ] );\n\n\t\t}\n\n\t\tlayer.dimensions.forEach( dim => {\n\n\t\t\turl = url.replace( new RegExp( `{\\\\s*${ dim.identifier }\\\\s*}` ), dim.defaultValue );\n\n\t\t} );\n\n\t\tthis.url = url;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n","import { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { MathUtils } from 'three';\n\nexport class WMSImageSource extends TiledImageSource {\n\n\t// TODO: layer and styles can be arrays, comma separated lists\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\turl = null,\n\t\t\tlayer = null,\n\t\t\tstyles = null,\n\t\t\tcontentBoundingBox = null,\n\t\t\tversion = '1.3.0',\n\t\t\tcrs = 'EPSG:4326',\n\t\t\tformat = 'image/png',\n\t\t\ttransparent = false,\n\t\t\tlevels = 18,\n\t\t\ttileDimension = 256,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\t\tthis.url = url;\n\t\tthis.layer = layer;\n\t\tthis.crs = crs;\n\t\tthis.format = format;\n\t\tthis.tileDimension = tileDimension;\n\t\tthis.styles = styles;\n\t\tthis.version = version;\n\t\tthis.levels = levels;\n\t\tthis.transparent = transparent;\n\t\tthis.contentBoundingBox = contentBoundingBox;\n\n\t}\n\n\tinit() {\n\n\t\tconst { tiling, levels, tileDimension, contentBoundingBox } = this;\n\t\ttiling.setProjection( new ProjectionScheme( this.crs ) );\n\t\ttiling.flipY = true;\n\t\ttiling.generateLevels( levels, tiling.projection.tileCountX, tiling.projection.tileCountY, {\n\t\t\ttilePixelWidth: tileDimension,\n\t\t\ttilePixelHeight: tileDimension,\n\t\t} );\n\n\t\tif ( contentBoundingBox !== null ) {\n\n\t\t\ttiling.setContentBounds( ...contentBoundingBox );\n\n\t\t} else {\n\n\t\t\ttiling.setContentBounds( ...tiling.projection.getBounds() );\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n\t// TODO: handle this in ProjectionScheme or TilingScheme? Or Loader?\n\tnormalizedToMercatorX( v ) {\n\n\t\tconst MERCATOR_MIN = - 20037508.342789244;\n\t\tconst MERCATOR_MAX = 20037508.342789244;\n\t\treturn MathUtils.mapLinear( v, 0, 1, MERCATOR_MIN, MERCATOR_MAX );\n\n\t}\n\n\tnormalizedToMercatorY( v ) {\n\n\t\tconst MERCATOR_MIN = - 20037508.342789244;\n\t\tconst MERCATOR_MAX = 20037508.342789244;\n\t\treturn MathUtils.mapLinear( v, 0, 1, MERCATOR_MIN, MERCATOR_MAX );\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\tconst {\n\t\t\ttiling,\n\t\t\tlayer,\n\t\t\tcrs,\n\t\t\tformat,\n\t\t\ttileDimension,\n\t\t\tstyles,\n\t\t\tversion,\n\t\t\ttransparent,\n\t\t} = this;\n\n\t\t// Axis order and CRS param name depend on WMS version and CRS\n\t\t// crsParam: 'SRS' for WMS 1.1.1, 'CRS' for WMS 1.3.0\n\t\tconst crsParam = version === '1.1.1' ? 'SRS' : 'CRS';\n\t\tlet bboxParam;\n\n\t\tif ( crs === 'EPSG:3857' ) {\n\n\t\t\t// Always lon / lat order for both versions\n\t\t\tconst range = tiling.getTileBounds( x, y, level, true, false );\n\t\t\tconst minx = this.normalizedToMercatorX( range[ 0 ] );\n\t\t\tconst miny = this.normalizedToMercatorY( range[ 1 ] );\n\t\t\tconst maxx = this.normalizedToMercatorX( range[ 2 ] );\n\t\t\tconst maxy = this.normalizedToMercatorY( range[ 3 ] );\n\t\t\tbboxParam = [ minx, miny, maxx, maxy ];\n\n\t\t} else {\n\n\t\t\t// Get the tile bounds as degrees\n\t\t\tconst [ minx, miny, maxx, maxy ] = tiling\n\t\t\t\t.getTileBounds( x, y, level, false, false )\n\t\t\t\t.map( v => v * MathUtils.RAD2DEG );\n\n\t\t\tif ( crs === 'EPSG:4326' ) {\n\n\t\t\t\t// Note: In WMS 1.1.1 EPSG:4326 is wrongly defined as having long/lat coordinate axes. See v1.3.0 documentation for details.\n\t\t\t\t// Docs:  https://docs.foursquare.com/analytics-products/docs/data-formats-wms\n\t\t\t\t// Topic: https://gis.stackexchange.com/questions/23347/getmap-wms-1-1-1-vs-1-3-0\n\t\t\t\tif ( version === '1.1.1' ) {\n\n\t\t\t\t\t// WMS 1.1.1: lon / lat order\n\t\t\t\t\tbboxParam = [ minx, miny, maxx, maxy ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// WMS 1.3.0: lat / lon order\n\t\t\t\t\tbboxParam = [ miny, minx, maxy, maxx ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbboxParam = [ minx, miny, maxx, maxy ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst params = new URLSearchParams( {\n\t\t\tSERVICE: 'WMS',\n\t\t\tREQUEST: 'GetMap',\n\t\t\tVERSION: version,\n\t\t\tLAYERS: layer,\n\t\t\t[ crsParam ]: crs,\n\t\t\tBBOX: bboxParam.join( ',' ),\n\t\t\tWIDTH: tileDimension,\n\t\t\tHEIGHT: tileDimension,\n\t\t\tFORMAT: format,\n\t\t\tTRANSPARENT: transparent ? 'TRUE' : 'FALSE',\n\t\t} );\n\n\t\t// Only add STYLES if it's defined (not null or undefined)\n\t\t// This is a WMS-specific parameter, and giving it an unexpected value can lead to errors\n\t\tif ( styles !== null && styles !== undefined ) {\n\n\t\t\tparams.set( 'STYLES', styles );\n\n\t\t}\n\n\t\treturn new URL( '?' + params.toString(), this.url ).toString();\n\n\t}\n\n}\n","\n// Support for XYZ / Slippy tile systems\n\nimport { EllipsoidProjectionTilesPlugin } from './EllipsoidProjectionTilesPlugin.js';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\nimport { WMSImageSource } from './sources/WMSImageSource.js';\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames\nexport class XYZTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tlevels,\n\t\t\ttileDimension,\n\t\t\turl,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'XYZ_TILES_PLUGIN';\n\t\tthis.imageSource = new XYZImageSource( { url, levels, tileDimension } );\n\n\t}\n\n}\n\n// Support for TMS tiles\n// https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification\n// NOTE: Most, if not all, TMS generation implementations do not correctly support the Origin tag\n// and tile index offsets, including CesiumJS and Ion.\nexport class TMSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst { url, ...rest } = options;\n\t\tsuper( rest );\n\n\t\tthis.name = 'TMS_TILES_PLUGIN';\n\t\tthis.imageSource = new TMSImageSource( { url } );\n\n\t}\n\n}\n\n// Support for WMTS tiles via a url template\nexport class WMTSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tcapabilities,\n\t\t\tlayer,\n\t\t\ttileMatrixSet,\n\t\t\tstyle,\n\t\t\tdimensions,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'WTMS_TILES_PLUGIN';\n\t\tthis.imageSource = new WMTSImageSource( {\n\t\t\tcapabilities,\n\t\t\tlayer,\n\t\t\ttileMatrixSet,\n\t\t\tstyle,\n\t\t\tdimensions\n\t\t} );\n\n\t}\n\n}\n\nexport class WMSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\turl,\n\t\t\tlayer,\n\t\t\tcrs,\n\t\t\tformat,\n\t\t\ttileDimension,\n\t\t\tstyles,\n\t\t\tversion,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'WMS_TILES_PLUGIN';\n\t\tthis.imageSource = new WMSImageSource( {\n\t\t\turl,\n\t\t\tlayer,\n\t\t\tcrs,\n\t\t\tformat,\n\t\t\ttileDimension,\n\t\t\tstyles,\n\t\t\tversion\n\t\t} );\n\n\t}\n\n}\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tDataTexture,\n\tDefaultLoadingManager,\n\tLinearFilter,\n\tLinearMipMapLinearFilter,\n\tMathUtils,\n\tMesh,\n\tMeshStandardMaterial,\n\tRGFormat,\n\tTriangle,\n\tUnsignedByteType,\n\tVector3,\n} from 'three';\nimport { QuantizedMeshLoaderBase } from '3d-tiles-renderer/core/plugins';\nimport { Ellipsoid } from '3d-tiles-renderer/three';\n\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _tri = /* @__PURE__ */ new Triangle();\nconst _uvh = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nexport class QuantizedMeshLoader extends QuantizedMeshLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.ellipsoid = new Ellipsoid();\n\t\tthis.skirtLength = 1000;\n\t\tthis.smoothSkirtNormals = true;\n\t\tthis.generateNormals = true;\n\t\tthis.solid = false;\n\n\t\t// set the range of the tile\n\t\tthis.minLat = - Math.PI / 2;\n\t\tthis.maxLat = Math.PI / 2;\n\t\tthis.minLon = - Math.PI;\n\t\tthis.maxLon = Math.PI;\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst {\n\t\t\tellipsoid,\n\t\t\tsolid,\n\t\t\tskirtLength,\n\t\t\tsmoothSkirtNormals,\n\t\t\tgenerateNormals,\n\n\t\t\tminLat,\n\t\t\tmaxLat,\n\t\t\tminLon,\n\t\t\tmaxLon,\n\t\t} = this;\n\n\t\tconst {\n\t\t\theader,\n\t\t\tindices,\n\t\t\tvertexData,\n\t\t\tedgeIndices,\n\t\t\textensions,\n\t\t} = super.parse( buffer );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new MeshStandardMaterial();\n\t\tconst mesh = new Mesh( geometry, material );\n\t\tmesh.position.set( ...header.center );\n\n\t\tconst hasNormalExtension = 'octvertexnormals' in extensions;\n\t\tconst includeNormals = hasNormalExtension || generateNormals;\n\t\tconst vertexCount = vertexData.u.length;\n\t\tconst positions = [];\n\t\tconst uvs = [];\n\t\tconst indexArr = [];\n\t\tconst normals = [];\n\t\tlet groupOffset = 0;\n\t\tlet materialIndex = 0;\n\n\t\t// construct terrain\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\treadUVHeight( i, _uvh );\n\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos );\n\n\t\t\tuvs.push( _uvh.x, _uvh.y );\n\t\t\tpositions.push( ..._pos );\n\n\t\t}\n\n\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tindexArr.push( indices[ i ] );\n\n\t\t}\n\n\t\tif ( includeNormals ) {\n\n\t\t\tif ( hasNormalExtension ) {\n\n\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\tfor ( let i = 0, l = extNormals.length; i < l; i ++ ) {\n\n\t\t\t\t\tnormals.push( extNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// generate normals using the positions we just created\n\t\t\t\tconst tempGeometry = new BufferGeometry();\n\t\t\t\tconst tempIndexBuffer = indices.length > 21845 ? new Uint32Array( indices ) : new Uint16Array( indices );\n\t\t\t\ttempGeometry.setIndex( new BufferAttribute( tempIndexBuffer, 1, false ) );\n\t\t\t\ttempGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( positions ), 3, false ) );\n\t\t\t\ttempGeometry.computeVertexNormals();\n\n\t\t\t\tconst normalAttr = tempGeometry.getAttribute( 'normal' );\n\t\t\t\tconst generatedNormals = normalAttr.array;\n\n\t\t\t\t// store in extensions format for consistency\n\t\t\t\textensions[ 'octvertexnormals' ] = { normals: generatedNormals };\n\n\t\t\t\t// copy to normals array\n\t\t\t\tfor ( let i = 0, l = generatedNormals.length; i < l; i ++ ) {\n\n\t\t\t\t\tnormals.push( generatedNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add material group\n\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\tgroupOffset += indices.length;\n\t\tmaterialIndex ++;\n\n\t\t// create a lower cap\n\t\tif ( solid ) {\n\n\t\t\tconst indexOffset = positions.length / 3;\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\treadUVHeight( i, _uvh );\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos, - skirtLength );\n\n\t\t\t\tuvs.push( _uvh.x, _uvh.y );\n\t\t\t\tpositions.push( ..._pos );\n\n\t\t\t}\n\n\t\t\tfor ( let i = indices.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tindexArr.push( indices[ i ] + indexOffset );\n\n\t\t\t}\n\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\tfor ( let i = 0, l = extNormals.length; i < l; i ++ ) {\n\n\t\t\t\t\tnormals.push( - extNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// add material group\n\t\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\t\tgroupOffset += indices.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\t// construct skirts\n\t\tif ( skirtLength > 0 ) {\n\n\t\t\tconst {\n\t\t\t\twestIndices,\n\t\t\t\teastIndices,\n\t\t\t\tsouthIndices,\n\t\t\t\tnorthIndices,\n\t\t\t} = edgeIndices;\n\n\t\t\t// construct the indices\n\t\t\tlet offset;\n\n\t\t\t// west\n\t\t\tconst westStrip = constructEdgeStrip( westIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...westStrip.uv );\n\t\t\tpositions.push( ...westStrip.positions );\n\t\t\tfor ( let i = 0, l = westStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( westStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// east\n\t\t\tconst eastStrip = constructEdgeStrip( eastIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...eastStrip.uv );\n\t\t\tpositions.push( ...eastStrip.positions );\n\t\t\tfor ( let i = 0, l = eastStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( eastStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// south\n\t\t\tconst southStrip = constructEdgeStrip( southIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...southStrip.uv );\n\t\t\tpositions.push( ...southStrip.positions );\n\t\t\tfor ( let i = 0, l = southStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( southStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// north\n\t\t\tconst northStrip = constructEdgeStrip( northIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...northStrip.uv );\n\t\t\tpositions.push( ...northStrip.positions );\n\t\t\tfor ( let i = 0, l = northStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( northStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// add the normals\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tnormals.push( ...westStrip.normals );\n\t\t\t\tnormals.push( ...eastStrip.normals );\n\t\t\t\tnormals.push( ...southStrip.normals );\n\t\t\t\tnormals.push( ...northStrip.normals );\n\n\t\t\t}\n\n\t\t\t// add material group\n\t\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\t\tgroupOffset += indices.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\t// shift the positions by the center of the tile\n\t\tfor ( let i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\tpositions[ i + 0 ] -= header.center[ 0 ];\n\t\t\tpositions[ i + 1 ] -= header.center[ 1 ];\n\t\t\tpositions[ i + 2 ] -= header.center[ 2 ];\n\n\t\t}\n\n\t\t// generate geometry and mesh\n\t\tconst indexBuffer = positions.length / 3 > 65535 ? new Uint32Array( indexArr ) : new Uint16Array( indexArr );\n\t\tgeometry.setIndex( new BufferAttribute( indexBuffer, 1, false ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( positions ), 3, false ) );\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( uvs ), 2, false ) );\n\t\tif ( includeNormals ) {\n\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3, false ) );\n\n\t\t}\n\n\t\t// generate the water texture\n\t\tif ( 'watermask' in extensions ) {\n\n\t\t\t// invert the mask data\n\t\t\t// TODO: this inversion step can be a bit slow\n\t\t\tconst { mask, size } = extensions[ 'watermask' ];\n\t\t\tconst maskBuffer = new Uint8Array( 2 * size * size );\n\t\t\tfor ( let i = 0, l = mask.length; i < l; i ++ ) {\n\n\t\t\t\tconst v = mask[ i ] === 255 ? 0 : 255;\n\t\t\t\tmaskBuffer[ 2 * i + 0 ] = v;\n\t\t\t\tmaskBuffer[ 2 * i + 1 ] = v;\n\n\t\t\t}\n\n\t\t\t// TODO: Luminance format is not supported - eventually node materials will\n\t\t\t// make it possible to map the texture to the appropriate buffer input.\n\t\t\tconst map = new DataTexture( maskBuffer, size, size, RGFormat, UnsignedByteType );\n\t\t\tmap.flipY = true;\n\t\t\tmap.minFilter = LinearMipMapLinearFilter;\n\t\t\tmap.magFilter = LinearFilter;\n\t\t\tmap.needsUpdate = true;\n\n\t\t\tmaterial.roughnessMap = map;\n\n\t\t}\n\n\t\t// set metadata\n\t\tmesh.userData.minHeight = header.minHeight;\n\t\tmesh.userData.maxHeight = header.maxHeight;\n\n\t\tif ( 'metadata' in extensions ) {\n\n\t\t\tmesh.userData.metadata = extensions[ 'metadata' ].json;\n\n\t\t}\n\n\t\treturn mesh;\n\n\t\tfunction readUVHeight( index, target ) {\n\n\t\t\ttarget.x = vertexData.u[ index ];\n\t\t\ttarget.y = vertexData.v[ index ];\n\t\t\ttarget.z = vertexData.height[ index ];\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction readPosition( u, v, h, target, heightOffset = 0 ) {\n\n\t\t\tconst height = MathUtils.lerp( header.minHeight, header.maxHeight, h );\n\t\t\tconst lon = MathUtils.lerp( minLon, maxLon, u );\n\t\t\tconst lat = MathUtils.lerp( minLat, maxLat, v );\n\n\t\t\tellipsoid.getCartographicToPosition( lat, lon, height + heightOffset, target );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction constructEdgeStrip( indices ) {\n\n\t\t\tconst topUvs = [];\n\t\t\tconst topPos = [];\n\t\t\tconst botUvs = [];\n\t\t\tconst botPos = [];\n\t\t\tconst sideIndices = [];\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\treadUVHeight( indices[ i ], _uvh );\n\t\t\t\ttopUvs.push( _uvh.x, _uvh.y );\n\t\t\t\tbotUvs.push( _uvh.x, _uvh.y );\n\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos );\n\t\t\t\ttopPos.push( ..._pos );\n\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos, - skirtLength );\n\t\t\t\tbotPos.push( ..._pos );\n\n\t\t\t}\n\n\t\t\tconst triCount = ( indices.length - 1 );\n\t\t\tfor ( let i = 0; i < triCount; i ++ ) {\n\n\t\t\t\tconst t0 = i;\n\t\t\t\tconst t1 = i + 1;\n\t\t\t\tconst b0 = i + indices.length;\n\t\t\t\tconst b1 = i + indices.length + 1;\n\n\t\t\t\tsideIndices.push( t0, b0, t1 );\n\t\t\t\tsideIndices.push( t1, b0, b1 );\n\n\t\t\t}\n\n\t\t\tlet normals = null;\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tconst total = ( topPos.length + botPos.length ) / 3;\n\n\t\t\t\tif ( smoothSkirtNormals ) {\n\n\t\t\t\t\tnormals = new Array( total * 3 );\n\n\t\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\t\tconst botOffset = normals.length / 2;\n\t\t\t\t\tfor ( let i = 0, l = total / 2; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst index = indices[ i ];\n\t\t\t\t\t\tconst i3 = 3 * i;\n\t\t\t\t\t\tconst nx = extNormals[ 3 * index + 0 ];\n\t\t\t\t\t\tconst ny = extNormals[ 3 * index + 1 ];\n\t\t\t\t\t\tconst nz = extNormals[ 3 * index + 2 ];\n\n\t\t\t\t\t\tnormals[ i3 + 0 ] = nx;\n\t\t\t\t\t\tnormals[ i3 + 1 ] = ny;\n\t\t\t\t\t\tnormals[ i3 + 2 ] = nz;\n\n\t\t\t\t\t\tnormals[ botOffset + i3 + 0 ] = nx;\n\t\t\t\t\t\tnormals[ botOffset + i3 + 1 ] = ny;\n\t\t\t\t\t\tnormals[ botOffset + i3 + 2 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormals = [];\n\t\t\t\t\t_tri.a.fromArray( topPos, 0 );\n\t\t\t\t\t_tri.b.fromArray( botPos, 0 );\n\t\t\t\t\t_tri.c.fromArray( topPos, 3 );\n\t\t\t\t\t_tri.getNormal( _norm );\n\n\t\t\t\t\tfor ( let i = 0; i < total; i ++ ) {\n\n\t\t\t\t\t\tnormals.push( ..._norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tuv: [ ...topUvs, ...botUvs ],\n\t\t\t\tpositions: [ ...topPos, ...botPos ],\n\t\t\t\tindices: sideIndices,\n\t\t\t\tnormals,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n","import { MathUtils, Triangle, BufferGeometry, BufferAttribute, Mesh, Vector4 } from 'three';\n\nconst SPLIT_VALUE = 0;\nconst vertNames = [ 'a', 'b', 'c' ];\nconst _vec = /* @__PURE__ */ new Vector4();\nconst _v0 = /* @__PURE__ */ new Vector4();\nconst _v1 = /* @__PURE__ */ new Vector4();\nconst _v2 = /* @__PURE__ */ new Vector4();\n\n// Class for clipping geometry using the results from a \"split operation\"\nexport class GeometryClipper {\n\n\tconstructor() {\n\n\t\t// the list of attributes to use in the geometry being clipped, such as\n\t\t// [ 'position', 'normal', 'uv' ]\n\t\tthis.attributeList = null;\n\n\t\t// internal\n\t\tthis.splitOperations = [];\n\t\tthis.trianglePool = new ClipTrianglePool();\n\n\t}\n\n\tforEachSplitPermutation( callback ) {\n\n\t\tconst { splitOperations } = this;\n\t\tconst runPermutations = ( index = 0 ) => {\n\n\t\t\tif ( index >= splitOperations.length ) {\n\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tsplitOperations[ index ].keepPositive = true;\n\t\t\trunPermutations( index + 1 );\n\n\t\t\tsplitOperations[ index ].keepPositive = false;\n\t\t\trunPermutations( index + 1 );\n\n\t\t};\n\n\t\trunPermutations();\n\n\t}\n\n\t// Takes an operation that returns a value for the given vertex passed to the callback. Triangles\n\t// are clipped along edges where the interpolated value is equal to 0. The polygons on the positive\n\t// side of the operation are kept if \"keepPositive\" is true.\n\t// callback( geometry, i0, i1, i2, barycoord );\n\taddSplitOperation( callback, keepPositive = true ) {\n\n\t\tthis.splitOperations.push( {\n\t\t\tcallback,\n\t\t\tkeepPositive,\n\t\t} );\n\n\t}\n\n\t// Removes all split operations\n\tclearSplitOperations() {\n\n\t\tthis.splitOperations.length = 0;\n\n\t}\n\n\t// clips an object hierarchy\n\tclipObject( object ) {\n\n\t\tconst result = object.clone();\n\t\tconst toRemove = [];\n\t\tresult.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tc.geometry = this.clip( c ).geometry;\n\n\t\t\t\tconst triCount = c.geometry.index ? c.geometry.index.count / 3 : c.attributes.position.count / 3;\n\t\t\t\tif ( triCount === 0 ) {\n\n\t\t\t\t\ttoRemove.push( c );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttoRemove.forEach( m => {\n\n\t\t\tm.removeFromParent();\n\n\t\t} );\n\n\t\treturn result;\n\n\t}\n\n\t// Returns a new mesh that has been clipped by the split operations. Range indicates the range of\n\t// elements to include when clipping.\n\tclip( mesh, range = null ) {\n\n\t\t// TODO: support multimaterial\n\t\tconst result = this.getClippedData( mesh, range );\n\t\treturn this.constructMesh( result.attributes, result.index, mesh );\n\n\t}\n\n\t// Appends the clip operation data to the given \"target\" object so multiple ranges can be appended.\n\t// The \"target\" object is returned with an \"index\" field, \"vertexIsClipped\" field, and series of arrays\n\t// in \"attributes\".\n\t// attributes - set of attribute arrays\n\t// index - triangle indices referencing vertices in attributes\n\t// vertexIsClipped - array indicating whether a vertex is on a clipped edge\n\tgetClippedData( mesh, range = null, target = {} ) {\n\n\t\tconst { trianglePool, splitOperations, attributeList } = this;\n\n\t\t// source geometry\n\t\tconst sourceGeometry = mesh.geometry;\n\t\tconst position = sourceGeometry.attributes.position;\n\t\tconst index = sourceGeometry.index;\n\n\t\t// vertex hash data\n\t\tlet nextIndex = 0;\n\t\tconst vertToNewIndexMap = {};\n\n\t\t// initialize the result\n\t\ttarget.index = target.index || [];\n\t\ttarget.vertexIsClipped = target.vertexIsClipped || [];\n\t\ttarget.attributes = target.attributes || {};\n\n\t\t// initialize the attributes to the set in the attribute list or all if set to null\n\t\tfor ( const key in sourceGeometry.attributes ) {\n\n\t\t\tif ( attributeList !== null ) {\n\n\t\t\t\tif ( attributeList instanceof Function && ! attributeList( key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else if ( Array.isArray( attributeList ) && ! attributeList.includes( key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.attributes[ key ] = [];\n\n\t\t}\n\n\t\t// iterate over each group separately to retain the group information\n\t\tlet start = 0;\n\t\tlet count = index ? index.count : position.count;\n\t\tif ( range !== null ) {\n\n\t\t\tstart = range.start;\n\t\t\tcount = range.count;\n\n\t\t}\n\n\t\t// run the clip operations\n\t\tfor ( let i = start, l = start + count; i < l; i += 3 ) {\n\n\t\t\t// get the indices\n\t\t\tlet i0 = i + 0;\n\t\t\tlet i1 = i + 1;\n\t\t\tlet i2 = i + 2;\n\t\t\tif ( index ) {\n\n\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t}\n\n\t\t\t// get the original triangle\n\t\t\tconst tri = trianglePool.get();\n\t\t\ttri.initFromIndices( i0, i1, i2 );\n\n\t\t\t// iterate over each triangle and clip it\n\t\t\tlet triangles = [ tri ];\n\t\t\tfor ( let s = 0; s < splitOperations.length; s ++ ) {\n\n\t\t\t\tconst { keepPositive, callback } = splitOperations[ s ];\n\t\t\t\tconst result = [];\n\t\t\t\tfor ( let t = 0; t < triangles.length; t ++ ) {\n\n\t\t\t\t\tconst tri = triangles[ t ];\n\t\t\t\t\tconst { indices, barycoord } = tri;\n\t\t\t\t\ttri.clipValues.a = callback( sourceGeometry, indices.a, indices.b, indices.c, barycoord.a, mesh.matrixWorld );\n\t\t\t\t\ttri.clipValues.b = callback( sourceGeometry, indices.a, indices.b, indices.c, barycoord.b, mesh.matrixWorld );\n\t\t\t\t\ttri.clipValues.c = callback( sourceGeometry, indices.a, indices.b, indices.c, barycoord.c, mesh.matrixWorld );\n\n\t\t\t\t\tthis.splitTriangle( tri, ! keepPositive, result );\n\n\t\t\t\t}\n\n\t\t\t\ttriangles = result;\n\n\t\t\t}\n\n\t\t\t// append the triangles to the result\n\t\t\tfor ( let t = 0, l = triangles.length; t < l; t ++ ) {\n\n\t\t\t\tconst tri = triangles[ t ];\n\t\t\t\tpushTriangle( tri, sourceGeometry );\n\n\t\t\t}\n\n\t\t\ttrianglePool.reset();\n\n\t\t}\n\n\t\treturn target;\n\n\t\tfunction pushTriangle( tri, geometry ) {\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst hash = tri.getVertexHash( i, geometry );\n\n\t\t\t\tif ( ! ( hash in vertToNewIndexMap ) ) {\n\n\t\t\t\t\tvertToNewIndexMap[ hash ] = nextIndex;\n\t\t\t\t\tnextIndex ++;\n\n\t\t\t\t\ttri.getVertexData( i, geometry, target.attributes );\n\t\t\t\t\ttarget.vertexIsClipped.push( tri.clipValues[ vertNames[ i ] ] === SPLIT_VALUE );\n\n\t\t\t\t}\n\n\t\t\t\tconst index = vertToNewIndexMap[ hash ];\n\t\t\t\ttarget.index.push( index );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Takes the set of resultant data and constructs a mesh\n\tconstructMesh( attributes, index, sourceMesh ) {\n\n\t\tconst sourceGeometry = sourceMesh.geometry;\n\n\t\t// new geometry\n\t\tconst geometry = new BufferGeometry();\n\t\tconst indexBuffer = attributes.position.length / 3 > 65535 ? new Uint32Array( index ) : new Uint16Array( index );\n\t\tgeometry.setIndex( new BufferAttribute( indexBuffer, 1, false ) );\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = sourceGeometry.getAttribute( key );\n\t\t\tconst cons = new attr.array.constructor( attributes[ key ] );\n\t\t\tconst newAttr = new BufferAttribute( cons, attr.itemSize, attr.normalized );\n\t\t\tnewAttr.gpuType = attr.gpuType;\n\n\t\t\tgeometry.setAttribute( key, newAttr );\n\n\t\t}\n\n\t\t// new mesh\n\t\tconst result = new Mesh( geometry, sourceMesh.material.clone() );\n\t\tresult.position.copy( sourceMesh.position );\n\t\tresult.quaternion.copy( sourceMesh.quaternion );\n\t\tresult.scale.copy( sourceMesh.scale );\n\n\t\treturn result;\n\n\n\t}\n\n\t// Splits the given triangle\n\tsplitTriangle( tri, keepNegative, target ) {\n\n\t\tconst { trianglePool } = this;\n\n\t\t// TODO: clean up, add scratch variables, optimize\n\t\tconst edgeIndices = [];\n\t\tconst edges = [];\n\t\tconst lerpValues = [];\n\n\t\t// Find all points to clip\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst v = vertNames[ i ];\n\t\t\tconst nv = vertNames[ ( i + 1 ) % 3 ];\n\n\t\t\tconst pValue = tri.clipValues[ v ];\n\t\t\tconst npValue = tri.clipValues[ nv ];\n\n\t\t\t// if the uv values span across the halfway divide\n\t\t\tif ( ( pValue < SPLIT_VALUE ) !== ( npValue < SPLIT_VALUE ) || pValue === SPLIT_VALUE ) {\n\n\t\t\t\tedgeIndices.push( i );\n\t\t\t\tedges.push( [ v, nv ] );\n\n\t\t\t\tif ( pValue === npValue ) {\n\n\t\t\t\t\t// avoid NaN here which can occur with mapLinear when pValue and npValue are the same value\n\t\t\t\t\tlerpValues.push( 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlerpValues.push( MathUtils.mapLinear( SPLIT_VALUE, pValue, npValue, 0, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( edgeIndices.length !== 2 ) {\n\n\t\t\t// if we don't have two intersection points then this triangle must fall on\n\t\t\t// one side of the bounds.\n\t\t\tconst minBound = Math.min(\n\t\t\t\ttri.clipValues.a,\n\t\t\t\ttri.clipValues.b,\n\t\t\t\ttri.clipValues.c,\n\t\t\t);\n\n\t\t\tif ( ( minBound < SPLIT_VALUE ) === keepNegative ) {\n\n\t\t\t\ttarget.push( tri );\n\n\t\t\t}\n\n\t\t} else if ( edgeIndices.length === 2 ) {\n\n\t\t\t// TODO: how can we determine which triangles actually need to be added here ahead of time\n\t\t\tconst tri0 = trianglePool.get().initFromTriangle( tri );\n\t\t\tconst tri1 = trianglePool.get().initFromTriangle( tri );\n\t\t\tconst tri2 = trianglePool.get().initFromTriangle( tri );\n\n\t\t\t// If the points lie on edges that are immediately after one another then we have to split the\n\t\t\t// triangle differently.\n\t\t\tconst sequential = ( ( edgeIndices[ 0 ] + 1 ) % 3 ) === edgeIndices[ 1 ];\n\t\t\tif ( sequential ) {\n\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri0.copyVertex( tri, edges[ 0 ][ 1 ], 'b' );\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'c' );\n\t\t\t\ttri0.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri0.clipValues.c = SPLIT_VALUE;\n\n\t\t\t\ttri1.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri1.copyVertex( tri, edges[ 1 ][ 1 ], 'b' );\n\t\t\t\ttri1.copyVertex( tri, edges[ 0 ][ 0 ], 'c' );\n\t\t\t\ttri1.clipValues.a = SPLIT_VALUE;\n\n\t\t\t\ttri2.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri2.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'b' );\n\t\t\t\ttri2.copyVertex( tri, edges[ 1 ][ 1 ], 'c' );\n\t\t\t\ttri2.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri2.clipValues.b = SPLIT_VALUE;\n\n\t\t\t} else {\n\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'b' );\n\t\t\t\ttri0.copyVertex( tri, edges[ 0 ][ 0 ], 'c' );\n\t\t\t\ttri0.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri0.clipValues.b = SPLIT_VALUE;\n\n\t\t\t\ttri1.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri1.copyVertex( tri, edges[ 0 ][ 1 ], 'b' );\n\t\t\t\ttri1.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'c' );\n\t\t\t\ttri1.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri1.clipValues.c = SPLIT_VALUE;\n\n\t\t\t\ttri2.copyVertex( tri, edges[ 0 ][ 1 ], 'a' );\n\t\t\t\ttri2.copyVertex( tri, edges[ 1 ][ 0 ], 'b' );\n\t\t\t\ttri2.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'c' );\n\t\t\t\ttri2.clipValues.c = SPLIT_VALUE;\n\n\t\t\t}\n\n\t\t\t// Save the triangles that sit on the right side of the split\n\t\t\tlet minBound, negativeSide;\n\t\t\tminBound = Math.min( tri0.clipValues.a, tri0.clipValues.b, tri0.clipValues.c );\n\t\t\tnegativeSide = minBound < SPLIT_VALUE;\n\t\t\tif ( negativeSide === keepNegative ) {\n\n\t\t\t\ttarget.push( tri0 );\n\n\t\t\t}\n\n\t\t\tminBound = Math.min( tri1.clipValues.a, tri1.clipValues.b, tri1.clipValues.c );\n\t\t\tnegativeSide = minBound < SPLIT_VALUE;\n\t\t\tif ( negativeSide === keepNegative ) {\n\n\t\t\t\ttarget.push( tri1 );\n\n\t\t\t}\n\n\t\t\tminBound = Math.min( tri2.clipValues.a, tri2.clipValues.b, tri2.clipValues.c );\n\t\t\tnegativeSide = minBound < SPLIT_VALUE;\n\t\t\tif ( negativeSide === keepNegative ) {\n\n\t\t\t\ttarget.push( tri2 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Pool of reusable triangles\nclass ClipTrianglePool {\n\n\tconstructor() {\n\n\t\tthis.pool = [];\n\t\tthis.index = 0;\n\n\t}\n\n\tget() {\n\n\t\tif ( this.index >= this.pool.length ) {\n\n\t\t\tconst tri = new ClipTriangle();\n\t\t\tthis.pool.push( tri );\n\n\t\t}\n\n\t\tconst res = this.pool[ this.index ];\n\t\tthis.index ++;\n\t\treturn res;\n\n\t}\n\n\treset() {\n\n\t\tthis.index = 0;\n\n\t}\n\n}\n\n// Triangle class that stores the values to clip along, barycoord values for clipping, and the\n// original indices that the barycoord are interpolated between.\nclass ClipTriangle {\n\n\tconstructor() {\n\n\t\tthis.indices = {\n\t\t\ta: - 1,\n\t\t\tb: - 1,\n\t\t\tc: - 1,\n\t\t};\n\n\t\tthis.clipValues = {\n\t\t\ta: - 1,\n\t\t\tb: - 1,\n\t\t\tc: - 1,\n\t\t};\n\n\t\tthis.barycoord = new Triangle();\n\n\t}\n\n\t// returns a hash for the given [0, 2] index based on attributes of the referenced geometry\n\tgetVertexHash( index, geometry ) {\n\n\t\tconst { barycoord, indices } = this;\n\t\tconst vn = vertNames[ index ];\n\t\tconst bc = barycoord[ vn ];\n\n\t\t// If the barycoord value is specifying a single vertex then return a quick hash\n\t\tif ( bc.x === 1 ) {\n\n\t\t\treturn indices[ vertNames[ 0 ] ];\n\n\t\t} else if ( bc.y === 1 ) {\n\n\t\t\treturn indices[ vertNames[ 1 ] ];\n\n\t\t} else if ( bc.z === 1 ) {\n\n\t\t\treturn indices[ vertNames[ 2 ] ];\n\n\t\t} else {\n\n\t\t\t// Construct a hash based on all the interpolated attributes\n\t\t\tconst { attributes } = geometry;\n\t\t\tlet result = '';\n\t\t\tfor ( const name in attributes ) {\n\n\t\t\t\tconst attr = attributes[ name ];\n\t\t\t\treadInterpolatedAttribute( attr, indices.a, indices.b, indices.c, bc, _vec );\n\n\t\t\t\t// normalize values if needed\n\t\t\t\tif ( name === 'normal' || name === 'tangent' || name === 'bitangent' ) {\n\n\t\t\t\t\t_vec.normalize();\n\n\t\t\t\t}\n\n\t\t\t\t// construct the hash\n\t\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tresult += hashVertex( _vec.x, _vec.y, _vec.z, _vec.w );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tresult += hashVertex( _vec.x, _vec.y, _vec.z );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tresult += hashVertex( _vec.x, _vec.y );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tresult += hashVertex( _vec.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tresult += '|';\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// Accumulate the vertex data in the given attribute arrays\n\tgetVertexData( index, geometry, target ) {\n\n\t\tconst { barycoord, indices } = this;\n\t\tconst vn = vertNames[ index ];\n\t\tconst bc = barycoord[ vn ];\n\n\t\tconst { attributes } = geometry;\n\t\tfor ( const name in attributes ) {\n\n\t\t\t// skip saving the data if we have no fields for it\n\t\t\tif ( ! target[ name ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst attr = attributes[ name ];\n\t\t\tconst arr = target[ name ];\n\n\t\t\treadInterpolatedAttribute( attr, indices.a, indices.b, indices.c, bc, _vec );\n\n\t\t\t// normalize values if needed\n\t\t\tif ( name === 'normal' || name === 'tangent' || name === 'bitangent' ) {\n\n\t\t\t\t_vec.normalize();\n\n\t\t\t}\n\n\t\t\t// append the data\n\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\tcase 4:\n\t\t\t\t\tarr.push( _vec.x, _vec.y, _vec.z, _vec.w );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tarr.push( _vec.x, _vec.y, _vec.z );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tarr.push( _vec.x, _vec.y );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tarr.push( _vec.x );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Copy the indices from a target triangle\n\tinitFromTriangle( other ) {\n\n\t\treturn this.initFromIndices(\n\t\t\tother.indices.a,\n\t\t\tother.indices.b,\n\t\t\tother.indices.c,\n\t\t);\n\n\t}\n\n\t// Set the indices for the given\n\tinitFromIndices( i0, i1, i2 ) {\n\n\t\tthis.indices.a = i0;\n\t\tthis.indices.b = i1;\n\t\tthis.indices.c = i2;\n\n\t\tthis.clipValues.a = - 1;\n\t\tthis.clipValues.b = - 1;\n\t\tthis.clipValues.c = - 1;\n\n\t\tthis.barycoord.a.set( 1, 0, 0 );\n\t\tthis.barycoord.b.set( 0, 1, 0 );\n\t\tthis.barycoord.c.set( 0, 0, 1 );\n\n\t\treturn this;\n\n\t}\n\n\t// Lerp the given vertex along to the provided edge of the provided triangle\n\tlerpVertexFromEdge( other, e0, e1, alpha, targetVertex ) {\n\n\t\tthis.clipValues[ targetVertex ] = MathUtils.lerp( other.clipValues[ e0 ], other.clipValues[ e1 ], alpha );\n\t\tthis.barycoord[ targetVertex ].lerpVectors( other.barycoord[ e0 ], other.barycoord[ e1 ], alpha );\n\n\t}\n\n\t// Copy a vertex from the provided triangle\n\tcopyVertex( other, fromVertex, targetVertex ) {\n\n\t\tthis.clipValues[ targetVertex ] = other.clipValues[ fromVertex ];\n\t\tthis.barycoord[ targetVertex ].copy( other.barycoord[ fromVertex ] );\n\n\t}\n\n}\n\n// Read a vertex from the given attribute interpolated between the indices\nfunction readInterpolatedAttribute( attribute, i0, i1, i2, barycoord, target ) {\n\n\t_v0.fromBufferAttribute( attribute, i0 );\n\t_v1.fromBufferAttribute( attribute, i1 );\n\t_v2.fromBufferAttribute( attribute, i2 );\n\n\ttarget\n\t\t.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( _v0, barycoord.x )\n\t\t.addScaledVector( _v1, barycoord.y )\n\t\t.addScaledVector( _v2, barycoord.z );\n\n\tswitch ( attribute.itemSize ) {\n\n\t\tcase 3:\n\t\t\t_vec.w = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_vec.w = 0;\n\t\t\t_vec.z = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t_vec.w = 0;\n\t\t\t_vec.z = 0;\n\t\t\t_vec.y = 0;\n\t\t\tbreak;\n\n\t}\n\n\treturn target;\n\n}\n\n// Hash the provided numbers\nexport function hashVertex( ...args ) {\n\n\tconst scalar = 1e5;\n\tconst additive = 0.5;\n\tlet result = '';\n\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\n\n\t\tresult += ~ ~ ( args[ i ] * scalar + additive );\n\t\tif ( i !== l - 1 ) {\n\n\t\t\tresult += '_';\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n","import { MathUtils, Vector2, Vector3 } from 'three';\nimport { Ellipsoid } from '3d-tiles-renderer/three';\nimport { GeometryClipper, hashVertex } from './GeometryClipper.js';\n\nconst _cart = {};\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _pos0 = /* @__PURE__ */ new Vector3();\nconst _pos1 = /* @__PURE__ */ new Vector3();\nconst _pos2 = /* @__PURE__ */ new Vector3();\nconst _pos3 = /* @__PURE__ */ new Vector3();\nconst _temp = /* @__PURE__ */ new Vector3();\nconst _temp2 = /* @__PURE__ */ new Vector3();\n\nconst _uv0 = /* @__PURE__ */ new Vector2();\nconst _uv1 = /* @__PURE__ */ new Vector2();\nconst _uv2 = /* @__PURE__ */ new Vector2();\n\nexport class QuantizedMeshClipper extends GeometryClipper {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.ellipsoid = new Ellipsoid();\n\t\tthis.skirtLength = 1000;\n\t\tthis.smoothSkirtNormals = true;\n\t\tthis.solid = false;\n\n\t\tthis.minLat = - Math.PI / 2;\n\t\tthis.maxLat = Math.PI / 2;\n\t\tthis.minLon = - Math.PI;\n\t\tthis.maxLon = Math.PI;\n\n\t\tthis.attributeList = [ 'position', 'normal', 'uv' ];\n\n\t}\n\n\tclipToQuadrant( sourceMesh, left, bottom ) {\n\n\t\tconst { solid, skirtLength, ellipsoid, smoothSkirtNormals } = this;\n\n\t\tthis.clearSplitOperations();\n\t\tthis.addSplitOperation( getUvSplitOperation( 'x' ), ! left );\n\t\tthis.addSplitOperation( getUvSplitOperation( 'y' ), ! bottom );\n\n\t\tlet botResult, skirtResult;\n\t\tconst capGroup = sourceMesh.geometry.groups[ 0 ];\n\t\tconst capResult = this.getClippedData( sourceMesh, capGroup );\n\t\tthis.adjustVertices( capResult, sourceMesh.position, 0 );\n\n\t\tif ( solid ) {\n\n\t\t\tbotResult = {\n\t\t\t\tindex: capResult.index.slice().reverse(),\n\t\t\t\tattributes: {},\n\t\t\t};\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tbotResult.attributes[ key ] = capResult.attributes[ key ].slice();\n\n\t\t\t}\n\n\t\t\tconst normal = botResult.attributes.normal;\n\t\t\tif ( normal ) {\n\n\t\t\t\tfor ( let i = 0; i < normal.length; i += 3 ) {\n\n\t\t\t\t\tnormal[ i + 0 ] *= - 1;\n\t\t\t\t\tnormal[ i + 1 ] *= - 1;\n\t\t\t\t\tnormal[ i + 2 ] *= - 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.adjustVertices( botResult, sourceMesh.position, - skirtLength );\n\n\t\t}\n\n\t\tif ( skirtLength > 0 ) {\n\n\t\t\tskirtResult = {\n\t\t\t\tindex: [],\n\t\t\t\tattributes: {\n\t\t\t\t\tposition: [],\n\t\t\t\t\tnormal: [],\n\t\t\t\t\tuv: [],\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// push data onto the\n\t\t\tlet nextIndex = 0;\n\t\t\tconst vertToNewIndexMap = {};\n\t\t\tconst pushVertex = ( pos, uv, norm ) => {\n\n\t\t\t\tconst hash = hashVertex( ...pos, ...norm, ...uv );\n\t\t\t\tif ( ! ( hash in vertToNewIndexMap ) ) {\n\n\t\t\t\t\tvertToNewIndexMap[ hash ] = nextIndex;\n\t\t\t\t\tnextIndex ++;\n\n\t\t\t\t\tskirtResult.attributes.position.push( ...pos );\n\t\t\t\t\tskirtResult.attributes.normal.push( ...norm );\n\t\t\t\t\tskirtResult.attributes.uv.push( ...uv );\n\n\t\t\t\t}\n\n\t\t\t\tskirtResult.index.push( vertToNewIndexMap[ hash ] );\n\n\t\t\t};\n\n\t\t\t// TODO: this seems to have some problematic cases at the root tiles near the poles\n\t\t\tconst capIndex = capResult.index;\n\t\t\tconst capUv = capResult.attributes.uv;\n\t\t\tconst capPosition = capResult.attributes.position;\n\t\t\tconst capNormal = capResult.attributes.normal;\n\t\t\tconst capTriangles = capResult.index.length / 3;\n\t\t\tfor ( let i = 0; i < capTriangles; i ++ ) {\n\n\t\t\t\tconst triOffset = 3 * i;\n\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\t\tconst ne = ( e + 1 ) % 3;\n\t\t\t\t\tconst i0 = capIndex[ triOffset + e ];\n\t\t\t\t\tconst i1 = capIndex[ triOffset + ne ];\n\n\t\t\t\t\t_uv0.fromArray( capUv, i0 * 2 );\n\t\t\t\t\t_uv1.fromArray( capUv, i1 * 2 );\n\n\t\t\t\t\t// find the vertices that lie on the edge\n\t\t\t\t\tif (\n\t\t\t\t\t\t_uv0.x === _uv1.x && ( _uv0.x === 0 || _uv0.x === 0.5 || _uv0.x === 1.0 ) ||\n\t\t\t\t\t\t_uv0.y === _uv1.y && ( _uv0.y === 0 || _uv0.y === 0.5 || _uv0.y === 1.0 )\n\t\t\t\t\t) {\n\n\t\t\t\t\t\t_pos0.fromArray( capPosition, i0 * 3 );\n\t\t\t\t\t\t_pos1.fromArray( capPosition, i1 * 3 );\n\n\t\t\t\t\t\tconst u0 = _pos0;\n\t\t\t\t\t\tconst u1 = _pos1;\n\n\t\t\t\t\t\tconst b0 = _pos2.copy( _pos0 );\n\t\t\t\t\t\tconst b1 = _pos3.copy( _pos1 );\n\n\t\t\t\t\t\t_temp.copy( b0 ).add( sourceMesh.position );\n\t\t\t\t\t\tellipsoid.getPositionToNormal( _temp, _temp );\n\t\t\t\t\t\tb0.addScaledVector( _temp, - skirtLength );\n\n\t\t\t\t\t\t_temp.copy( b1 ).add( sourceMesh.position );\n\t\t\t\t\t\tellipsoid.getPositionToNormal( _temp, _temp );\n\t\t\t\t\t\tb1.addScaledVector( _temp, - skirtLength );\n\n\t\t\t\t\t\tif ( smoothSkirtNormals && capNormal ) {\n\n\t\t\t\t\t\t\t_temp.fromArray( capNormal, i0 * 3 );\n\t\t\t\t\t\t\t_temp2.fromArray( capNormal, i1 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_temp.subVectors( u0, u1 );\n\t\t\t\t\t\t\t_temp2.subVectors( u0, b0 ).cross( _temp ).normalize();\n\t\t\t\t\t\t\t_temp.copy( _temp2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpushVertex( u1, _uv1, _temp2 );\n\t\t\t\t\t\tpushVertex( u0, _uv0, _temp );\n\t\t\t\t\t\tpushVertex( b0, _uv0, _temp );\n\n\t\t\t\t\t\tpushVertex( u1, _uv1, _temp2 );\n\t\t\t\t\t\tpushVertex( b0, _uv0, _temp );\n\t\t\t\t\t\tpushVertex( b1, _uv1, _temp2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst capLength = capResult.index.length;\n\t\tconst result = capResult;\n\t\tif ( botResult ) {\n\n\t\t\tconst { index, attributes } = botResult;\n\t\t\tconst offset = result.attributes.position.length / 3;\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tresult.index.push( index[ i ] + offset );\n\n\t\t\t}\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tresult.attributes[ key ].push( ...attributes[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( skirtResult ) {\n\n\t\t\tconst { index, attributes } = skirtResult;\n\t\t\tconst offset = result.attributes.position.length / 3;\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tresult.index.push( index[ i ] + offset );\n\n\t\t\t}\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tresult.attributes[ key ].push( ...attributes[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// offset the uvs\n\t\tconst xUvOffset = left ? 0 : - 0.5;\n\t\tconst yUvOffset = bottom ? 0 : - 0.5;\n\t\tconst uv = result.attributes.uv;\n\t\tfor ( let i = 0, l = uv.length; i < l; i += 2 ) {\n\n\t\t\tuv[ i ] = ( uv[ i ] + xUvOffset ) * 2.0;\n\t\t\tuv[ i + 1 ] = ( uv[ i + 1 ] + yUvOffset ) * 2.0;\n\n\t\t}\n\n\t\t// construct the result\n\t\tconst resultMesh = this.constructMesh( result.attributes, result.index, sourceMesh );\n\t\tresultMesh.userData.minHeight = sourceMesh.userData.minHeight;\n\t\tresultMesh.userData.maxHeight = sourceMesh.userData.maxHeight;\n\n\t\tlet materialIndex = 0;\n\t\tlet start = 0;\n\t\tresultMesh.geometry.addGroup( start, capLength, materialIndex );\n\t\tstart += capLength;\n\t\tmaterialIndex ++;\n\n\t\tif ( botResult ) {\n\n\t\t\tresultMesh.geometry.addGroup( start, botResult.index.length, materialIndex );\n\t\t\tstart += botResult.index.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\tif ( skirtResult ) {\n\n\t\t\tresultMesh.geometry.addGroup( start, skirtResult.index.length, materialIndex );\n\t\t\tstart += skirtResult.index.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\treturn resultMesh;\n\n\t}\n\n\tadjustVertices( info, position, offset ) {\n\n\t\tconst { ellipsoid, minLat, maxLat, minLon, maxLon } = this;\n\t\tconst { attributes, vertexIsClipped } = info;\n\t\tconst posArr = attributes.position;\n\t\tconst uvArr = attributes.uv;\n\n\t\tconst vertexCount = posArr.length / 3;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tconst uv = _uv0.fromArray( uvArr, i * 2 );\n\t\t\tif ( vertexIsClipped && vertexIsClipped[ i ] ) {\n\n\t\t\t\tif ( Math.abs( uv.x - 0.5 ) < 1e-10 ) {\n\n\t\t\t\t\tuv.x = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\tif ( Math.abs( uv.y - 0.5 ) < 1e-10 ) {\n\n\t\t\t\t\tuv.y = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\t_uv0.toArray( uvArr, i * 2 );\n\n\t\t\t}\n\n\t\t\tconst lat = MathUtils.lerp( minLat, maxLat, uv.y );\n\t\t\tconst lon = MathUtils.lerp( minLon, maxLon, uv.x );\n\t\t\tconst point = _vec.fromArray( posArr, i * 3 ).add( position );\n\t\t\tellipsoid.getPositionToCartographic( point, _cart );\n\t\t\tellipsoid.getCartographicToPosition( lat, lon, _cart.height + offset, point );\n\t\t\tpoint.sub( position );\n\t\t\tpoint.toArray( posArr, i * 3 );\n\n\t\t}\n\n\t}\n\n}\n\nfunction getUvSplitOperation( axis ) {\n\n\treturn ( geometry, i0, i1, i2, barycoord ) => {\n\n\t\tconst uv = geometry.attributes.uv;\n\t\t_uv0.fromBufferAttribute( uv, i0 );\n\t\t_uv1.fromBufferAttribute( uv, i1 );\n\t\t_uv2.fromBufferAttribute( uv, i2 );\n\n\t\treturn _uv0[ axis ] * barycoord.x + _uv1[ axis ] * barycoord.y + _uv2[ axis ] * barycoord.z - 0.5;\n\n\t};\n\n}\n","import { Vector3 } from 'three';\nimport { QuantizedMeshLoader } from './loaders/QuantizedMeshLoader.js';\nimport { TilingScheme } from './images/utils/TilingScheme.js';\nimport { ProjectionScheme } from './images/utils/ProjectionScheme.js';\nimport { QuantizedMeshClipper } from './utilities/QuantizedMeshClipper.js';\n\nconst TILE_X = Symbol( 'TILE_X' );\nconst TILE_Y = Symbol( 'TILE_Y' );\nconst TILE_LEVEL = Symbol( 'TILE_LEVEL' );\nconst TILE_AVAILABLE = Symbol( 'TILE_AVAILABLE' );\n\n// We don't know the height ranges for the tileset on load so assume a large range and\n// adjust it once the tiles have actually loaded based on the min and max height\nconst INITIAL_HEIGHT_RANGE = 1e4;\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// Checks if the given tile is available\nfunction isTileAvailable( available, level, x, y ) {\n\n\tif ( available && level < available.length ) {\n\n\t\t// TODO: consider a binary search\n\t\tconst availableSet = available[ level ];\n\t\tfor ( let i = 0, l = availableSet.length; i < l; i ++ ) {\n\n\t\t\tconst { startX, startY, endX, endY } = availableSet[ i ];\n\t\t\tif ( x >= startX && x <= endX && y >= startY && y <= endY ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n// Calculates the max level that can be loaded.\nfunction getMaxLevel( layer ) {\n\n\tconst { available = null, maxzoom = null } = layer;\n\treturn maxzoom === null ? available.length - 1 : maxzoom;\n\n}\n\n// Calculates whether metadata availability is present - returns -1 if not.\nfunction getMetadataAvailability( layer ) {\n\n\tconst { metadataAvailability = - 1 } = layer;\n\treturn metadataAvailability;\n\n}\n\n// Calculates whether the given tile should have metadata availability\nfunction getTileHasMetadata( tile, layer ) {\n\n\tconst level = tile[ TILE_LEVEL ];\n\tconst metadataAvailability = getMetadataAvailability( layer );\n\tconst maxLevel = getMaxLevel( layer );\n\n\treturn level < maxLevel && metadataAvailability !== - 1 && ( level % metadataAvailability ) === 0;\n\n}\n\n// Constructs the url for the given tile content\nfunction getContentUrl( x, y, level, version, layer ) {\n\n\treturn layer.tiles[ 0 ]\n\t\t.replace( /{\\s*z\\s*}/g, level )\n\t\t.replace( /{\\s*x\\s*}/g, x )\n\t\t.replace( /{\\s*y\\s*}/g, y )\n\t\t.replace( /{\\s*version\\s*}/g, version );\n\n}\n\nexport class QuantizedMeshPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tuseRecommendedSettings = true,\n\t\t\tskirtLength = null,\n\t\t\tsmoothSkirtNormals = true,\n\t\t\tgenerateNormals = true,\n\t\t\tsolid = false,\n\t\t} = options;\n\n\t\t// plugin needs to run before other plugins that fetch data since content\n\t\t// is handled and loaded in a custom way\n\t\tthis.name = 'QUANTIZED_MESH_PLUGIN';\n\t\tthis.priority = - 1000;\n\n\t\tthis.tiles = null;\n\t\tthis.layer = null;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\t\tthis.skirtLength = skirtLength;\n\t\tthis.smoothSkirtNormals = smoothSkirtNormals;\n\t\tthis.solid = solid;\n\t\tthis.generateNormals = generateNormals;\n\t\tthis.attribution = null;\n\n\t\tthis.tiling = new TilingScheme();\n\t\tthis.projection = new ProjectionScheme();\n\n\t}\n\n\t// Plugin function\n\tinit( tiles ) {\n\n\t\t// TODO: should we avoid setting this globally?\n\t\ttiles.fetchOptions.headers = tiles.fetchOptions.headers || {};\n\t\ttiles.fetchOptions.headers.Accept = 'application/vnd.quantized-mesh,application/octet-stream;q=0.9';\n\n\t\tif ( this.useRecommendedSettings ) {\n\n\t\t\ttiles.errorTarget = 2;\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\n\t}\n\n\tloadRootTileset() {\n\n\t\tconst { tiles } = this;\n\n\t\t// initialize href to resolve the root in case it's specified as a relative url\n\t\tlet url = new URL( 'layer.json', new URL( tiles.rootURL, location.href ) );\n\t\ttiles.invokeAllPlugins( plugin => url = plugin.preprocessURL ? plugin.preprocessURL( url, null ) : url );\n\n\t\treturn tiles\n\t\t\t.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( url, this.tiles.fetchOptions ) )\n\t\t\t.then( res => res.json() )\n\t\t\t.then( json => {\n\n\t\t\t\tthis.layer = json;\n\t\t\t\tconst {\n\t\t\t\t\tprojection: layerProjection = 'EPSG:4326',\n\t\t\t\t\textensions = [],\n\t\t\t\t\tattribution = '',\n\t\t\t\t\tavailable = null,\n\t\t\t\t} = json;\n\n\t\t\t\tconst {\n\t\t\t\t\ttiling,\n\t\t\t\t\ttiles,\n\t\t\t\t\tprojection,\n\t\t\t\t} = this;\n\n\t\t\t\t// attribution\n\t\t\t\tif ( attribution ) {\n\n\t\t\t\t\tthis.attribution = {\n\t\t\t\t\t\tvalue: attribution,\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tcollapsible: true,\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\t// extensions\n\t\t\t\tif ( extensions.length > 0 ) {\n\n\t\t\t\t\ttiles.fetchOptions.headers[ 'Accept' ] += `;extensions=${ extensions.join( '-' ) }`;\n\n\t\t\t\t}\n\n\t\t\t\t// initialize tiling, projection\n\t\t\t\tprojection.setScheme( layerProjection );\n\n\t\t\t\tconst { tileCountX, tileCountY } = projection;\n\t\t\t\ttiling.setProjection( projection );\n\t\t\t\ttiling.generateLevels( getMaxLevel( json ) + 1, tileCountX, tileCountY );\n\n\t\t\t\t// initialize children\n\t\t\t\tconst children = [];\n\t\t\t\tfor ( let x = 0; x < tileCountX; x ++ ) {\n\n\t\t\t\t\tconst child = this.createChild( 0, x, 0, available );\n\t\t\t\t\tif ( child ) {\n\n\t\t\t\t\t\tchildren.push( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// produce the tileset root\n\t\t\t\tconst tileset = {\n\t\t\t\t\tasset: {\n\t\t\t\t\t\tversion: '1.1'\n\t\t\t\t\t},\n\t\t\t\t\tgeometricError: Infinity,\n\t\t\t\t\troot: {\n\t\t\t\t\t\trefine: 'REPLACE',\n\t\t\t\t\t\tgeometricError: Infinity,\n\t\t\t\t\t\tboundingVolume: {\n\t\t\t\t\t\t\tregion: [ ...this.tiling.getContentBounds(), - INITIAL_HEIGHT_RANGE, INITIAL_HEIGHT_RANGE ],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tchildren: children,\n\n\t\t\t\t\t\t[ TILE_AVAILABLE ]: available,\n\t\t\t\t\t\t[ TILE_LEVEL ]: - 1,\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tlet baseUrl = tiles.rootURL;\n\t\t\t\ttiles.invokeAllPlugins( plugin => baseUrl = plugin.preprocessURL ? plugin.preprocessURL( baseUrl, null ) : baseUrl );\n\t\t\t\ttiles.preprocessTileset( tileset, baseUrl );\n\n\t\t\t\treturn tileset;\n\n\t\t\t} );\n\n\t}\n\n\tparseToMesh( buffer, tile, extension, uri ) {\n\n\t\tconst {\n\t\t\tskirtLength,\n\t\t\tsolid,\n\t\t\tsmoothSkirtNormals,\n\t\t\tgenerateNormals,\n\t\t\ttiles,\n\t\t} = this;\n\n\t\t// set up loader\n\t\tconst ellipsoid = tiles.ellipsoid;\n\n\t\t// split the parent tile if needed\n\t\tlet result;\n\t\tif ( extension === 'quantized_tile_split' ) {\n\n\t\t\t// split the parent tile\n\t\t\tconst searchParams = new URL( uri ).searchParams;\n\t\t\tconst left = searchParams.get( 'left' ) === 'true';\n\t\t\tconst bottom = searchParams.get( 'bottom' ) === 'true';\n\n\t\t\t// parse the tile data\n\t\t\tconst clipper = new QuantizedMeshClipper();\n\t\t\tclipper.ellipsoid.copy( ellipsoid );\n\t\t\tclipper.solid = solid;\n\t\t\tclipper.smoothSkirtNormals = smoothSkirtNormals;\n\t\t\tclipper.skirtLength = skirtLength === null ? tile.geometricError : skirtLength;\n\n\t\t\tconst [ west, south, east, north ] = tile.parent.boundingVolume.region;\n\t\t\tclipper.minLat = south;\n\t\t\tclipper.maxLat = north;\n\t\t\tclipper.minLon = west;\n\t\t\tclipper.maxLon = east;\n\n\t\t\tresult = clipper.clipToQuadrant( tile.parent.cached.scene, left, bottom );\n\n\t\t} else if ( extension === 'terrain' ) {\n\n\t\t\tconst loader = new QuantizedMeshLoader( tiles.manager );\n\t\t\tloader.ellipsoid.copy( ellipsoid );\n\t\t\tloader.solid = solid;\n\t\t\tloader.smoothSkirtNormals = smoothSkirtNormals;\n\t\t\tloader.generateNormals = generateNormals;\n\t\t\tloader.skirtLength = skirtLength === null ? tile.geometricError : skirtLength;\n\n\t\t\tconst [ west, south, east, north ] = tile.boundingVolume.region;\n\t\t\tloader.minLat = south;\n\t\t\tloader.maxLat = north;\n\t\t\tloader.minLon = west;\n\t\t\tloader.maxLon = east;\n\n\t\t\tresult = loader.parse( buffer );\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// adjust the bounding region to be more accurate based on the contents of the terrain file\n\t\t// NOTE: The debug region bounds are only created after the tile is first shown so the debug\n\t\t// region bounding volume will have the correct dimensions.\n\t\tconst { minHeight, maxHeight, metadata } = result.userData;\n\t\ttile.boundingVolume.region[ 4 ] = minHeight;\n\t\ttile.boundingVolume.region[ 5 ] = maxHeight;\n\t\ttile.cached.boundingVolume.setRegionData( ellipsoid, ...tile.boundingVolume.region );\n\n\t\t// use the geometric error value if it's present\n\t\tif ( metadata ) {\n\n\t\t\tif ( 'geometricerror' in metadata ) {\n\n\t\t\t\ttile.geometricError = metadata.geometricerror;\n\n\t\t\t}\n\n\t\t\t// if the tile hasn't been expanded yet and isn't in the queue to do so then\n\t\t\t// mark it for expansion again\n\t\t\tconst hasMetadata = getTileHasMetadata( tile, this.layer );\n\t\t\tif ( hasMetadata && 'available' in metadata && tile.children.length === 0 ) {\n\n\t\t\t\t// add an offset to account for the current and previous layers\n\t\t\t\ttile[ TILE_AVAILABLE ] = [\n\t\t\t\t\t...new Array( tile[ TILE_LEVEL ] + 1 ).fill( null ),\n\t\t\t\t\t...metadata.available,\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// NOTE: we expand children only once the parent mesh data is loaded to ensure the mesh\n\t\t// data is ready for clipping. It's possible that this child data gets to the parse stage\n\t\t// first, otherwise, while the parent is still downloading.\n\t\t// Ideally we would be able to guarantee parents are loaded first but this is an odd case.\n\t\tthis.expandChildren( tile );\n\n\t\treturn result;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.attribution ) {\n\n\t\t\ttarget.push( this.attribution );\n\n\t\t}\n\n\t}\n\n\t// Local functions\n\tcreateChild( level, x, y, available ) {\n\n\t\tconst { tiles, layer, tiling, projection } = this;\n\t\tconst ellipsoid = tiles.ellipsoid;\n\n\t\t// metadata availability will return \"null\" if there are no more children but we\n\t\t// have to always load the root tile data.\n\t\tconst isAvailable = available === null && level === 0 || isTileAvailable( available, level, x, y );\n\t\tconst url = getContentUrl( x, y, level, 1, layer );\n\t\tconst region = [ ...tiling.getTileBounds( x, y, level ), - INITIAL_HEIGHT_RANGE, INITIAL_HEIGHT_RANGE ];\n\t\tconst [ /* west */, south, /* east */, north, /* minHeight */, maxHeight ] = region;\n\t\tconst midLat = ( south > 0 ) !== ( north > 0 ) ? 0 : Math.min( Math.abs( south ), Math.abs( north ) );\n\n\t\t// get the projected perimeter\n\t\tellipsoid.getCartographicToPosition( midLat, 0, maxHeight, _vec );\n\t\t_vec.z = 0;\n\n\t\t// https://github.com/CesiumGS/cesium/blob/53889cbed2a91d38e0fae4b6f2dcf6783632fc92/packages/engine/Source/Scene/QuadtreeTileProvider.js#L24-L31\n\t\t// Implicit quantized mesh tile error halves with every layer\n\t\tconst tileCountX = projection.tileCountX;\n\t\tconst maxRadius = Math.max( ...ellipsoid.radius );\n\t\tconst rootGeometricError = maxRadius * 2 * Math.PI * 0.25 / ( 65 * tileCountX );\n\t\tconst geometricError = rootGeometricError / ( 2 ** level );\n\n\t\t// Create the child\n\t\tconst tile = {\n\t\t\t[ TILE_AVAILABLE ]: null,\n\t\t\t[ TILE_LEVEL ]: level,\n\t\t\t[ TILE_X ]: x,\n\t\t\t[ TILE_Y ]: y,\n\t\t\trefine: 'REPLACE',\n\t\t\tgeometricError: geometricError,\n\t\t\tboundingVolume: { region },\n\t\t\tcontent: isAvailable ? { uri: url } : null,\n\t\t\tchildren: []\n\t\t};\n\n\t\t// if we're relying on tile metadata availability then skip storing the tile metadata\n\t\tif ( ! getTileHasMetadata( tile, layer ) ) {\n\n\t\t\ttile[ TILE_AVAILABLE ] = available;\n\n\t\t}\n\n\t\treturn tile;\n\n\t}\n\n\texpandChildren( tile ) {\n\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst x = tile[ TILE_X ];\n\t\tconst y = tile[ TILE_Y ];\n\t\tconst available = tile[ TILE_AVAILABLE ];\n\n\t\t// only expand down to the highest level\n\t\tif ( level >= this.tiling.maxLevel ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet hasChildren = false;\n\t\tfor ( let cx = 0; cx < 2; cx ++ ) {\n\n\t\t\tfor ( let cy = 0; cy < 2; cy ++ ) {\n\n\t\t\t\tconst child = this.createChild( level + 1, 2 * x + cx, 2 * y + cy, available );\n\t\t\t\tif ( child.content !== null ) {\n\n\t\t\t\t\ttile.children.push( child );\n\t\t\t\t\thasChildren = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttile.children.push( child );\n\t\t\t\t\tchild.content = { uri: `tile.quantized_tile_split?bottom=${ cy === 0 }&left=${ cx === 0 }` };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! hasChildren ) {\n\n\t\t\ttile.children.length = 0;\n\n\t\t}\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\t// if this is our custom url indicating a tile split then return fake response\n\t\tif ( /quantized_tile_split/.test( uri ) ) {\n\n\t\t\treturn new ArrayBuffer();\n\n\t\t}\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// dispose of the available array since we will get it again if this tile is loaded\n\t\tif ( getTileHasMetadata( tile, this.layer ) ) {\n\n\t\t\ttile[ TILE_AVAILABLE ] = null;\n\n\t\t}\n\n\t\t// Note: we remove all children always because child tiles can rely on splitting parent tiles\n\t\t// and we can find ourselves in a situation where a child tile is ready first but the parent tile\n\t\t// hasn't loaded, causing a stall / race condition in the parsing queue. To avoid this dependency\n\t\t// we just remove all children and generate them again one the parent is loaded.\n\t\t// Only get rid of the children if this plugin was responsible for them.\n\t\tif ( TILE_AVAILABLE in tile ) {\n\n\t\t\ttile.children.forEach( child => {\n\n\t\t\t\t// TODO: there should be a reliable way for removing children like this.\n\t\t\t\tthis.tiles.processNodeQueue.remove( child );\n\n\t\t\t} );\n\t\t\ttile.children.length = 0;\n\t\t\ttile.__childrenProcessed = 0;\n\n\t\t}\n\n\t}\n\n}\n","import { CesiumIonAuthPlugin as CesiumIonAuthPluginImpl } from '3d-tiles-renderer/core/plugins';\nimport { TMSTilesPlugin } from './images/EPSGTilesPlugin.js';\nimport { QuantizedMeshPlugin } from './QuantizedMeshPlugin.js';\n\nexport class CesiumIonAuthPlugin extends CesiumIonAuthPluginImpl {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( {\n\t\t\tassetTypeHandler: ( type, tiles, asset ) => {\n\n\t\t\t\tif ( type === 'TERRAIN' && tiles.getPluginByName( 'QUANTIZED_MESH_PLUGIN' ) === null ) {\n\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'CesiumIonAuthPlugin: CesiumIonAuthPlugin plugin auto-registration has been deprecated. ' +\n\t\t\t\t\t\t'Please implement a custom \"assetTypeHandler\" for \"TERRAIN\" using \"QuantizedMeshPlugin\", instead.'\n\t\t\t\t\t);\n\t\t\t\t\ttiles.registerPlugin( new QuantizedMeshPlugin( {\n\t\t\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t\t\t} ) );\n\n\t\t\t\t} else if ( type === 'IMAGERY' && tiles.getPluginByName( 'TMS_TILES_PLUGIN' ) === null ) {\n\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'CesiumIonAuthPlugin: CesiumIonAuthPlugin plugin auto-registration has been deprecated. ' +\n\t\t\t\t\t\t'Please implement a custom \"assetTypeHandler\" for \"IMAGERY\" using \"TMSTilesPlugin\", instead.'\n\t\t\t\t\t);\n\t\t\t\t\ttiles.registerPlugin( new TMSTilesPlugin( {\n\t\t\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t\t\t\tshape: 'ellipsoid',\n\t\t\t\t\t} ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( `CesiumIonAuthPlugin: Cesium Ion asset type \"${ type }\" unhandled.` );\n\n\t\t\t\t}\n\n\t\t\t},\n\t\t\t...options,\n\t\t} );\n\n\t\tif ( options.__suppress_warning__ ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'CesiumIonAuthPlugin: Plugin has been moved to \"3d-tiles-renderer/core/plugins\".'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4 } from 'three';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nexport class UpdateOnChangePlugin {\n\n\tconstructor() {\n\n\t\tthis.name = 'UPDATE_ON_CHANGE_PLUGIN';\n\t\tthis.tiles = null;\n\t\tthis.needsUpdate = false;\n\t\tthis.cameraMatrices = new Map();\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\t// register callbacks to add cameras and force a new update\n\t\tthis._needsUpdateCallback = () => {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t};\n\n\t\tthis._onCameraAdd = ( { camera } ) => {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cameraMatrices.set( camera, new Matrix4() );\n\n\t\t};\n\n\t\tthis._onCameraDelete = ( { camera } ) => {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cameraMatrices.delete( camera );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'needs-update', this._needsUpdateCallback );\n\t\ttiles.addEventListener( 'add-camera', this._onCameraAdd );\n\t\ttiles.addEventListener( 'delete-camera', this._onCameraDelete );\n\t\ttiles.addEventListener( 'camera-resolution-change', this._needsUpdateCallback );\n\n\t\t// register any already-present cameras\n\t\ttiles.cameras.forEach( camera => {\n\n\t\t\tthis._onCameraAdd( { camera } );\n\n\t\t} );\n\n\t}\n\n\tdoTilesNeedUpdate() {\n\n\t\tconst tiles = this.tiles;\n\t\tlet didCamerasChange = false;\n\t\tthis.cameraMatrices.forEach( ( matrix, camera ) => {\n\n\t\t\t// check if the camera position or frustum changed by comparing the MVP\n\t\t\t// matrix between frames\n\t\t\t_matrix\n\t\t\t\t.copy( tiles.group.matrixWorld )\n\t\t\t\t.premultiply( camera.matrixWorldInverse )\n\t\t\t\t.premultiply( camera.projectionMatrixInverse );\n\n\t\t\tdidCamerasChange = didCamerasChange || ! _matrix.equals( matrix );\n\t\t\tmatrix.copy( _matrix );\n\n\t\t} );\n\n\t\tconst needsUpdate = this.needsUpdate;\n\t\tthis.needsUpdate = false;\n\n\t\treturn needsUpdate || didCamerasChange;\n\n\t}\n\n\tpreprocessNode() {\n\n\t\t// trigger a new update when nodes are processed because hte process happens asynchronously\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tconst tiles = this.tiles;\n\t\ttiles.removeEventListener( 'camera-resolution-change', this._needsUpdateCallback );\n\t\ttiles.removeEventListener( 'needs-update', this._needsUpdateCallback );\n\t\ttiles.removeEventListener( 'add-camera', this._onCameraAdd );\n\t\ttiles.removeEventListener( 'delete-camera', this._onCameraDelete );\n\n\t}\n\n}\n","import { Vector3, LinearFilter, BufferAttribute, MathUtils } from 'three';\n\nconst _vec = /* @__PURE__ */ new Vector3();\nfunction compressAttribute( attribute, arrayType ) {\n\n\tif ( attribute.isInterleavedBufferAttribute || attribute.array instanceof arrayType ) {\n\n\t\treturn attribute;\n\n\t}\n\n\tconst signed = arrayType === Int8Array || arrayType === Int16Array || arrayType === Int32Array;\n\tconst minValue = signed ? - 1 : 0;\n\n\tconst array = new arrayType( attribute.count * attribute.itemSize );\n\tconst newAttribute = new BufferAttribute( array, attribute.itemSize, true );\n\tconst itemSize = attribute.itemSize;\n\tconst count = attribute.count;\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\tconst v = MathUtils.clamp( attribute.getComponent( i, j ), minValue, 1 );\n\t\t\tnewAttribute.setComponent( i, j, v );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\nfunction compressPositionAttribute( mesh, arrayType = Int16Array ) {\n\n\tconst geometry = mesh.geometry;\n\tconst attributes = geometry.attributes;\n\tconst attribute = attributes.position;\n\n\t// skip if it's already compressed to the provided level\n\tif ( attribute.isInterleavedBufferAttribute || attribute.array instanceof arrayType ) {\n\n\t\treturn attribute;\n\n\t}\n\n\t// new attribute data\n\tconst array = new arrayType( attribute.count * attribute.itemSize );\n\tconst newAttribute = new BufferAttribute( array, attribute.itemSize, false );\n\tconst itemSize = attribute.itemSize;\n\tconst count = attribute.count;\n\n\t// bounding box stride\n\t// TODO: the bounding box is computed every time even if it already exists because\n\t// it's possible that the encoded value is incorrect causing artifacts\n\tgeometry.computeBoundingBox();\n\n\tconst boundingBox = geometry.boundingBox;\n\tconst { min, max } = boundingBox;\n\n\t// array range\n\tconst maxValue = 2 ** ( 8 * arrayType.BYTES_PER_ELEMENT - 1 ) - 1;\n\tconst minValue = - maxValue;\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\tconst key = j === 0 ? 'x' : j === 1 ? 'y' : 'z';\n\t\t\tconst bbMinValue = min[ key ];\n\t\t\tconst bbMaxValue = max[ key ];\n\n\t\t\t// scale the geometry values to the integer range\n\t\t\tconst v = MathUtils.mapLinear(\n\t\t\t\tattribute.getComponent( i, j ),\n\t\t\t\tbbMinValue, bbMaxValue,\n\t\t\t\tminValue, maxValue,\n\t\t\t);\n\n\t\t\tnewAttribute.setComponent( i, j, v );\n\n\t\t}\n\n\t}\n\n\t// shift the mesh to the center of the bounds\n\tboundingBox\n\t\t.getCenter( _vec )\n\t\t.multiply( mesh.scale )\n\t\t.applyQuaternion( mesh.quaternion );\n\tmesh.position.add( _vec );\n\n\t// adjust the scale to accommodate the new geometry data range\n\tmesh.scale.x *= 0.5 * ( max.x - min.x ) / maxValue;\n\tmesh.scale.y *= 0.5 * ( max.y - min.y ) / maxValue;\n\tmesh.scale.z *= 0.5 * ( max.z - min.z ) / maxValue;\n\n\tattributes.position = newAttribute;\n\tmesh.geometry.boundingBox = null;\n\tmesh.geometry.boundingSphere = null;\n\n\tmesh.updateMatrixWorld();\n\n}\n\nexport class TileCompressionPlugin {\n\n\tconstructor( options ) {\n\n\t\tthis._options = {\n\t\t\t// whether to generate normals if they don't already exist.\n\t\t\tgenerateNormals: false,\n\n\t\t\t// whether to disable use of mipmaps since they are typically not necessary\n\t\t\t// with something like 3d tiles.\n\t\t\tdisableMipmaps: true,\n\n\t\t\t// whether to compress certain attributes\n\t\t\tcompressIndex: true,\n\t\t\tcompressNormals: false,\n\t\t\tcompressUvs: false,\n\t\t\tcompressPosition: false,\n\n\t\t\t// the TypedArray type to use when compressing the attributes\n\t\t\tuvType: Int8Array,\n\t\t\tnormalType: Int8Array,\n\t\t\tpositionType: Int16Array,\n\n\t\t\t...options,\n\t\t};\n\n\t\tthis.name = 'TILES_COMPRESSION_PLUGIN';\n\t\tthis.priority = - 100;\n\n\t}\n\n\tprocessTileModel( scene, tile ) {\n\n\t\tconst {\n\t\t\tgenerateNormals,\n\n\t\t\tdisableMipmaps,\n\t\t\tcompressIndex,\n\t\t\tcompressUvs,\n\t\t\tcompressNormals,\n\t\t\tcompressPosition,\n\n\t\t\tuvType,\n\t\t\tnormalType,\n\t\t\tpositionType,\n\t\t} = this._options;\n\n\t\tscene.traverse( c => {\n\n\t\t\t// handle materials\n\t\t\tif ( c.material && disableMipmaps ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture && value.generateMipmaps ) {\n\n\t\t\t\t\t\tvalue.generateMipmaps = false;\n\t\t\t\t\t\tvalue.minFilter = LinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// handle geometry attribute compression\n\t\t\tif ( c.geometry ) {\n\n\t\t\t\tconst geometry = c.geometry;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tif ( compressUvs ) {\n\n\t\t\t\t\tconst { uv, uv1, uv2, uv3 } = attributes;\n\t\t\t\t\tif ( uv ) attributes.uv = compressAttribute( uv, uvType );\n\t\t\t\t\tif ( uv1 ) attributes.uv1 = compressAttribute( uv1, uvType );\n\t\t\t\t\tif ( uv2 ) attributes.uv2 = compressAttribute( uv2, uvType );\n\t\t\t\t\tif ( uv3 ) attributes.uv3 = compressAttribute( uv3, uvType );\n\n\t\t\t\t}\n\n\t\t\t\tif ( generateNormals && ! attributes.normals ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t}\n\n\t\t\t\tif ( compressNormals && attributes.normals ) {\n\n\t\t\t\t\tattributes.normals = compressAttribute( attributes.normals, normalType );\n\n\t\t\t\t}\n\n\t\t\t\tif ( compressPosition ) {\n\n\t\t\t\t\tcompressPositionAttribute( c, positionType );\n\n\t\t\t\t}\n\n\t\t\t\tif ( compressIndex && geometry.index ) {\n\n\t\t\t\t\tconst vertCount = attributes.position.count;\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tconst type = vertCount > 65535 ? Uint32Array : vertCount > 255 ? Uint16Array : Uint8Array;\n\t\t\t\t\tif ( ! ( index.array instanceof type ) ) {\n\n\t\t\t\t\t\tconst array = new type( geometry.index.count );\n\t\t\t\t\t\tarray.set( index.array );\n\n\t\t\t\t\t\tconst attribute = new BufferAttribute( array, 1 );\n\t\t\t\t\t\tgeometry.setIndex( attribute );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import {\n\tVector2,\n\tVector3,\n\tVector4,\n\tMatrix2,\n\tMatrix3,\n\tMatrix4,\n} from 'three';\n\n// returns the field in the object with a resolved default\nexport function getField( object, key, def ) {\n\n\treturn object && key in object ? object[ key ] : def;\n\n}\n\n// checks the structural metadata type\nexport function isNumericType( type ) {\n\n\treturn type !== 'BOOLEAN' && type !== 'STRING' && type !== 'ENUM';\n\n}\n\n// check if the class property type is a float component type value\nexport function isFloatComponentType( type ) {\n\n\treturn /^FLOAT/.test( type );\n\n}\n\n// check if the class property type is a vector type\nexport function isVectorType( type ) {\n\n\treturn /^VEC/.test( type );\n\n}\n\n// check if the class property type is a matrix type\nexport function isMatrixType( type ) {\n\n\treturn /^MAT/.test( type );\n\n}\n\n// returns a value from the given buffer of the given type\nexport function readDataFromBufferToType( buffer, offset, type, target = null ) {\n\n\tif ( isMatrixType( type ) ) {\n\n\t\treturn target.fromArray( buffer, offset );\n\n\t} else if ( isVectorType( type ) ) {\n\n\t\treturn target.fromArray( buffer, offset );\n\n\t} else {\n\n\t\treturn buffer[ offset ];\n\n\t}\n\n}\n\n// gets a new instance of the given structural metadata type\nexport function getTypeInstance( property ) {\n\n\tconst { type, componentType } = property;\n\tswitch ( type ) {\n\n\t\tcase 'SCALAR': return componentType === 'INT64' ? 0n : 0;\n\t\tcase 'VEC2': return new Vector2();\n\t\tcase 'VEC3': return new Vector3();\n\t\tcase 'VEC4': return new Vector4();\n\t\tcase 'MAT2': return new Matrix2();\n\t\tcase 'MAT3': return new Matrix3();\n\t\tcase 'MAT4': return new Matrix4();\n\t\tcase 'BOOLEAN': return false;\n\t\tcase 'STRING': return '';\n\n\t\t// the final value for enums is a string but are represented as integers\n\t\t// during intermediate steps\n\t\tcase 'ENUM': return 0;\n\n\t}\n\n}\n\n// returns false if the given value is not of \"type\"\nexport function isTypeInstance( type, value ) {\n\n\tif ( value === null || value === undefined ) {\n\n\t\treturn false;\n\n\t}\n\n\tswitch ( type ) {\n\n\t\tcase 'SCALAR': return typeof value === 'number' || typeof value === 'bigint';\n\t\tcase 'VEC2': return value.isVector2;\n\t\tcase 'VEC3': return value.isVector3;\n\t\tcase 'VEC4': return value.isVector4;\n\t\tcase 'MAT2': return value.isMatrix2;\n\t\tcase 'MAT3': return value.isMatrix3;\n\t\tcase 'MAT4': return value.isMatrix4;\n\t\tcase 'BOOLEAN': return typeof value === 'boolean';\n\t\tcase 'STRING': return typeof value === 'string';\n\t\tcase 'ENUM': return typeof value === 'number' || typeof value === 'bigint';\n\n\t}\n\n\tthrow new Error( 'ClassProperty: invalid type.' );\n\n}\n\n// gets a new numeric array constructor from the given structural metadata type\nexport function getArrayConstructorFromComponentType( componentType, type = null ) {\n\n\tswitch ( componentType ) {\n\n\t\tcase 'INT8': return Int8Array;\n\t\tcase 'INT16': return Int16Array;\n\t\tcase 'INT32': return Int32Array;\n\t\tcase 'INT64': return BigInt64Array;\n\n\t\tcase 'UINT8': return Uint8Array;\n\t\tcase 'UINT16': return Uint16Array;\n\t\tcase 'UINT32': return Uint32Array;\n\t\tcase 'UINT64': return BigUint64Array;\n\n\t\tcase 'FLOAT32': return Float32Array;\n\t\tcase 'FLOAT64': return Float64Array;\n\n\t}\n\n\tswitch ( type ) {\n\n\t\tcase 'BOOLEAN': return Uint8Array;\n\t\tcase 'STRING': return Uint8Array;\n\n\t}\n\n\tthrow new Error( 'ClassProperty: invalid type.' );\n\n}\n\n// resolve a full default value for the given property including arrays\nexport function resolveDefault( property, target = null ) {\n\n\tconst array = property.array;\n\tif ( array ) {\n\n\t\ttarget = target && Array.isArray( target ) ? target : [];\n\t\ttarget.length = property.count;\n\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\ttarget[ i ] = resolveDefaultElement( property, target[ i ] );\n\n\t\t}\n\n\t} else {\n\n\t\ttarget = resolveDefaultElement( property, target );\n\n\t}\n\n\treturn target;\n\n}\n\n// gets the default value of the given type\nexport function resolveDefaultElement( property, target = null ) {\n\n\tconst defaultValue = property.default;\n\tconst type = property.type;\n\n\ttarget = target || getTypeInstance( property );\n\n\tif ( defaultValue === null ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 'SCALAR': return 0;\n\t\t\tcase 'VEC2': return target.set( 0, 0 );\n\t\t\tcase 'VEC3': return target.set( 0, 0, 0 );\n\t\t\tcase 'VEC4': return target.set( 0, 0, 0, 0 );\n\t\t\tcase 'MAT2': return target.identity();\n\t\t\tcase 'MAT3': return target.identity();\n\t\t\tcase 'MAT4': return target.identity();\n\t\t\tcase 'BOOLEAN': return false;\n\t\t\tcase 'STRING': return '';\n\t\t\tcase 'ENUM': return '';\n\n\t\t}\n\n\t\tthrow new Error( 'ClassProperty: invalid type.' );\n\n\t} else {\n\n\t\tif ( isMatrixType( type ) ) {\n\n\t\t\ttarget.fromArray( defaultValue );\n\n\t\t} else if ( isVectorType( type ) ) {\n\n\t\t\ttarget.fromArray( defaultValue );\n\n\t\t} else {\n\n\t\t\treturn defaultValue;\n\n\t\t}\n\n\t}\n\n}\n\n// check for of instances of \"no data\" in the given target value and adjust them to the\n// default value.\nexport function resolveNoData( property, target ) {\n\n\tif ( property.noData === null ) {\n\n\t\treturn target;\n\n\t}\n\n\tconst noData = property.noData;\n\tconst type = property.type;\n\tif ( Array.isArray( target ) ) {\n\n\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\ttarget[ i ] = performResolution( target[ i ] );\n\n\t\t}\n\n\t} else {\n\n\t\ttarget = performResolution( target );\n\n\t}\n\n\treturn target;\n\n\t// replace the value with a default if no data is encountered\n\tfunction performResolution( target ) {\n\n\t\tif ( isNoDataEqual( target ) ) {\n\n\t\t\ttarget = resolveDefaultElement( property, target );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// checks if the given value is equal to the no data value\n\tfunction isNoDataEqual( value ) {\n\n\t\tif ( isMatrixType( type ) ) {\n\n\t\t\tconst elements = value.elements;\n\t\t\tfor ( let i = 0, l = noData.length; i < l; i ++ ) {\n\n\t\t\t\tif ( noData[ i ] !== elements[ i ] ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else if ( isVectorType( type ) ) {\n\n\t\t\tfor ( let i = 0, l = noData.length; i < l; i ++ ) {\n\n\t\t\t\tif ( noData[ i ] !== value.getComponent( i ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn noData === value;\n\n\t\t}\n\n\t}\n\n}\n\nexport function normalizeValue( componentType, v ) {\n\n\t// formulas defined here but normalizing 64 bit ints will result in precision loss:\n\t// https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata/#normalized-values\n\tswitch ( componentType ) {\n\n\t\tcase 'INT8': return Math.max( v / 127.0, - 1.0 );\n\t\tcase 'INT16': return Math.max( v, 32767.0, - 1.0 );\n\t\tcase 'INT32': return Math.max( v / 2147483647.0, - 1.0 );\n\t\tcase 'INT64': return Math.max( Number( v ) / 9223372036854775807.0, - 1.0 ); // eslint-disable-line no-loss-of-precision\n\n\t\tcase 'UINT8': return v / 255.0;\n\t\tcase 'UINT16': return v / 65535.0;\n\t\tcase 'UINT32': return v / 4294967295.0;\n\t\tcase 'UINT64': return Number( v ) / 18446744073709551615.0; // eslint-disable-line no-loss-of-precision\n\n\t}\n\n}\n\n// scales the value based on property settings\n// the provided target value is normalized, scaled, and then offset if numeric\nexport function adjustValueScaleOffset( property, target ) {\n\n\tconst {\n\t\ttype,\n\t\tcomponentType,\n\t\tscale,\n\t\toffset,\n\t\tnormalized,\n\t} = property;\n\n\tif ( Array.isArray( target ) ) {\n\n\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\ttarget[ i ] = adjustFromType( target[ i ] );\n\n\t\t}\n\n\t} else {\n\n\t\ttarget = adjustFromType( target );\n\n\t}\n\n\treturn target;\n\n\tfunction adjustFromType( value ) {\n\n\t\tif ( isMatrixType( type ) ) {\n\n\t\t\tvalue = adjustMatrix( value );\n\n\t\t} else if ( isVectorType( type ) ) {\n\n\t\t\tvalue = adjustVector( value );\n\n\t\t} else {\n\n\t\t\tvalue = adjustScalar( value );\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\tfunction adjustVector( value ) {\n\n\t\tvalue.x = adjustScalar( value.x );\n\t\tvalue.y = adjustScalar( value.y );\n\t\tif ( 'z' in value ) value.z = adjustScalar( value.z );\n\t\tif ( 'w' in value ) value.w = adjustScalar( value.w );\n\t\treturn value;\n\n\t}\n\n\tfunction adjustMatrix( value ) {\n\n\t\tconst elements = value.elements;\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\telements[ i ] = adjustScalar( elements[ i ] );\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\tfunction adjustScalar( value ) {\n\n\t\tif ( normalized ) {\n\n\t\t\tvalue = normalizeValue( componentType, value );\n\n\t\t}\n\n\t\tif ( normalized || isFloatComponentType( componentType ) ) {\n\n\t\t\tvalue = value * scale + offset;\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n}\n\n// Shape the given target object based on the provided property. If overrideCount is\n// provided then it will be used to specify the array length.\nexport function initializeFromProperty( property, target, overrideCount = null ) {\n\n\tif ( property.array ) {\n\n\t\tif ( ! Array.isArray( target ) ) {\n\n\t\t\ttarget = new Array( property.count || 0 );\n\n\t\t}\n\n\t\ttarget.length = overrideCount !== null ? overrideCount : property.count;\n\n\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\tif ( ! isTypeInstance( property.type, target[ i ] ) ) {\n\n\t\t\t\ttarget[ i ] = getTypeInstance( property );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tif ( ! isTypeInstance( property.type, target ) ) {\n\n\t\t\ttarget = getTypeInstance( property );\n\n\t\t}\n\n\t}\n\n\treturn target;\n\n}\n\n// Shape the \"target\" object based on the provided set of properties\nexport function initializeFromClass( properties, target ) {\n\n\t// remove unused fields\n\tfor ( const key in target ) {\n\n\t\tif ( ! ( key in properties ) ) {\n\n\t\t\tdelete target[ key ];\n\n\t\t}\n\n\t}\n\n\t// add and adjust any fields required by the set of properties\n\tfor ( const key in properties ) {\n\n\t\tconst prop = properties[ key ];\n\t\ttarget[ key ] = initializeFromProperty( prop, target[ key ] );\n\n\t}\n\n}\n\n// Returns the number of components required for the given type\nexport function typeToComponentCount( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 'ENUM': return 1;\n\t\tcase 'SCALAR': return 1;\n\t\tcase 'VEC2': return 2;\n\t\tcase 'VEC3': return 3;\n\t\tcase 'VEC4': return 4;\n\t\tcase 'MAT2': return 4;\n\t\tcase 'MAT3': return 9;\n\t\tcase 'MAT4': return 16;\n\n\t\t// unused\n\t\tcase 'BOOLEAN': return - 1;\n\t\tcase 'STRING': return - 1;\n\t\tdefault: return - 1;\n\n\t}\n\n}\n","import {\n\tinitializeFromProperty,\n\tadjustValueScaleOffset,\n\tgetField,\n\tisNumericType,\n\tresolveDefaultElement,\n\tresolveNoData,\n\tresolveDefault,\n} from '../utilities/ClassPropertyHelpers.js';\n\nexport class ClassProperty {\n\n\tconstructor( enums, property, accessorProperty = null ) {\n\n\t\t// initialize defaults for class property info\n\t\tthis.name = property.name || null;\n\t\tthis.description = property.description || null;\n\t\tthis.type = property.type;\n\t\tthis.componentType = property.componentType || null;\n\t\tthis.enumType = property.enumType || null;\n\t\tthis.array = property.array || false;\n\t\tthis.count = property.count || 0;\n\t\tthis.normalized = property.normalized || false;\n\t\tthis.offset = property.offset || 0;\n\t\tthis.scale = getField( property, 'scale', 1 );\n\t\tthis.max = getField( property, 'max', Infinity );\n\t\tthis.min = getField( property, 'min', - Infinity );\n\t\tthis.required = property.required || false;\n\t\tthis.noData = getField( property, 'noData', null );\n\t\tthis.default = getField( property, 'default', null );\n\t\tthis.semantic = getField( property, 'semantic', null );\n\t\tthis.enumSet = null;\n\t\tthis.accessorProperty = accessorProperty;\n\n\t\t// accessor properties can override min, max, offset, and scale values\n\t\tif ( accessorProperty ) {\n\n\t\t\tthis.offset = getField( accessorProperty, 'offset', this.offset );\n\t\t\tthis.scale = getField( accessorProperty, 'scale', this.scale );\n\t\t\tthis.max = getField( accessorProperty, 'max', this.max );\n\t\t\tthis.min = getField( accessorProperty, 'min', this.min );\n\n\t\t}\n\n\t\t// get the component type for the provided enum\n\t\tif ( property.type === 'ENUM' ) {\n\n\t\t\tthis.enumSet = enums[ this.enumType ];\n\t\t\tif ( this.componentType === null ) {\n\n\t\t\t\tthis.componentType = getField( this.enumSet, 'valueType', 'UINT16' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// shape the given target to match the data type of the property\n\t// enums are set to their integer value\n\tshapeToProperty( target, countOverride = null ) {\n\n\t\treturn initializeFromProperty( this, target, countOverride );\n\n\t}\n\n\t// resolve the given object to the default value for the property for a single element\n\t// enums are set to a default string\n\tresolveDefaultElement( target ) {\n\n\t\treturn resolveDefaultElement( this, target );\n\n\t}\n\n\t// resolve the target to the default value for the property for every element if it's an array\n\t// enums are set to a default string\n\tresolveDefault( target ) {\n\n\t\treturn resolveDefault( this, target );\n\n\t}\n\n\t// converts any instances of no data to the default value\n\tresolveNoData( target ) {\n\n\t\treturn resolveNoData( this, target );\n\n\t}\n\n\t// converts enums integers in the given target to strings\n\tresolveEnumsToStrings( target ) {\n\n\t\tconst enumSet = this.enumSet;\n\t\tif ( this.type === 'ENUM' ) {\n\n\t\t\tif ( Array.isArray( target ) ) {\n\n\t\t\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\t\t\ttarget[ i ] = getEnumName( target[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttarget = getEnumName( target );\n\n\t\t\t}\n\n\n\t\t}\n\n\t\treturn target;\n\n\t\tfunction getEnumName( index ) {\n\n\t\t\tconst match = enumSet.values.find( e => e.value === index );\n\t\t\tif ( match === null ) {\n\n\t\t\t\t// the default \"default enum\" value is an empty string when we can't find a match\n\t\t\t\t// in a case where enums are defined correctly we should never get here.\n\t\t\t\treturn '';\n\n\t\t\t} else {\n\n\t\t\t\treturn match.name;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// apply scales\n\tadjustValueScaleOffset( target ) {\n\n\t\tif ( isNumericType( this.type ) ) {\n\n\t\t\treturn adjustValueScaleOffset( this, target );\n\n\t\t} else {\n\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n}\n","import { ClassProperty } from './ClassProperty.js';\n\nexport class PropertySetAccessor {\n\n\tconstructor( definition, classes = {}, enums = {}, data = null ) {\n\n\t\tthis.definition = definition;\n\t\tthis.class = classes[ definition.class ];\n\t\tthis.className = definition.class;\n\t\tthis.enums = enums;\n\t\tthis.data = data;\n\t\tthis.name = 'name' in definition ? definition.name : null;\n\n\t\tthis.properties = null;\n\n\t}\n\n\tgetPropertyNames() {\n\n\t\treturn Object.keys( this.class.properties );\n\n\t}\n\n\tincludesData( name ) {\n\n\t\treturn Boolean( this.definition.properties[ name ] );\n\n\t}\n\n\tdispose() {}\n\n\t_initProperties( propertyClass = ClassProperty ) {\n\n\t\tconst properties = {};\n\t\tfor ( const key in this.class.properties ) {\n\n\t\t\tproperties[ key ] = new propertyClass( this.enums, this.class.properties[ key ], this.definition.properties[ key ] );\n\n\t\t}\n\n\t\tthis.properties = properties;\n\n\t}\n\n}\n","import { initializeFromClass, isMatrixType, isVectorType } from '../utilities/ClassPropertyHelpers.js';\nimport { ClassProperty } from './ClassProperty.js';\nimport { PropertySetAccessor } from './PropertySetAccessor.js';\n\nclass PropertyAttributeClassProperty extends ClassProperty {\n\n\tconstructor( enums, classProperty, attributeProperty = null ) {\n\n\t\tsuper( enums, classProperty, attributeProperty );\n\n\t\tthis.attribute = attributeProperty?.attribute ?? null;\n\n\t}\n\n}\n\nexport class PropertyAttributeAccessor extends PropertySetAccessor {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isPropertyAttributeAccessor = true;\n\t\tthis._initProperties( PropertyAttributeClassProperty );\n\n\t}\n\n\tgetData( id, geometry, target = {} ) {\n\n\t\tconst properties = this.properties;\n\t\tinitializeFromClass( properties, target );\n\n\t\tfor ( const name in properties ) {\n\n\t\t\ttarget[ name ] = this.getPropertyValue( name, id, geometry, target[ name ] );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetPropertyValue( name, id, geometry, target = null ) {\n\n\t\t// NOTE: arrays are not supported via attribute accessors\n\t\tif ( id >= this.count ) {\n\n\t\t\tthrow new Error( 'PropertyAttributeAccessor: Requested index is outside the range of the buffer.' );\n\n\t\t}\n\n\t\t// use a default of the texture accessor definition does not include the value\n\t\tconst property = this.properties[ name ];\n\t\tconst type = property.type;\n\t\tif ( ! property ) {\n\n\t\t\tthrow new Error( 'PropertyAttributeAccessor: Requested class property does not exist.' );\n\n\t\t} else if ( ! this.definition.properties[ name ] ) {\n\n\t\t\treturn property.resolveDefault( target );\n\n\t\t}\n\n\t\t// initialize the array\n\t\ttarget = property.shapeToProperty( target );\n\n\t\t// Read the data values from the attribute\n\t\tconst attribute = geometry.getAttribute( property.attribute.toLowerCase() );\n\t\tif ( isMatrixType( type ) ) {\n\n\t\t\tconst elements = target.elements;\n\t\t\tfor ( let i = 0, l = elements.length; i < l; i < l ) {\n\n\t\t\t\telements[ i ] = attribute.getComponent( id, i );\n\n\t\t\t}\n\n\t\t} else if ( isVectorType( type ) ) {\n\n\t\t\ttarget.fromBufferAttribute( attribute, id );\n\n\t\t} else if ( type === 'SCALAR' || type === 'ENUM' ) {\n\n\t\t\ttarget = attribute.getX( id );\n\n\t\t} else {\n\n\t\t\t// BOOLEAN, STRING not supported\n\t\t\tthrow new Error( 'StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.' );\n\n\t\t}\n\n\t\t// scale the numeric values\n\t\ttarget = property.adjustValueScaleOffset( target );\n\n\t\t// convert to enum strings - no data enum values are stored as strings\n\t\ttarget = property.resolveEnumsToStrings( target );\n\n\t\t// resolve to default values\n\t\ttarget = property.resolveNoData( target );\n\n\t\treturn target;\n\n\t}\n\n}\n","import { ClassProperty } from './ClassProperty.js';\nimport { PropertySetAccessor } from './PropertySetAccessor.js';\nimport {\n\tinitializeFromClass,\n\tgetArrayConstructorFromComponentType,\n\treadDataFromBufferToType,\n\tgetField,\n\tisNumericType,\n\ttypeToComponentCount,\n} from '../utilities/ClassPropertyHelpers.js';\n\nclass PropertyTableClassProperty extends ClassProperty {\n\n\tconstructor( enums, classProperty, tableProperty = null ) {\n\n\t\tsuper( enums, classProperty, tableProperty );\n\n\t\tthis.values = tableProperty?.values ?? null;\n\t\tthis.valueLength = typeToComponentCount( this.type );\n\t\tthis.arrayOffsets = getField( tableProperty, 'arrayOffsets', null );\n\t\tthis.stringOffsets = getField( tableProperty, 'stringOffsets', null );\n\t\tthis.arrayOffsetType = getField( tableProperty, 'arrayOffsetType', 'UINT32' );\n\t\tthis.stringOffsetType = getField( tableProperty, 'stringOffsetType', 'UINT32' );\n\n\t}\n\n\t// returns the necessary array length based on the array offsets if present\n\tgetArrayLengthFromId( buffers, id ) {\n\n\t\tlet count = this.count;\n\t\tif ( this.arrayOffsets !== null ) {\n\n\t\t\tconst { arrayOffsets, arrayOffsetType } = this;\n\t\t\tconst bufferCons = getArrayConstructorFromComponentType( arrayOffsetType );\n\t\t\tconst arr = new bufferCons( buffers[ arrayOffsets ] );\n\t\t\tcount = arr[ id + 1 ] - arr[ id ];\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// returns the index offset into the data buffer for the given id based on the\n\t// the array offsets if present\n\tgetIndexOffsetFromId( buffers, id ) {\n\n\t\tlet indexOffset = id;\n\t\tif ( this.arrayOffsets ) {\n\n\t\t\tconst { arrayOffsets, arrayOffsetType } = this;\n\t\t\tconst bufferCons = getArrayConstructorFromComponentType( arrayOffsetType );\n\t\t\tconst arr = new bufferCons( buffers[ arrayOffsets ] );\n\t\t\tindexOffset = arr[ indexOffset ];\n\n\t\t} else if ( this.array ) {\n\n\t\t\t// TODO: why do this? Revisit\n\t\t\tindexOffset *= this.count;\n\n\t\t}\n\n\t\treturn indexOffset;\n\n\t}\n\n}\n\nexport class PropertyTableAccessor extends PropertySetAccessor {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isPropertyTableAccessor = true;\n\t\tthis.count = this.definition.count;\n\n\t\tthis._initProperties( PropertyTableClassProperty );\n\n\t}\n\n\tgetData( id, target = {} ) {\n\n\t\tconst properties = this.properties;\n\t\tinitializeFromClass( properties, target );\n\n\t\tfor ( const name in properties ) {\n\n\t\t\ttarget[ name ] = this.getPropertyValue( name, id, target[ name ] );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// reads an individual element\n\t_readValueAtIndex( name, id, index, target = null ) {\n\n\t\tconst property = this.properties[ name ];\n\t\tconst { componentType, type } = property;\n\n\t\tconst buffers = this.data;\n\t\tconst bufferView = buffers[ property.values ];\n\t\tconst bufferCons = getArrayConstructorFromComponentType( componentType, type );\n\t\tconst dataArray = new bufferCons( bufferView );\n\n\t\t// array offsets contain element offsets, not byte offsets\n\t\tconst indexOffset = property.getIndexOffsetFromId( buffers, id );\n\n\t\tif ( isNumericType( type ) || type === 'ENUM' ) {\n\n\t\t\t// \"readDataFromBufferToType\" takes the start offset to read from so we multiply the\n\t\t\t// index by the final value length\n\t\t\treturn readDataFromBufferToType( dataArray, ( indexOffset + index ) * property.valueLength, type, target );\n\n\t\t} else if ( type === 'STRING' ) {\n\n\t\t\t// https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata/#variable-length-arrays\n\n\t\t\tlet stringIndex = indexOffset + index;\n\t\t\tlet stringLength = 0;\n\t\t\tif ( property.stringOffsets !== null ) {\n\n\t\t\t\t// get the string lengths and beginning offsets if variable\n\t\t\t\tconst { stringOffsets, stringOffsetType } = property;\n\t\t\t\tconst bufferCons = getArrayConstructorFromComponentType( stringOffsetType );\n\t\t\t\tconst stringOffsetBuffer = new bufferCons( buffers[ stringOffsets ] );\n\t\t\t\tstringLength = stringOffsetBuffer[ stringIndex + 1 ] - stringOffsetBuffer[ stringIndex ];\n\t\t\t\tstringIndex = stringOffsetBuffer[ stringIndex ];\n\n\t\t\t}\n\n\t\t\tconst byteArray = new Uint8Array( dataArray.buffer, stringIndex, stringLength );\n\t\t\ttarget = new TextDecoder().decode( byteArray );\n\n\t\t} else if ( type === 'BOOLEAN' ) {\n\n\t\t\tconst offset = indexOffset + index;\n\t\t\tconst byteIndex = Math.floor( offset / 8 );\n\t\t\tconst bitIndex = offset % 8;\n\t\t\tconst bitValue = ( dataArray[ byteIndex ] >> bitIndex ) & 1;\n\t\t\ttarget = bitValue === 1;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// Reads the data for the given table index\n\tgetPropertyValue( name, id, target = null ) {\n\n\t\t// check if the requested id is outside of the size of the table\n\t\tif ( id >= this.count ) {\n\n\t\t\tthrow new Error( 'PropertyTableAccessor: Requested index is outside the range of the table.' );\n\n\t\t}\n\n\t\t// check to see if we skip this field since its not in the table\n\t\tconst property = this.properties[ name ];\n\t\tif ( ! property ) {\n\n\t\t\tthrow new Error( 'PropertyTableAccessor: Requested property does not exist.' );\n\n\t\t} else if ( ! this.definition.properties[ name ] ) {\n\n\t\t\treturn property.resolveDefault( target );\n\n\t\t}\n\n\t\t// get the dynamic array count from the property buffer\n\t\tconst array = property.array;\n\t\tconst buffers = this.data;\n\t\tconst count = property.getArrayLengthFromId( buffers, id );\n\n\t\t// initialize the array\n\t\ttarget = property.shapeToProperty( target, count );\n\n\t\t// read all data\n\t\tif ( array ) {\n\n\t\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\t\ttarget[ i ] = this._readValueAtIndex( name, id, i, target[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttarget = this._readValueAtIndex( name, id, 0, target );\n\n\t\t}\n\n\t\t// scale the numeric values\n\t\ttarget = property.adjustValueScaleOffset( target );\n\n\t\t// convert to enum strings - no data enum values are stored as strings\n\t\ttarget = property.resolveEnumsToStrings( target );\n\n\t\t// resolve to default values\n\t\ttarget = property.resolveNoData( target );\n\n\t\treturn target;\n\n\t}\n\n}\n","import { WebGLRenderTarget, WebGLRenderer, Box2, Vector2, ShaderMaterial, CustomBlending, ZeroFactor, OneFactor } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\n\nconst _box = /* @__PURE__ */ new Box2();\n\n// Utility for reading sets of individual pixel values from textures\nclass _TextureReadUtility {\n\n\tconstructor() {\n\n\t\tthis._renderer = new WebGLRenderer();\n\t\tthis._target = new WebGLRenderTarget( 1, 1 );\n\t\tthis._texTarget = new WebGLRenderTarget();\n\n\t\t// quad to render just a single pixel from the provided texture\n\t\tthis._quad = new FullScreenQuad( new ShaderMaterial( {\n\n\t\t\tblending: CustomBlending,\n\t\t\tblendDst: ZeroFactor,\n\t\t\tblendSrc: OneFactor,\n\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: null },\n\t\t\t\tpixel: { value: new Vector2() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform ivec2 pixel;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texelFetch( map, pixel, 0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} ) );\n\n\t}\n\n\t// increases the width of the target render target to support more data\n\tincreaseSizeTo( width ) {\n\n\t\tthis._target.setSize( Math.max( this._target.width, width ), 1 );\n\n\t}\n\n\t// read data from the rendered texture asynchronously\n\treadDataAsync( buffer ) {\n\n\t\tconst { _renderer, _target } = this;\n\t\treturn _renderer.readRenderTargetPixelsAsync( _target, 0, 0, buffer.length / 4, 1, buffer );\n\n\t}\n\n\t// read data from the rendered texture\n\treadData( buffer ) {\n\n\t\tconst { _renderer, _target } = this;\n\t\t_renderer.readRenderTargetPixels( _target, 0, 0, buffer.length / 4, 1, buffer );\n\n\t}\n\n\t// render a single pixel from the source at the destination point on the render target\n\t// takes the texture, pixel to read from, and pixel to render in to\n\trenderPixelToTarget( texture, pixel, dstPixel ) {\n\n\t\tconst { _renderer, _target } = this;\n\n\t\t// copies the pixel directly to the target buffer\n\t\t_box.min.copy( pixel );\n\t\t_box.max.copy( pixel );\n\t\t_box.max.x += 1;\n\t\t_box.max.y += 1;\n\t\t_renderer.initRenderTarget( _target );\n\t\t_renderer.copyTextureToTexture( texture, _target.texture, _box, dstPixel, 0 );\n\n\t}\n\n}\n\n// Create a wrapper class to defer instantiation of the WebGLRenderer until it's needed\n// See NASA-AMMOS/3DTilesRendererJS#905\nexport const TextureReadUtility = /* @__PURE__ */ new ( class {\n\n\tconstructor() {\n\n\t\tlet reader = null;\n\t\tObject\n\t\t\t.getOwnPropertyNames( _TextureReadUtility.prototype )\n\t\t\t.forEach( key => {\n\n\t\t\t\tif ( key !== 'constructor' ) {\n\n\t\t\t\t\tthis[ key ] = ( ...args ) => {\n\n\t\t\t\t\t\treader = reader || new _TextureReadUtility();\n\t\t\t\t\t\treturn reader[ key ]( ...args );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t}\n\n} )();\n","import { Vector2 } from 'three';\n\nconst _uv0 = /* @__PURE__ */ new Vector2();\nconst _uv1 = /* @__PURE__ */ new Vector2();\nconst _uv2 = /* @__PURE__ */ new Vector2();\n\n// returns the uv attribute of the given index\nexport function getTextureCoordAttribute( geometry, index ) {\n\n\tif ( index === 0 ) {\n\n\t\treturn geometry.getAttribute( 'uv' );\n\n\t} else {\n\n\t\treturn geometry.getAttribute( `uv${ index }` );\n\n\t}\n\n}\n\n// returns the vertex indices associated with the triangle index\nexport function getTriangleVertexIndices( geometry, faceIndex, target = new Array( 3 ) ) {\n\n\t// get the attribute indices\n\tlet i0 = 3 * faceIndex;\n\tlet i1 = 3 * faceIndex + 1;\n\tlet i2 = 3 * faceIndex + 2;\n\tif ( geometry.index ) {\n\n\t\ti0 = geometry.index.getX( i0 );\n\t\ti1 = geometry.index.getX( i1 );\n\t\ti2 = geometry.index.getX( i2 );\n\n\t}\n\n\ttarget[ 0 ] = i0;\n\ttarget[ 1 ] = i1;\n\ttarget[ 2 ] = i2;\n\treturn target;\n\n}\n\n// takes a tex coord index, barycoord, vertex indices, and target to set\n// sets target to the interpolated uv value\nexport function getTexCoord( geometry, texCoord, barycoord, indices, target ) {\n\n\tconst [ i0, i1, i2 ] = indices;\n\tconst attr = getTextureCoordAttribute( geometry, texCoord );\n\t_uv0.fromBufferAttribute( attr, i0 );\n\t_uv1.fromBufferAttribute( attr, i1 );\n\t_uv2.fromBufferAttribute( attr, i2 );\n\n\ttarget\n\t\t.set( 0, 0, 0 )\n\t\t.addScaledVector( _uv0, barycoord.x )\n\t\t.addScaledVector( _uv1, barycoord.y )\n\t\t.addScaledVector( _uv2, barycoord.z );\n\n}\n\n// gets the x, y index of the pixel at the given uv coordinate\nexport function getTexelIndices( uv, width, height, target ) {\n\n\tconst fx = uv.x - Math.floor( uv.x );\n\tconst fy = uv.y - Math.floor( uv.y );\n\tconst px = Math.floor( ( fx * width ) % width );\n\tconst py = Math.floor( ( fy * height ) % height );\n\ttarget.set( px, py );\n\treturn target;\n\n}\n","import { Vector2 } from 'three';\nimport { PropertySetAccessor } from './PropertySetAccessor.js';\nimport { ClassProperty } from './ClassProperty.js';\nimport { TextureReadUtility } from '../utilities/TextureReadUtility.js';\nimport { getTexCoord, getTexelIndices, getTriangleVertexIndices } from '../utilities/TexCoordUtilities.js';\nimport {\n\tinitializeFromClass,\n\tinitializeFromProperty,\n\tgetArrayConstructorFromComponentType,\n\treadDataFromBufferToType,\n\tgetField\n} from '../utilities/ClassPropertyHelpers.js';\n\nconst _uv = /* @__PURE__ */ new Vector2();\nconst _srcPixel = /* @__PURE__ */ new Vector2();\nconst _dstPixel = /* @__PURE__ */ new Vector2();\n\nclass PropertyTextureClassProperty extends ClassProperty {\n\n\tconstructor( enums, classProperty, textureProperty = null ) {\n\n\t\tsuper( enums, classProperty, textureProperty );\n\n\t\tthis.channels = getField( textureProperty, 'channels', [ 0 ] );\n\t\tthis.index = getField( textureProperty, 'index', null );\n\t\tthis.texCoord = getField( textureProperty, 'texCoord', null );\n\t\tthis.valueLength = parseInt( this.type.replace( /[^0-9]/g, '' ) ) || 1;\n\n\t}\n\n\t// takes the buffer to read from and the value index to read\n\treadDataFromBuffer( buffer, index, target = null ) {\n\n\t\tconst type = this.type;\n\t\tif ( type === 'BOOLEAN' || type === 'STRING' ) {\n\n\t\t\tthrow new Error( 'PropertyTextureAccessor: BOOLEAN and STRING types not supported.' );\n\n\t\t}\n\n\t\t// \"readDataFromBufferToType\" takes the start offset to read from so we multiply the index by the\n\t\t// final value length\n\t\treturn readDataFromBufferToType( buffer, index * this.valueLength, type, target );\n\n\t}\n\n}\n\n// Reads and accesses data encoded to textures\nexport class PropertyTextureAccessor extends PropertySetAccessor {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isPropertyTextureAccessor = true;\n\t\tthis._asyncRead = false;\n\n\t\tthis._initProperties( PropertyTextureClassProperty );\n\n\t}\n\n\t// Reads the full set of property data\n\tgetData( faceIndex, barycoord, geometry, target = {} ) {\n\n\t\tconst properties = this.properties;\n\t\tinitializeFromClass( properties, target );\n\n\t\tconst names = Object.keys( properties );\n\t\tconst results = names.map( n => target[ n ] );\n\t\tthis.getPropertyValuesAtTexel( names, faceIndex, barycoord, geometry, results );\n\n\t\tnames.forEach( ( n, i ) => target[ n ] = results[ i ] );\n\t\treturn target;\n\n\t}\n\n\t// Reads the full set of property data asynchronously\n\tasync getDataAsync( faceIndex, barycoord, geometry, target = {} ) {\n\n\t\tconst properties = this.properties;\n\t\tinitializeFromClass( properties, target );\n\n\t\tconst names = Object.keys( properties );\n\t\tconst results = names.map( n => target[ n ] );\n\t\tawait this.getPropertyValuesAtTexelAsync( names, faceIndex, barycoord, geometry, results );\n\n\t\tnames.forEach( ( n, i ) => target[ n ] = results[ i ] );\n\t\treturn target;\n\n\t}\n\n\t// Reads values asynchronously\n\tgetPropertyValuesAtTexelAsync( ...args ) {\n\n\t\tthis._asyncRead = true;\n\t\tconst result = this.getPropertyValuesAtTexel( ...args );\n\t\tthis._asyncRead = false;\n\t\treturn result;\n\n\t}\n\n\t// Reads values from the textures synchronously\n\tgetPropertyValuesAtTexel( names, faceIndex, barycoord, geometry, target = [] ) {\n\n\t\t// resize our targets appropriately\n\t\twhile ( target.length < names.length ) target.push( null );\n\t\ttarget.length = names.length;\n\t\tTextureReadUtility.increaseSizeTo( target.length );\n\n\t\t// get the attribute indices\n\t\tconst textures = this.data;\n\t\tconst accessorProperties = this.definition.properties;\n\t\tconst properties = this.properties;\n\t\tconst indices = getTriangleVertexIndices( geometry, faceIndex );\n\t\tfor ( let i = 0, l = names.length; i < l; i ++ ) {\n\n\t\t\t// skip any requested class schema properties that are not provided via the accessor\n\t\t\tconst name = names[ i ];\n\t\t\tif ( ! accessorProperties[ name ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// get the attribute of the target tex coord\n\t\t\tconst property = properties[ name ];\n\t\t\tconst texture = textures[ property.index ];\n\t\t\tgetTexCoord( geometry, property.texCoord, barycoord, indices, _uv );\n\t\t\tgetTexelIndices( _uv, texture.image.width, texture.image.height, _srcPixel );\n\t\t\t_dstPixel.set( i, 0 );\n\n\t\t\tTextureReadUtility.renderPixelToTarget( texture, _srcPixel, _dstPixel );\n\n\t\t}\n\n\t\t// read the data\n\t\tconst buffer = new Uint8Array( names.length * 4 );\n\t\tif ( this._asyncRead ) {\n\n\t\t\treturn TextureReadUtility\n\t\t\t\t.readDataAsync( buffer )\n\t\t\t\t.then( () => {\n\n\t\t\t\t\treadTextureSampleResults.call( this );\n\t\t\t\t\treturn target;\n\n\t\t\t\t} );\n\n\t\t} else {\n\n\t\t\tTextureReadUtility.readData( buffer );\n\t\t\treadTextureSampleResults.call( this );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction readTextureSampleResults() {\n\n\t\t\tfor ( let i = 0, l = names.length; i < l; i ++ ) {\n\n\t\t\t\tconst name = names[ i ];\n\t\t\t\tconst property = properties[ name ];\n\t\t\t\tconst type = property.type;\n\n\t\t\t\t// initialize the output value\n\t\t\t\ttarget[ i ] = initializeFromProperty( property, target[ i ] );\n\n\t\t\t\t// use a default of the texture accessor definition does not include the value\n\t\t\t\tif ( ! property ) {\n\n\t\t\t\t\tthrow new Error( 'PropertyTextureAccessor: Requested property does not exist.' );\n\n\t\t\t\t} else if ( ! accessorProperties[ name ] ) {\n\n\t\t\t\t\ttarget[ i ] = property.resolveDefault( target );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// get the final array length to read all data based on used buffer data\n\t\t\t\tconst length = property.valueLength * ( property.count || 1 );\n\n\t\t\t\t// set the data read back from the texture to the target type\n\t\t\t\tconst data = property.channels.map( c => buffer[ 4 * i + c ] );\n\t\t\t\tconst componentType = property.componentType;\n\t\t\t\tconst BufferCons = getArrayConstructorFromComponentType( componentType, type );\n\t\t\t\tconst readBuffer = new BufferCons( length );\n\t\t\t\tnew Uint8Array( readBuffer.buffer ).set( data );\n\n\t\t\t\t// read all the data\n\t\t\t\tif ( property.array ) {\n\n\t\t\t\t\tconst arr = target[ i ];\n\t\t\t\t\tfor ( let j = 0, lj = arr.length; j < lj; j ++ ) {\n\n\t\t\t\t\t\tarr[ j ] = property.readDataFromBuffer( readBuffer, j, arr[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget[ i ] = property.readDataFromBuffer( readBuffer, 0, target[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t// scale the numeric values\n\t\t\t\ttarget[ i ] = property.adjustValueScaleOffset( target[ i ] );\n\n\t\t\t\t// convert to enum strings - no data enum values are stored as strings\n\t\t\t\ttarget[ i ] = property.resolveEnumsToStrings( target[ i ] );\n\n\t\t\t\t// resolve to default values\n\t\t\t\ttarget[ i ] = property.resolveNoData( target[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// dispose all of the texture data used\n\tdispose() {\n\n\t\tthis.data.forEach( texture => {\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import { PropertyAttributeAccessor } from './PropertyAttributeAccessor.js';\nimport { PropertyTableAccessor } from './PropertyTableAccessor.js';\nimport { PropertyTextureAccessor } from './PropertyTextureAccessor.js';\n\nexport class StructuralMetadata {\n\n\tconstructor( definition, textures, buffers, nodeMetadata = null, object = null ) {\n\n\t\tconst {\n\t\t\tschema,\n\t\t\tpropertyTables = [],\n\t\t\tpropertyTextures = [],\n\t\t\tpropertyAttributes = [],\n\t\t} = definition;\n\n\t\tconst { enums, classes } = schema;\n\t\tconst tableAccessors = propertyTables.map( t => new PropertyTableAccessor( t, classes, enums, buffers ) );\n\t\tlet textureAccessors = [];\n\t\tlet attributeAccessors = [];\n\n\t\tif ( nodeMetadata ) {\n\n\t\t\tif ( nodeMetadata.propertyTextures ) {\n\n\t\t\t\ttextureAccessors = nodeMetadata.propertyTextures.map( i => new PropertyTextureAccessor( propertyTextures[ i ], classes, enums, textures ) );\n\n\t\t\t}\n\n\t\t\tif ( nodeMetadata.propertyAttributes ) {\n\n\t\t\t\tattributeAccessors = nodeMetadata.propertyAttributes.map( i => new PropertyAttributeAccessor( propertyAttributes[ i ], classes, enums ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.schema = schema;\n\t\tthis.tableAccessors = tableAccessors;\n\t\tthis.textureAccessors = textureAccessors;\n\t\tthis.attributeAccessors = attributeAccessors;\n\t\tthis.object = object;\n\t\tthis.textures = textures;\n\t\tthis.nodeMetadata = nodeMetadata;\n\n\t}\n\n\t// Property Tables\n\tgetPropertyTableData( tableIndices, ids, target = null ) {\n\n\t\tif ( ! Array.isArray( tableIndices ) || ! Array.isArray( ids ) ) {\n\n\t\t\t// only return a single tables data\n\t\t\ttarget = target || {};\n\n\t\t\tconst table = this.tableAccessors[ tableIndices ];\n\t\t\ttarget = table.getData( ids, target );\n\n\t\t} else {\n\n\t\t\t// return data from an array of tables and ids\n\t\t\ttarget = target || [];\n\n\t\t\tconst length = Math.min( tableIndices.length, ids.length );\n\t\t\ttarget.length = length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst table = this.tableAccessors[ tableIndices[ i ] ];\n\t\t\t\ttarget[ i ] = table.getData( ids[ i ], target[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetPropertyTableInfo( tableIndices = null ) {\n\n\t\t// default to all table information\n\t\tif ( tableIndices === null ) {\n\n\t\t\ttableIndices = this.tableAccessors.map( ( t, i ) => i );\n\n\t\t}\n\n\t\tif ( Array.isArray( tableIndices ) ) {\n\n\t\t\t// return all table information from the requested list\n\t\t\treturn tableIndices.map( i => {\n\n\t\t\t\tconst table = this.tableAccessors[ i ];\n\t\t\t\treturn {\n\t\t\t\t\tname: table.name,\n\t\t\t\t\tclassName: table.definition.class,\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\t// return the one piece of table information\n\t\t\tconst table = this.tableAccessors[ tableIndices ];\n\t\t\treturn {\n\t\t\t\tname: table.name,\n\t\t\t\tclassName: table.definition.class,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t// Property Textures\n\tgetPropertyTextureData( triangle, barycoord, target = [] ) {\n\n\t\tconst textureAccessors = this.textureAccessors;\n\t\ttarget.length = textureAccessors.length;\n\n\t\tfor ( let i = 0; i < textureAccessors.length; i ++ ) {\n\n\t\t\tconst accessor = textureAccessors[ i ];\n\t\t\ttarget[ i ] = accessor.getData( triangle, barycoord, this.object.geometry, target[ i ] );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tasync getPropertyTextureDataAsync( triangle, barycoord, target = [] ) {\n\n\t\tconst textureAccessors = this.textureAccessors;\n\t\ttarget.length = textureAccessors.length;\n\n\t\tconst promises = [];\n\t\tfor ( let i = 0; i < textureAccessors.length; i ++ ) {\n\n\t\t\tconst accessor = textureAccessors[ i ];\n\t\t\tconst promise = accessor\n\t\t\t\t.getDataAsync( triangle, barycoord, this.object.geometry, target[ i ] )\n\t\t\t\t.then( result => {\n\n\t\t\t\t\ttarget[ i ] = result;\n\n\t\t\t\t} );\n\n\t\t\tpromises.push( promise );\n\n\t\t}\n\n\t\tawait Promise.all( promises );\n\n\t\treturn target;\n\n\t}\n\n\tgetPropertyTextureInfo() {\n\n\t\treturn this.textureAccessors;\n\n\t}\n\n\t// Property Attributes\n\tgetPropertyAttributeData( attributeIndex, target = [] ) {\n\n\t\tconst attributeAccessors = this.attributeAccessors;\n\t\ttarget.length = attributeAccessors.length;\n\n\t\tfor ( let i = 0; i < attributeAccessors.length; i ++ ) {\n\n\t\t\tconst accessor = attributeAccessors[ i ];\n\t\t\ttarget[ i ] = accessor.getData( attributeIndex, this.object.geometry, target[ i ] );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetPropertyAttributeInfo() {\n\n\t\treturn this.attributeAccessors.map( acc => {\n\n\t\t\treturn {\n\t\t\t\tname: acc.name,\n\t\t\t\tclassName: acc.definition.class,\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.textureAccessors.forEach( acc => acc.dispose() );\n\t\tthis.tableAccessors.forEach( acc => acc.dispose() );\n\t\tthis.attributeAccessors.forEach( acc => acc.dispose() );\n\n\t}\n\n}\n","// https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata\n\nimport { FileLoader } from 'three';\nimport { StructuralMetadata } from './metadata/classes/StructuralMetadata.js';\n\nconst EXT_NAME = 'EXT_structural_metadata';\n\n// returns the set of textures required by the property texture definitions\nfunction getRelevantTextures( parser, propertyTextures = [] ) {\n\n\tconst textureCount = parser.json.textures?.length || 0;\n\tconst result = new Array( textureCount ).fill( null );\n\n\tpropertyTextures.forEach( ( { properties } ) => {\n\n\t\tfor ( const key in properties ) {\n\n\t\t\tconst { index } = properties[ key ];\n\t\t\tif ( result[ index ] === null ) {\n\n\t\t\t\tresult[ index ] = parser.loadTexture( index );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn Promise.all( result );\n\n}\n\n// returns the set of buffers required by the property table definitions\nfunction getRelevantBuffers( parser, propertyTables = [] ) {\n\n\tconst textureCount = parser.json.bufferViews?.length || 0;\n\tconst result = new Array( textureCount ).fill( null );\n\n\tpropertyTables.forEach( ( { properties } ) => {\n\n\t\tfor ( const key in properties ) {\n\n\t\t\tconst { values, arrayOffsets, stringOffsets } = properties[ key ];\n\t\t\tif ( result[ values ] === null ) {\n\n\t\t\t\tresult[ values ] = parser.loadBufferView( values );\n\n\t\t\t}\n\n\t\t\tif ( result[ arrayOffsets ] === null ) {\n\n\t\t\t\tresult[ arrayOffsets ] = parser.loadBufferView( arrayOffsets );\n\n\t\t\t}\n\n\t\t\tif ( result[ stringOffsets ] === null ) {\n\n\t\t\t\tresult[ stringOffsets ] = parser.loadBufferView( stringOffsets );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn Promise.all( result );\n\n}\n\nexport class GLTFStructuralMetadataExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXT_NAME;\n\n\t}\n\n\tasync afterRoot( { scene, parser } ) {\n\n\t\t// skip if the extension is not present\n\t\tconst extensionsUsed = parser.json.extensionsUsed;\n\t\tif ( ! extensionsUsed || ! extensionsUsed.includes( EXT_NAME ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// load the remote schema definition if present\n\t\tlet schemaPromise = null;\n\t\tlet rootExtension = parser.json.extensions[ EXT_NAME ];\n\t\tif ( rootExtension.schemaUri ) {\n\n\t\t\t// TODO: cache the loaded schema so we can share it and dispose of it when the\n\t\t\t// extension is no longer available\n\t\t\tconst { manager, path, requestHeader, crossOrigin } = parser.options;\n\t\t\tconst finalUri = new URL( rootExtension.schemaUri, path ).toString();\n\t\t\tconst fileLoader = new FileLoader( manager );\n\t\t\tfileLoader.setCrossOrigin( crossOrigin );\n\t\t\tfileLoader.setResponseType( 'json' );\n\t\t\tfileLoader.setRequestHeader( requestHeader );\n\n\t\t\tschemaPromise = fileLoader.loadAsync( finalUri )\n\t\t\t\t.then( schema => {\n\n\t\t\t\t\trootExtension = { ...rootExtension, schema };\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\t// prep the textures and buffers\n\t\tconst [ textures, buffers ] = await Promise.all( [\n\t\t\tgetRelevantTextures( parser, rootExtension.propertyTextures ),\n\t\t\tgetRelevantBuffers( parser, rootExtension.propertyTables ),\n\t\t\tschemaPromise,\n\t\t] );\n\n\t\t// initialize the extension\n\t\tconst rootMetadata = new StructuralMetadata( rootExtension, textures, buffers );\n\t\tscene.userData.structuralMetadata = rootMetadata;\n\n\t\tscene.traverse( child => {\n\n\t\t\tif ( parser.associations.has( child ) ) {\n\n\t\t\t\t// check if this object has extension references and use a child-specific version of the extension\n\t\t\t\tconst { meshes, primitives } = parser.associations.get( child );\n\t\t\t\tconst primitive = parser.json.meshes[ meshes ]?.primitives[ primitives ];\n\t\t\t\tif ( primitive && primitive.extensions && primitive.extensions[ EXT_NAME ] ) {\n\n\t\t\t\t\tconst extension = primitive.extensions[ EXT_NAME ];\n\t\t\t\t\tchild.userData.structuralMetadata = new StructuralMetadata( rootExtension, textures, buffers, extension, child );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.userData.structuralMetadata = rootMetadata;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import { Vector2 } from 'three';\nimport { TextureReadUtility } from '../utilities/TextureReadUtility.js';\nimport { getTexCoord, getTexelIndices, getTriangleVertexIndices } from '../utilities/TexCoordUtilities.js';\n\nconst _uv = /* @__PURE__ */ new Vector2();\nconst _pixel = /* @__PURE__ */ new Vector2();\nconst _dstPixel = /* @__PURE__ */ new Vector2();\n\n// retrieve the appropriate UV attribute based on the tex coord index\nfunction getMaxBarycoordIndex( barycoord ) {\n\n\tif ( barycoord.x > barycoord.y && barycoord.x > barycoord.z ) {\n\n\t\treturn 0;\n\n\t} else if ( barycoord.y > barycoord.z ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 2;\n\n\t}\n\n}\n\nexport class MeshFeatures {\n\n\tconstructor( geometry, textures, data ) {\n\n\t\tthis.geometry = geometry;\n\t\tthis.textures = textures;\n\t\tthis.data = data;\n\t\tthis._asyncRead = false;\n\n\t\t// fill out feature id default values\n\t\tthis.featureIds = data.featureIds.map( info => {\n\n\t\t\tconst { texture, ...rest } = info;\n\t\t\tconst result = {\n\t\t\t\tlabel: null,\n\t\t\t\tpropertyTable: null,\n\t\t\t\tnullFeatureId: null,\n\t\t\t\t...rest,\n\t\t\t};\n\n\t\t\tif ( texture ) {\n\n\t\t\t\tresult.texture = {\n\t\t\t\t\ttexCoord: 0,\n\t\t\t\t\tchannels: [ 0 ],\n\t\t\t\t\t...texture,\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t} );\n\n\t}\n\n\t// returns list of textures\n\tgetTextures() {\n\n\t\treturn this.textures;\n\n\t}\n\n\t// returns a set of info for each feature\n\tgetFeatureInfo() {\n\n\t\treturn this.featureIds;\n\n\t}\n\n\t// performs texture data read back asynchronously\n\tgetFeaturesAsync( ...args ) {\n\n\t\tthis._asyncRead = true;\n\t\tconst result = this.getFeatures( ...args );\n\t\tthis._asyncRead = false;\n\t\treturn result;\n\n\t}\n\n\t// returns all features for the given point on the given triangle\n\tgetFeatures( triangle, barycoord ) {\n\n\t\tconst { geometry, textures, featureIds } = this;\n\t\tconst result = new Array( featureIds.length ).fill( null );\n\n\t\t// prep the canvas width\n\t\tconst width = featureIds.length;\n\t\tTextureReadUtility.increaseSizeTo( width );\n\n\t\t// get the attribute indices\n\t\tconst indices = getTriangleVertexIndices( geometry, triangle );\n\t\tconst closestIndex = indices[ getMaxBarycoordIndex( barycoord ) ];\n\t\tfor ( let i = 0, l = featureIds.length; i < l; i ++ ) {\n\n\t\t\t// the feature id from the closest point is returned\n\t\t\tconst featureId = featureIds[ i ];\n\t\t\tconst nullFeatureId = 'nullFeatureId' in featureId ? featureId.nullFeatureId : null;\n\t\t\tif ( 'texture' in featureId ) {\n\n\t\t\t\tconst texture = textures[ featureId.texture.index ];\n\n\t\t\t\t// get the attribute of the target tex coord and pixel\n\t\t\t\tgetTexCoord( geometry, featureId.texture.texCoord, barycoord, indices, _uv );\n\t\t\t\tgetTexelIndices( _uv, texture.image.width, texture.image.height, _pixel );\n\t\t\t\t_dstPixel.set( i, 0 );\n\n\t\t\t\t// draw the image\n\t\t\t\tTextureReadUtility.renderPixelToTarget( textures[ featureId.texture.index ], _pixel, _dstPixel );\n\n\t\t\t} else if ( 'attribute' in featureId ) {\n\n\t\t\t\tconst attr = geometry.getAttribute( `_feature_id_${ featureId.attribute }` );\n\t\t\t\tconst value = attr.getX( closestIndex );\n\t\t\t\tif ( value !== nullFeatureId ) {\n\n\t\t\t\t\tresult[ i ] = value;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// implicit id is based on vertex attributes, see 3d-tiles#763\n\t\t\t\tconst value = closestIndex;\n\t\t\t\tif ( value !== nullFeatureId ) {\n\n\t\t\t\t\tresult[ i ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// read the buffer data\n\t\tconst buffer = new Uint8Array( width * 4 );\n\t\tif ( this._asyncRead ) {\n\n\t\t\treturn TextureReadUtility\n\t\t\t\t.readDataAsync( buffer )\n\t\t\t\t.then( () => {\n\n\t\t\t\t\treadTextureSampleResults();\n\t\t\t\t\treturn result;\n\n\t\t\t\t} );\n\n\t\t} else {\n\n\t\t\tTextureReadUtility.readData( buffer );\n\t\t\treadTextureSampleResults();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction readTextureSampleResults() {\n\n\t\t\t// get data based on the texture information\n\t\t\tconst readBuffer = new Uint32Array( 1 );\n\t\t\tfor ( let i = 0, l = featureIds.length; i < l; i ++ ) {\n\n\t\t\t\tconst featureId = featureIds[ i ];\n\t\t\t\tconst nullFeatureId = 'nullFeatureId' in featureId ? featureId.nullFeatureId : null;\n\t\t\t\tif ( 'texture' in featureId ) {\n\n\t\t\t\t\t// TODO: do we need to handle big-endian here?\n\t\t\t\t\tconst { channels } = featureId.texture;\n\t\t\t\t\tconst data = channels.map( c => buffer[ 4 * i + c ] );\n\t\t\t\t\tnew Uint8Array( readBuffer.buffer ).set( data );\n\n\t\t\t\t\tconst value = readBuffer[ 0 ];\n\t\t\t\t\tif ( value !== nullFeatureId ) {\n\n\t\t\t\t\t\tresult[ i ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// dispose all of the texture data used\n\tdispose() {\n\n\t\tthis.textures.forEach( texture => {\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import { MeshFeatures } from './metadata/classes/MeshFeatures.js';\n\n// https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_mesh_features\n\nconst EXT_NAME = 'EXT_mesh_features';\n\nfunction forEachPrimitiveExtension( scene, parser, callback ) {\n\n\tscene.traverse( c => {\n\n\t\tif ( parser.associations.has( c ) ) {\n\n\t\t\t// check if this object has extension references\n\t\t\tconst { meshes, primitives } = parser.associations.get( c );\n\n\t\t\tconst primitive = parser.json.meshes[ meshes ]?.primitives[ primitives ];\n\n\t\t\tif ( primitive && primitive.extensions && primitive.extensions[ EXT_NAME ] ) {\n\n\t\t\t\tcallback( c, primitive.extensions[ EXT_NAME ] );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n}\n\nexport class GLTFMeshFeaturesExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXT_NAME;\n\n\t}\n\n\tasync afterRoot( { scene, parser } ) {\n\n\t\t// skip if the extension is not present\n\t\tconst extensionsUsed = parser.json.extensionsUsed;\n\t\tif ( ! extensionsUsed || ! extensionsUsed.includes( EXT_NAME ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// get fetch the relevant textures are loaded\n\t\tconst textureCount = parser.json.textures?.length || 0;\n\t\tconst promises = new Array( textureCount ).fill( null );\n\t\tforEachPrimitiveExtension( scene, parser, ( child, { featureIds } ) => {\n\n\t\t\tfeatureIds.forEach( info => {\n\n\t\t\t\tif ( info.texture && promises[ info.texture.index ] === null ) {\n\n\t\t\t\t\tconst index = info.texture.index;\n\t\t\t\t\tpromises[ index ] = parser.loadTexture( index );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// initialize mesh features on each primitive\n\t\tconst textures = await Promise.all( promises );\n\t\tforEachPrimitiveExtension( scene, parser, ( child, extension ) => {\n\n\t\t\tchild.userData.meshFeatures = new MeshFeatures( child.geometry, textures, extension );\n\n\t\t} );\n\n\t}\n\n}\n","export class GLTFCesiumRTCExtension {\n\n\tconstructor() {\n\n\t\tthis.name = 'CESIUM_RTC';\n\n\t}\n\n\tafterRoot( res ) {\n\n\t\tif ( res.parser.json.extensions && res.parser.json.extensions.CESIUM_RTC ) {\n\n\t\t\tconst { center } = res.parser.json.extensions.CESIUM_RTC;\n\n\t\t\tif ( center ) {\n\n\t\t\t\tres.scene.position.x += center[ 0 ];\n\t\t\t\tres.scene.position.y += center[ 1 ];\n\t\t\t\tres.scene.position.z += center[ 2 ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { GLTFStructuralMetadataExtension } from './gltf/GLTFStructuralMetadataExtension.js';\nimport { GLTFMeshFeaturesExtension } from './gltf/GLTFMeshFeaturesExtension.js';\nimport { GLTFCesiumRTCExtension } from './gltf/GLTFCesiumRTCExtension.js';\n\nexport class GLTFExtensionsPlugin {\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\t\t\tmetadata: true,\n\t\t\trtc: true,\n\n\t\t\tplugins: [],\n\n\t\t\tdracoLoader: null,\n\t\t\tktxLoader: null,\n\t\t\tmeshoptDecoder: null,\n\t\t\tautoDispose: true,\n\t\t\t...options,\n\t\t};\n\n\t\tthis.tiles = null;\n\n\t\tthis.metadata = options.metadata;\n\t\tthis.rtc = options.rtc;\n\t\tthis.plugins = options.plugins;\n\n\t\tthis.dracoLoader = options.dracoLoader;\n\t\tthis.ktxLoader = options.ktxLoader;\n\t\tthis.meshoptDecoder = options.meshoptDecoder;\n\t\tthis._gltfRegex = /\\.(gltf|glb)$/g;\n\t\tthis._dracoRegex = /\\.drc$/g;\n\t\tthis._loader = null;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tconst loader = new GLTFLoader( tiles.manager );\n\t\tif ( this.dracoLoader ) {\n\n\t\t\tloader.setDRACOLoader( this.dracoLoader );\n\t\t\ttiles.manager.addHandler( this._dracoRegex, this.dracoLoader );\n\n\t\t}\n\n\t\tif ( this.ktxLoader ) {\n\n\t\t\tloader.setKTX2Loader( this.ktxLoader );\n\n\t\t}\n\n\t\tif ( this.meshoptDecoder ) {\n\n\t\t\tloader.setMeshoptDecoder( this.meshoptDecoder );\n\n\t\t}\n\n\t\tif ( this.rtc ) {\n\n\t\t\tloader.register( () => new GLTFCesiumRTCExtension() );\n\n\t\t}\n\n\t\tif ( this.metadata ) {\n\n\t\t\tloader.register( () => new GLTFStructuralMetadataExtension() );\n\t\t\tloader.register( () => new GLTFMeshFeaturesExtension() );\n\n\t\t}\n\n\t\tthis.plugins.forEach( plugin => loader.register( plugin ) );\n\n\t\ttiles.manager.addHandler( this._gltfRegex, loader );\n\t\tthis.tiles = tiles;\n\t\tthis._loader = loader;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.tiles.manager.removeHandler( this._gltfRegex );\n\t\tthis.tiles.manager.removeHandler( this._dracoRegex );\n\t\tif ( this.autoDispose ) {\n\n\t\t\tthis.ktxLoader.dispose();\n\t\t\tthis.dracoLoader.dispose();\n\n\t\t}\n\n\t}\n\n}\n","import { Sphere } from 'three';\nimport { OBJECT_FRAME } from '3d-tiles-renderer/three';\n\nconst sphere = /* @__PURE__ */ new Sphere();\nexport class ReorientationPlugin {\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\t\t\tup: '+z',\n\t\t\trecenter: true,\n\n\t\t\tlat: null,\n\t\t\tlon: null,\n\t\t\theight: 0,\n\n\t\t\tazimuth: 0,\n\t\t\televation: 0,\n\t\t\troll: 0,\n\n\t\t\t...options,\n\t\t};\n\n\t\tthis.tiles = null;\n\n\t\tthis.up = options.up.toLowerCase().replace( /\\s+/, '' );\n\t\tthis.lat = options.lat;\n\t\tthis.lon = options.lon;\n\t\tthis.height = options.height;\n\t\tthis.azimuth = options.azimuth;\n\t\tthis.elevation = options.elevation;\n\t\tthis.roll = options.roll;\n\t\tthis.recenter = options.recenter;\n\t\tthis._callback = null;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\tthis._callback = () => {\n\n\t\t\tconst { up, lat, lon, height, azimuth, elevation, roll, recenter } = this;\n\n\t\t\tif ( lat !== null && lon !== null ) {\n\n\t\t\t\t// if the latitude and longitude are provided then remove the position offset\n\t\t\t\tthis.transformLatLonHeightToOrigin( lat, lon, height, azimuth, elevation, roll );\n\n\t\t\t} else {\n\n\t\t\t\tconst { ellipsoid } = tiles;\n\t\t\t\tconst minRadii = Math.min( ...ellipsoid.radius );\n\t\t\t\ttiles.getBoundingSphere( sphere );\n\t\t\t\tif ( sphere.center.length() > minRadii * 0.5 ) {\n\n\t\t\t\t\t// otherwise see if this is possibly a tileset on the surface of the globe based on the positioning\n\t\t\t\t\tconst cart = {};\n\t\t\t\t\tellipsoid.getPositionToCartographic( sphere.center, cart );\n\t\t\t\t\tthis.transformLatLonHeightToOrigin( cart.lat, cart.lon, cart.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// lastly fall back to orienting the up direction to +Y\n\t\t\t\t\tconst group = tiles.group;\n\t\t\t\t\tgroup.rotation.set( 0, 0, 0 );\n\t\t\t\t\tswitch ( up ) {\n\n\t\t\t\t\t\tcase 'x': case '+x':\n\t\t\t\t\t\t\tgroup.rotation.z = Math.PI / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-x':\n\t\t\t\t\t\t\tgroup.rotation.z = - Math.PI / 2;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'y': case '+y':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-y':\n\t\t\t\t\t\t\tgroup.rotation.z = Math.PI;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'z': case '+z':\n\t\t\t\t\t\t\tgroup.rotation.x = - Math.PI / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-z':\n\t\t\t\t\t\t\tgroup.rotation.x = Math.PI / 2;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttiles.group.position\n\t\t\t\t\t\t.copy( sphere.center )\n\t\t\t\t\t\t.applyEuler( group.rotation )\n\t\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! recenter ) {\n\n\t\t\t\ttiles.group.position.setScalar( 0 );\n\n\t\t\t}\n\n\t\t\ttiles.removeEventListener( 'load-root-tileset', this._callback );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'load-root-tileset', this._callback );\n\n\t\tif ( tiles.root ) {\n\n\t\t\tthis._callback();\n\n\t\t}\n\n\t}\n\n\ttransformLatLonHeightToOrigin( lat, lon, height = 0, azimuth = 0, elevation = 0, roll = 0 ) {\n\n\t\tconst { group, ellipsoid } = this.tiles;\n\n\t\t// get ENU orientation (Z facing north and X facing west) and position\n\t\tellipsoid.getObjectFrame( lat, lon, height, azimuth, elevation, roll, group.matrix, OBJECT_FRAME );\n\n\t\t// adjust the group matrix\n\t\tgroup.matrix.invert().decompose( group.position, group.quaternion, group.scale );\n\t\tgroup.updateMatrixWorld();\n\n\t}\n\n\tdispose() {\n\n\t\tconst { group } = this.tiles;\n\t\tgroup.position.setScalar( 0 );\n\t\tgroup.quaternion.identity();\n\t\tgroup.scale.set( 1, 1, 1 );\n\n\t\tthis.tiles.removeEventListener( 'load-root-tileset', this._callback );\n\n\t}\n\n}\n","import { LRUCache } from '3d-tiles-renderer/core';\n\n// Plugin that disposes tiles on unload to remove them from the GPU, saving memory\n\n// TODO:\n// - abstract the \"tile visible\" callback so fade tiles can call it when tiles are _actually_ marked as non-visible\nexport class UnloadTilesPlugin {\n\n\tset delay( v ) {\n\n\t\tthis.deferCallbacks.delay = v;\n\n\t}\n\n\tget delay() {\n\n\t\treturn this.deferCallbacks.delay;\n\n\t}\n\n\tset bytesTarget( v ) {\n\n\t\tthis.lruCache.minBytesSize = v;\n\n\t}\n\n\tget bytesTarget() {\n\n\t\treturn this.lruCache.minBytesSize;\n\n\t}\n\n\tget estimatedGpuBytes() {\n\n\t\treturn this.lruCache.cachedBytes;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tbytesTarget = 0,\n\t\t} = options;\n\n\t\tthis.name = 'UNLOAD_TILES_PLUGIN';\n\n\t\tthis.tiles = null;\n\t\tthis.lruCache = new LRUCache();\n\t\tthis.deferCallbacks = new DeferCallbackManager();\n\n\t\tthis.delay = delay;\n\t\tthis.bytesTarget = bytesTarget;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\tconst { lruCache, deferCallbacks } = this;\n\t\tdeferCallbacks.callback = tile => {\n\n\t\t\tlruCache.markUnused( tile );\n\t\t\tlruCache.scheduleUnload( false );\n\n\t\t};\n\n\t\tconst unloadCallback = tile => {\n\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tconst visible = tiles.visibleTiles.has( tile );\n\n\t\t\tif ( ! visible ) {\n\n\t\t\t\ttiles.invokeOnePlugin( plugin => plugin.unloadTileFromGPU && plugin.unloadTileFromGPU( scene, tile ) );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._onUpdateBefore = () => {\n\n\t\t\t// update lruCache in \"update\" in case the callback values change\n\t\t\tlruCache.unloadPriorityCallback = tiles.lruCache.unloadPriorityCallback;\n\t\t\tlruCache.computeMemoryUsageCallback = tiles.lruCache.computeMemoryUsageCallback;\n\t\t\tlruCache.minSize = Infinity;\n\t\t\tlruCache.maxSize = Infinity;\n\t\t\tlruCache.maxBytesSize = Infinity;\n\t\t\tlruCache.unloadPercent = 1;\n\t\t\tlruCache.autoMarkUnused = false;\n\n\t\t};\n\n\t\tthis._onVisibilityChangeCallback = ( { tile, visible } ) => {\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tlruCache.add( tile, unloadCallback );\n\t\t\t\ttiles.markTileUsed( tile );\n\t\t\t\tdeferCallbacks.cancel( tile );\n\n\t\t\t} else {\n\n\t\t\t\tdeferCallbacks.run( tile );\n\n\t\t\t}\n\n\t\t};\n\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tconst visible = tiles.visibleTiles.has( tile );\n\t\t\tthis._onVisibilityChangeCallback( { scene, visible } );\n\n\t\t} );\n\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onVisibilityChangeCallback );\n\t\ttiles.addEventListener( 'update-before', this._onUpdateBefore );\n\n\t}\n\n\tunloadTileFromGPU( scene, tile ) {\n\n\t\tif ( scene ) {\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tconst material = c.material;\n\t\t\t\t\tmaterial.dispose();\n\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\t\tvalue.dispose();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c.geometry ) {\n\n\t\t\t\t\tc.geometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.tiles.removeEventListener( 'tile-visibility-change', this._onVisibilityChangeCallback );\n\t\tthis.tiles.removeEventListener( 'update-before', this._onUpdateBefore );\n\t\tthis.deferCallbacks.cancelAll();\n\n\t}\n\n}\n\n// Manager for running callbacks after a certain amount of time\nclass DeferCallbackManager {\n\n\tconstructor( callback = () => {} ) {\n\n\t\tthis.map = new Map();\n\t\tthis.callback = callback;\n\t\tthis.delay = 0;\n\n\t}\n\n\trun( tile ) {\n\n\t\tconst { map, delay } = this;\n\t\tif ( map.has( tile ) ) {\n\n\t\t\tthrow new Error( 'DeferCallbackManager: Callback already initialized.' );\n\n\t\t}\n\n\t\tif ( delay === 0 ) {\n\n\t\t\tthis.callback( tile );\n\n\t\t} else {\n\n\t\t\tmap.set( tile, setTimeout( () => this.callback( tile ), delay ) );\n\n\t\t}\n\n\t}\n\n\tcancel( tile ) {\n\n\t\tconst { map } = this;\n\t\tif ( map.has( tile ) ) {\n\n\t\t\tclearTimeout( map.get( tile ) );\n\t\t\tmap.delete( tile );\n\n\t\t}\n\n\t}\n\n\tcancelAll() {\n\n\t\tthis.map.forEach( ( value, tile ) => {\n\n\t\t\tthis.cancel( tile );\n\n\t\t} );\n\n\t}\n\n}\n","import { MathUtils } from 'three';\n\nconst { clamp } = MathUtils;\nexport class FadeManager {\n\n\tconstructor() {\n\n\t\tthis.duration = 250;\n\t\tthis.fadeCount = 0;\n\t\tthis._lastTick = - 1;\n\t\tthis._fadeState = new Map();\n\t\tthis.onFadeComplete = null;\n\t\tthis.onFadeStart = null;\n\t\tthis.onFadeSetComplete = null;\n\t\tthis.onFadeSetStart = null;\n\n\t}\n\n\t// delete the object from the fade, reset the material data\n\tdeleteObject( object ) {\n\n\t\tif ( ! object ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.completeFade( object );\n\n\t}\n\n\t// Ensure we're storing a fade timer for the provided object\n\t// Returns whether a new state had to be added\n\tguaranteeState( object ) {\n\n\t\tconst fadeState = this._fadeState;\n\t\tif ( fadeState.has( object ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst state = {\n\t\t\tfadeInTarget: 0,\n\t\t\tfadeOutTarget: 0,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t};\n\n\t\tfadeState.set( object, state );\n\n\t\treturn true;\n\n\t}\n\n\t// Force the fade to complete in the direction it is already trending\n\tcompleteFade( object ) {\n\n\t\tconst fadeState = this._fadeState;\n\t\tif ( ! fadeState.has( object ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst visible = fadeState.get( object ).fadeOutTarget === 0;\n\n\t\tfadeState.delete( object );\n\n\t\t// fire events\n\t\tthis.fadeCount --;\n\n\t\tif ( this.onFadeComplete ) {\n\n\t\t\tthis.onFadeComplete( object, visible );\n\n\t\t}\n\n\t\tif ( this.fadeCount === 0 && this.onFadeSetComplete ) {\n\n\t\t\tthis.onFadeSetComplete();\n\n\t\t}\n\n\t}\n\n\tcompleteAllFades() {\n\n\t\tthis._fadeState.forEach( ( value, key ) => {\n\n\t\t\tthis.completeFade( key );\n\n\t\t} );\n\n\t}\n\n\tforEachObject( cb ) {\n\n\t\tthis._fadeState.forEach( ( info, object ) => {\n\n\t\t\tcb( object, info );\n\n\t\t} );\n\n\t}\n\n\t// Fade the object in\n\tfadeIn( object ) {\n\n\t\tconst noState = this.guaranteeState( object );\n\t\tconst state = this._fadeState.get( object );\n\t\tstate.fadeInTarget = 1;\n\t\tstate.fadeOutTarget = 0;\n\t\tstate.fadeOut = 0;\n\n\t\t// Fire events\n\t\tif ( noState ) {\n\n\t\t\tthis.fadeCount ++;\n\t\t\tif ( this.fadeCount === 1 && this.onFadeSetStart ) {\n\n\t\t\t\tthis.onFadeSetStart();\n\n\t\t\t}\n\n\t\t\tif ( this.onFadeStart ) {\n\n\t\t\t\tthis.onFadeStart( object );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Fade the object out\n\tfadeOut( object ) {\n\n\t\tconst noState = this.guaranteeState( object );\n\t\tconst state = this._fadeState.get( object );\n\t\tstate.fadeOutTarget = 1;\n\n\t\t// Fire events and initialize state\n\t\tif ( noState ) {\n\n\t\t\tstate.fadeInTarget = 1;\n\t\t\tstate.fadeIn = 1;\n\n\t\t\tthis.fadeCount ++;\n\t\t\tif ( this.fadeCount === 1 && this.onFadeSetStart ) {\n\n\t\t\t\tthis.onFadeSetStart();\n\n\t\t\t}\n\n\t\t\tif ( this.onFadeStart ) {\n\n\t\t\t\tthis.onFadeStart( object );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tisFading( object ) {\n\n\t\treturn this._fadeState.has( object );\n\n\t}\n\n\tisFadingOut( object ) {\n\n\t\tconst state = this._fadeState.get( object );\n\t\treturn state && state.fadeOutTarget === 1;\n\n\t}\n\n\t// Tick the fade timer for each actively fading object\n\tupdate() {\n\n\t\t// clamp delta in case duration is really small or 0\n\t\tconst time = window.performance.now();\n\t\tif ( this._lastTick === - 1 ) {\n\n\t\t\tthis._lastTick = time;\n\n\t\t}\n\n\t\tconst delta = clamp( ( time - this._lastTick ) / this.duration, 0, 1 );\n\t\tthis._lastTick = time;\n\n\t\tconst fadeState = this._fadeState;\n\t\tfadeState.forEach( ( state, object ) => {\n\n\t\t\t// tick the fade values\n\t\t\tconst {\n\t\t\t\tfadeOutTarget,\n\t\t\t\tfadeInTarget,\n\t\t\t} = state;\n\n\t\t\tlet {\n\t\t\t\tfadeOut,\n\t\t\t\tfadeIn,\n\t\t\t} = state;\n\n\t\t\tconst fadeInSign = Math.sign( fadeInTarget - fadeIn );\n\t\t\tfadeIn = clamp( fadeIn + fadeInSign * delta, 0, 1 );\n\n\t\t\tconst fadeOutSign = Math.sign( fadeOutTarget - fadeOut );\n\t\t\tfadeOut = clamp( fadeOut + fadeOutSign * delta, 0, 1 );\n\n\t\t\tstate.fadeIn = fadeIn;\n\t\t\tstate.fadeOut = fadeOut;\n\n\t\t\t// Check if the fade in and fade out animations are complete\n\t\t\tconst fadeOutComplete = fadeOut === 1 || fadeOut === 0;\n\t\t\tconst fadeInComplete = fadeIn === 1 || fadeIn === 0;\n\n\t\t\t// If they are or the fade out animation is further along than the\n\t\t\t// fade in animation then mark the fade as completed for this tile\n\t\t\tif ( ( fadeOutComplete && fadeInComplete ) || fadeOut >= fadeIn ) {\n\n\t\t\t\tthis.completeFade( object );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","// Adjusts the provided material to support fading in and out using a bayer pattern. Providing a \"previous\"\n// before compile can be used to chain shader adjustments. Returns the added uniforms used for fading.\nconst FADE_PARAMS = Symbol( 'FADE_PARAMS' );\nexport function wrapFadeMaterial( material, previousOnBeforeCompile ) {\n\n\t// if the material has already been wrapped then return the params\n\tif ( material[ FADE_PARAMS ] ) {\n\n\t\treturn material[ FADE_PARAMS ];\n\n\t}\n\n\tconst params = {\n\t\tfadeIn: { value: 0 },\n\t\tfadeOut: { value: 0 },\n\t\tfadeTexture: { value: null },\n\t};\n\n\tmaterial[ FADE_PARAMS ] = params;\n\n\tmaterial.defines = {\n\t\t...( material.defines || {} ),\n\t\tFEATURE_FADE: 0,\n\t};\n\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tif ( previousOnBeforeCompile ) {\n\n\t\t\tpreviousOnBeforeCompile( shader );\n\n\t\t}\n\n\t\tshader.uniforms = {\n\t\t\t...shader.uniforms,\n\t\t\t...params,\n\t\t};\n\n\t\tshader.vertexShader = shader.vertexShader\n\t\t\t.replace(\n\t\t\t\t/void\\s+main\\(\\)\\s+{/,\n\t\t\t\tvalue => /* glsl */`\n\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\tvarying float vBatchId;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t${ value }\n\n\t\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\t\t// add 0.5 to the value to avoid floating error that may cause flickering\n\t\t\t\t\t\tvBatchId = getIndirectIndex( gl_DrawID ) + 0.5;\n\n\t\t\t\t\t\t#endif\n\t\t\t\t`\n\t\t\t);\n\n\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t// adapted from https://www.shadertoy.com/view/Mlt3z8\n\t\t\t\tfloat bayerDither2x2( vec2 v ) {\n\n\t\t\t\t\treturn mod( 3.0 * v.y + 2.0 * v.x, 4.0 );\n\n\t\t\t\t}\n\n\t\t\t\tfloat bayerDither4x4( vec2 v ) {\n\n\t\t\t\t\tvec2 P1 = mod( v, 2.0 );\n\t\t\t\t\tvec2 P2 = floor( 0.5 * mod( v, 4.0 ) );\n\t\t\t\t\treturn 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );\n\n\t\t\t\t}\n\n\t\t\t\t// the USE_BATCHING define is not available in fragment shaders\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t// functions for reading the fade state of a given batch id\n\t\t\t\tuniform sampler2D fadeTexture;\n\t\t\t\tvarying float vBatchId;\n\t\t\t\tvec2 getFadeValues( const in float i ) {\n\n\t\t\t\t\tint size = textureSize( fadeTexture, 0 ).x;\n\t\t\t\t\tint j = int( i );\n\t\t\t\t\tint x = j % size;\n\t\t\t\t\tint y = j / size;\n\t\t\t\t\treturn texelFetch( fadeTexture, ivec2( x, y ), 0 ).rg;\n\n\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\tuniform float fadeIn;\n\t\t\t\tuniform float fadeOut;\n\n\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t${ value }\n\t\t\t` )\n\t\t\t.replace( /#include <dithering_fragment>/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\tvec2 fadeValues = getFadeValues( vBatchId );\n\t\t\t\tfloat fadeIn = fadeValues.r;\n\t\t\t\tfloat fadeOut = fadeValues.g;\n\n\t\t\t\t#endif\n\n\t\t\t\tfloat bayerValue = bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) );\n\t\t\t\tfloat bayerBins = 16.0;\n\t\t\t\tfloat dither = ( 0.5 + bayerValue ) / bayerBins;\n\t\t\t\tif ( dither >= fadeIn ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\tif ( dither < fadeOut ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t` );\n\n\t};\n\n\treturn params;\n\n}\n","import { wrapFadeMaterial } from './wrapFadeMaterial.js';\n\n// Class for managing and updating extended fade parameters\nexport class FadeMaterialManager {\n\n\tconstructor() {\n\n\t\tthis._fadeParams = new WeakMap();\n\t\tthis.fading = 0;\n\n\t}\n\n\t// Set the fade parameters for the given scene\n\tsetFade( scene, fadeIn, fadeOut ) {\n\n\t\tif ( ! scene ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// traverse the scene and update the fade parameters of all materials\n\t\tconst fadeParams = this._fadeParams;\n\t\tscene.traverse( child => {\n\n\t\t\tconst material = child.material;\n\t\t\tif ( material && fadeParams.has( material ) ) {\n\n\t\t\t\tconst params = fadeParams.get( material );\n\t\t\t\tparams.fadeIn.value = fadeIn;\n\t\t\t\tparams.fadeOut.value = fadeOut;\n\n\t\t\t\tconst fadeInComplete = fadeIn === 0 || fadeIn === 1;\n\t\t\t\tconst fadeOutComplete = fadeOut === 0 || fadeOut === 1;\n\t\t\t\tconst value = Number( ! fadeInComplete || ! fadeOutComplete );\n\t\t\t\tif ( material.defines.FEATURE_FADE !== value ) {\n\n\t\t\t\t\tthis.fading += value === 1 ? 1 : - 1;\n\t\t\t\t\tmaterial.defines.FEATURE_FADE = value;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// initialize materials in the object\n\tprepareScene( scene ) {\n\n\t\tscene.traverse( child => {\n\n\t\t\tif ( child.material ) {\n\n\t\t\t\tthis.prepareMaterial( child.material );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// delete the object from the fade, reset the material data\n\tdeleteScene( scene ) {\n\n\t\tif ( ! scene ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// mark the materials such that they are displayed at full value\n\t\tthis.setFade( scene, 1, 0 );\n\n\t\t// revert the materials\n\t\tconst fadeParams = this._fadeParams;\n\t\tscene.traverse( child => {\n\n\t\t\tconst material = child.material;\n\t\t\tif ( material ) {\n\n\t\t\t\tfadeParams.delete( material );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// initialize the material\n\tprepareMaterial( material ) {\n\n\t\tconst fadeParams = this._fadeParams;\n\t\tif ( fadeParams.has( material ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tfadeParams.set( material, wrapFadeMaterial( material, material.onBeforeCompile ) );\n\n\t}\n\n}\n","import { MeshBasicMaterial } from 'three';\n\n// A hacky version of BatchedMesh that passes through functions and geometry and other fields from the underlying\n// BatchedMesh. Calls to \"this\" or \"super\" will not work in subfunctions.\nexport class PassThroughBatchedMesh {\n\n\tconstructor( other, material = new MeshBasicMaterial() ) {\n\n\t\t// the other batched mesh\n\t\tthis.other = other;\n\n\t\t// guarded fields\n\t\tthis.material = material;\n\t\tthis.visible = true;\n\t\tthis.parent = null;\n\t\tthis._instanceInfo = [];\n\t\tthis._visibilityChanged = true;\n\n\t\t// the proxy instance tht pass through arguments to the underlying mesh\n\t\tconst proxyTarget = new Proxy( this, {\n\n\t\t\tget( target, key ) {\n\n\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\treturn target[ key ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// sync instances on function call and call functions on \"this\" instance\n\t\t\t\t\tconst value = other[ key ];\n\t\t\t\t\tif ( value instanceof Function ) {\n\n\t\t\t\t\t\treturn ( ...args ) => {\n\n\t\t\t\t\t\t\ttarget.syncInstances();\n\t\t\t\t\t\t\treturn value.call( proxyTarget, ...args );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn other[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tset( target, key, value ) {\n\n\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\ttarget[ key ] = value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tother[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t},\n\n\t\t\tdeleteProperty( target, key ) {\n\n\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\treturn delete target[ key ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn delete other[ key ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// ownKeys() {},\n\t\t\t// has(target, key) {},\n\t\t\t// defineProperty(target, key, descriptor) {},\n\t\t\t// getOwnPropertyDescriptor(target, key) {},\n\n\t\t} );\n\n\t\treturn proxyTarget;\n\n\t}\n\n\tsyncInstances() {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst otherInstanceInfo = this.other._instanceInfo;\n\t\twhile ( otherInstanceInfo.length > instanceInfo.length ) {\n\n\t\t\tconst index = instanceInfo.length;\n\t\t\tinstanceInfo.push( new Proxy( { visible: false }, {\n\n\t\t\t\tget( target, key ) {\n\n\t\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\t\treturn target[ key ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn otherInstanceInfo[ index ][ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tset( target, key, value ) {\n\n\t\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\t\ttarget[ key ] = value;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\totherInstanceInfo[ index ][ key ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} ) );\n\n\t\t}\n\n\t}\n\n}\n","import { PassThroughBatchedMesh } from './PassThroughBatchedMesh.js';\nimport { RGFormat, UnsignedByteType, DataTexture } from 'three';\nimport { wrapFadeMaterial } from './wrapFadeMaterial.js';\n\n// BatchedMesh instance that can fade materials\nexport class FadeBatchedMesh extends PassThroughBatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\t// construct a version of the material that supports fading\n\t\tconst material = this.material;\n\t\tconst params = wrapFadeMaterial( material, material.onBeforeCompile );\n\t\tmaterial.defines.FEATURE_FADE = 1;\n\t\tmaterial.defines.USE_BATCHING_FRAG = 1;\n\t\tmaterial.needsUpdate = true;\n\n\t\t// fade parameters\n\t\tthis.fadeTexture = null;\n\t\tthis._fadeParams = params;\n\n\t}\n\n\t// Set the fade state\n\tsetFadeAt( index, fadeIn, fadeOut ) {\n\n\t\tthis._initFadeTexture();\n\t\tthis.fadeTexture.setValueAt( index, fadeIn * 255, fadeOut * 255 );\n\n\t}\n\n\t// initialize the texture and resize it if needed\n\t_initFadeTexture() {\n\n\t\t// calculate the new size\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\tconst length = size * size * 2;\n\t\tconst oldFadeTexture = this.fadeTexture;\n\t\tif ( ! oldFadeTexture || oldFadeTexture.image.data.length !== length ) {\n\n\t\t\t// 2 bytes per RG pixel\n\t\t\tconst fadeArray = new Uint8Array( length );\n\t\t\tconst fadeTexture = new InstanceDataTexture( fadeArray, size, size, RGFormat, UnsignedByteType );\n\n\t\t\t// copy the data from the old fade texture if it exists\n\t\t\tif ( oldFadeTexture ) {\n\n\t\t\t\toldFadeTexture.dispose();\n\n\t\t\t\tconst src = oldFadeTexture.image.data;\n\t\t\t\tconst dst = this.fadeTexture.image.data;\n\t\t\t\tconst len = Math.min( src.length, dst.length );\n\t\t\t\tdst.set( new src.constructor( src.buffer, 0, len ) );\n\n\t\t\t}\n\n\t\t\t// assign the new fade texture to the uniform, member variable\n\t\t\tthis.fadeTexture = fadeTexture;\n\t\t\tthis._fadeParams.fadeTexture.value = fadeTexture;\n\t\t\tfadeTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t// dispose the fade texture. Super cannot be used here due to proxy\n\tdispose() {\n\n\t\tif ( this.fadeTexture ) {\n\n\t\t\tthis.fadeTexture.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n// Version of data texture that can assign pixel values\nclass InstanceDataTexture extends DataTexture {\n\n\tsetValueAt( instance, ...values ) {\n\n\t\tconst { data, width, height } = this.image;\n\t\tconst itemSize = Math.floor( data.length / ( width * height ) );\n\t\tlet needsUpdate = false;\n\t\tfor ( let i = 0; i < itemSize; i ++ ) {\n\n\t\t\tconst index = instance * itemSize + i;\n\t\t\tconst prevValue = data[ index ];\n\t\t\tconst newValue = values[ i ] || 0;\n\t\t\tif ( prevValue !== newValue ) {\n\n\t\t\t\tdata[ index ] = newValue;\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4, Vector3, Quaternion } from 'three';\nimport { FadeManager } from './FadeManager.js';\nimport { FadeMaterialManager } from './FadeMaterialManager.js';\nimport { FadeBatchedMesh } from './FadeBatchedMesh.js';\n\nconst HAS_POPPED_IN = Symbol( 'HAS_POPPED_IN' );\nconst _fromPos = /* @__PURE__ */ new Vector3();\nconst _toPos = /* @__PURE__ */ new Vector3();\nconst _fromQuat = /* @__PURE__ */ new Quaternion();\nconst _toQuat = /* @__PURE__ */ new Quaternion();\nconst _scale = /* @__PURE__ */ new Vector3();\n\nfunction onUpdateBefore() {\n\n\tconst fadeManager = this._fadeManager;\n\tconst tiles = this.tiles;\n\n\t// store the tiles renderer state before the tiles update so we can check\n\t// whether fading started or stopped completely\n\tthis._fadingBefore = fadeManager.fadeCount;\n\tthis._displayActiveTiles = tiles.displayActiveTiles;\n\n\t// we need to display all active tiles in this case so we don't fade tiles in\n\t// when moving from off screen\n\ttiles.displayActiveTiles = true;\n\n}\n\nfunction onUpdateAfter() {\n\n\tconst fadeManager = this._fadeManager;\n\tconst fadeMaterialManager = this._fadeMaterialManager;\n\tconst displayActiveTiles = this._displayActiveTiles;\n\tconst fadingBefore = this._fadingBefore;\n\tconst prevCameraTransforms = this._prevCameraTransforms;\n\tconst { tiles, maximumFadeOutTiles, batchedMesh } = this;\n\tconst { cameras } = tiles;\n\n\t// reset the active tiles flag\n\ttiles.displayActiveTiles = displayActiveTiles;\n\n\t// update fade step\n\tfadeManager.update();\n\n\t// fire an event\n\tconst fadingAfter = fadeManager.fadeCount;\n\tif ( fadingBefore !== 0 && fadingAfter !== 0 ) {\n\n\t\ttiles.dispatchEvent( { type: 'fade-change' } );\n\t\ttiles.dispatchEvent( { type: 'needs-render' } );\n\n\t}\n\n\t// update the visibility of tiles based on visibility since we must use\n\t// the active tiles for rendering fade\n\tif ( ! displayActiveTiles ) {\n\n\t\ttiles.visibleTiles.forEach( t => {\n\n\t\t\t// if a tile is fading out then it may not be traversed and thus will not have\n\t\t\t// the frustum flag set correctly.\n\t\t\tconst scene = t.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.visible = t.__inFrustum;\n\n\t\t\t}\n\n\t\t\tthis.forEachBatchIds( t, ( id, batchedMesh, plugin ) => {\n\n\t\t\t\tbatchedMesh.setVisibleAt( id, t.__inFrustum );\n\t\t\t\tplugin.batchedMesh.setVisibleAt( id, t.__inFrustum );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\tif ( maximumFadeOutTiles < this._fadingOutCount ) {\n\n\t\t// determine whether all the rendering cameras are moving\n\t\t// quickly so we can adjust how tiles fade accordingly\n\t\tlet isMovingFast = true;\n\t\tcameras.forEach( camera => {\n\n\t\t\tif ( ! prevCameraTransforms.has( camera ) ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currMatrix = camera.matrixWorld;\n\t\t\tconst prevMatrix = prevCameraTransforms.get( camera );\n\n\t\t\tcurrMatrix.decompose( _toPos, _toQuat, _scale );\n\t\t\tprevMatrix.decompose( _fromPos, _fromQuat, _scale );\n\n\t\t\tconst angleTo = _toQuat.angleTo( _fromQuat );\n\t\t\tconst positionTo = _toPos.distanceTo( _fromPos );\n\n\t\t\t// if rotation is moving > 0.25 radians per frame or position is moving > 0.1 units\n\t\t\t// then we are considering the camera to be moving too fast to notice a faster / abrupt fade\n\t\t\tisMovingFast = isMovingFast && ( angleTo > 0.25 || positionTo > 0.1 );\n\n\t\t} );\n\n\t\tif ( isMovingFast ) {\n\n\t\t\tfadeManager.completeAllFades();\n\n\t\t}\n\n\t}\n\n\t// track the camera movement so we can use it for next frame\n\tcameras.forEach( camera => {\n\n\t\tprevCameraTransforms.get( camera ).copy( camera.matrixWorld );\n\n\t} );\n\n\t// update the fade state for each tile\n\tfadeManager.forEachObject( ( tile, { fadeIn, fadeOut } ) => {\n\n\t\t// prevent faded tiles from being unloaded\n\t\tconst scene = tile.cached.scene;\n\t\tconst isFadingOut = fadeManager.isFadingOut( tile );\n\t\ttiles.markTileUsed( tile );\n\t\tif ( scene ) {\n\n\t\t\tfadeMaterialManager.setFade( scene, fadeIn, fadeOut );\n\t\t\tif ( isFadingOut ) {\n\n\t\t\t\tscene.visible = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// fade the tiles and toggle the visibility appropriately\n\t\tthis.forEachBatchIds( tile, ( id, batchedMesh, plugin ) => {\n\n\t\t\tbatchedMesh.setFadeAt( id, fadeIn, fadeOut );\n\t\t\tbatchedMesh.setVisibleAt( id, true );\n\t\t\tplugin.batchedMesh.setVisibleAt( id, false );\n\n\t\t} );\n\n\t} );\n\n\t// update the batched mesh fields\n\tif ( batchedMesh ) {\n\n\t\tconst material = tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' ).batchedMesh.material;\n\t\tbatchedMesh.material.map = material.map;\n\n\t}\n\n}\n\nexport class TilesFadePlugin {\n\n\tget fadeDuration() {\n\n\t\treturn this._fadeManager.duration;\n\n\t}\n\n\tset fadeDuration( value ) {\n\n\t\tthis._fadeManager.duration = Number( value );\n\n\t}\n\n\tget fadingTiles() {\n\n\t\treturn this._fadeManager.fadeCount;\n\n\t}\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\n\t\t\tmaximumFadeOutTiles: 50,\n\t\t\tfadeRootTiles: false,\n\t\t\tfadeDuration: 250,\n\t\t\t...options,\n\n\t\t};\n\n\t\tthis.name = 'FADE_TILES_PLUGIN';\n\t\tthis.priority = - 2;\n\n\t\tthis.tiles = null;\n\t\tthis.batchedMesh = null;\n\t\tthis._quickFadeTiles = new Set();\n\t\tthis._fadeManager = new FadeManager();\n\t\tthis._fadeMaterialManager = new FadeMaterialManager();\n\t\tthis._prevCameraTransforms = null;\n\t\tthis._fadingOutCount = 0;\n\n\t\tthis.maximumFadeOutTiles = options.maximumFadeOutTiles;\n\t\tthis.fadeRootTiles = options.fadeRootTiles;\n\t\tthis.fadeDuration = options.fadeDuration;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\t// event callback initialization\n\t\tthis._onLoadModel = ( { scene } )=> {\n\n\t\t\t// initialize all the scene materials to fade\n\t\t\tthis._fadeMaterialManager.prepareScene( scene );\n\n\t\t};\n\n\t\tthis._onDisposeModel = ( { tile, scene } ) => {\n\n\t\t\tif ( this.tiles.visibleTiles.has( tile ) ) {\n\n\t\t\t\t// mark the parent as needing to fade in quickly to accommodate the children disappearing.\n\t\t\t\t// this can happen when a tile is forcefully disposed or removed from the lru cache while visible.\n\t\t\t\tthis._quickFadeTiles.add( tile.parent );\n\n\t\t\t}\n\n\t\t\t// delete the fade info from the managers on disposal of model\n\t\t\tthis._fadeManager.deleteObject( tile );\n\t\t\tthis._fadeMaterialManager.deleteScene( scene );\n\n\t\t};\n\n\t\tthis._onAddCamera = ( { camera } ) => {\n\n\t\t\t// track the camera transform\n\t\t\tthis._prevCameraTransforms.set( camera, new Matrix4() );\n\n\t\t};\n\n\t\tthis._onDeleteCamera = ( { camera } )=> {\n\n\t\t\t// remove the camera transform\n\t\t\tthis._prevCameraTransforms.delete( camera );\n\n\t\t};\n\n\t\tthis._onTileVisibilityChange = ( { tile, visible } ) => {\n\n\t\t\t// this function gets fired _after_ all set visible callbacks including the batched meshes\n\n\t\t\t// revert the scene and fade to the initial state when toggling\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.visible = true;\n\n\t\t\t}\n\n\t\t\tthis.forEachBatchIds( tile, ( id, batchedMesh, plugin ) => {\n\n\t\t\t\tbatchedMesh.setFadeAt( id, 0, 0 );\n\t\t\t\tbatchedMesh.setVisibleAt( id, false );\n\t\t\t\tplugin.batchedMesh.setVisibleAt( id, false );\n\n\t\t\t} );\n\n\t\t};\n\n\t\tthis._onUpdateBefore = () => {\n\n\t\t\tonUpdateBefore.call( this );\n\n\t\t};\n\n\t\tthis._onUpdateAfter = () => {\n\n\t\t\tonUpdateAfter.call( this );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'load-model', this._onLoadModel );\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModel );\n\t\ttiles.addEventListener( 'add-camera', this._onAddCamera );\n\t\ttiles.addEventListener( 'delete-camera', this._onDeleteCamera );\n\t\ttiles.addEventListener( 'update-before', this._onUpdateBefore );\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onTileVisibilityChange );\n\n\t\t// initialize fade manager\n\t\tconst fadeManager = this._fadeManager;\n\t\tfadeManager.onFadeSetStart = () => {\n\n\t\t\ttiles.dispatchEvent( { type: 'fade-start' } );\n\t\t\ttiles.dispatchEvent( { type: 'needs-render' } );\n\n\t\t};\n\n\t\tfadeManager.onFadeSetComplete = () => {\n\n\t\t\ttiles.dispatchEvent( { type: 'fade-end' } );\n\t\t\ttiles.dispatchEvent( { type: 'needs-render' } );\n\n\t\t};\n\n\t\tfadeManager.onFadeComplete = ( tile, visible ) => {\n\n\t\t\t// mark the fade as finished and reset the fade parameters\n\t\t\tthis._fadeMaterialManager.setFade( tile.cached.scene, 0, 0 );\n\n\t\t\tthis.forEachBatchIds( tile, ( id, batchedMesh, plugin ) => {\n\n\t\t\t\tbatchedMesh.setFadeAt( id, 0, 0 );\n\t\t\t\tbatchedMesh.setVisibleAt( id, false );\n\t\t\t\tplugin.batchedMesh.setVisibleAt( id, visible );\n\n\t\t\t} );\n\n\t\t\tif ( ! visible ) {\n\n\t\t\t\t// now that the tile is hidden we can run the built-in setTileVisible function for the tile\n\t\t\t\ttiles.invokeOnePlugin( plugin => plugin !== this && plugin.setTileVisible && plugin.setTileVisible( tile, false ) );\n\t\t\t\tthis._fadingOutCount --;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// initialize the state based on what's already present\n\t\tconst prevCameraTransforms = new Map();\n\t\ttiles.cameras.forEach( camera => {\n\n\t\t\tprevCameraTransforms.set( camera, new Matrix4() );\n\n\t\t} );\n\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._onLoadModel( { scene } );\n\n\t\t} );\n\n\t\tthis.tiles = tiles;\n\t\tthis._fadeManager = fadeManager;\n\t\tthis._prevCameraTransforms = prevCameraTransforms;\n\n\t}\n\n\t// initializes the batched mesh if it needs to be, dispose if it it's no longer needed\n\tinitBatchedMesh() {\n\n\t\tconst otherBatchedMesh = this.tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' )?.batchedMesh;\n\t\tif ( otherBatchedMesh ) {\n\n\t\t\tif ( this.batchedMesh === null ) {\n\n\t\t\t\tthis._onBatchedMeshDispose = () => {\n\n\t\t\t\t\tthis.batchedMesh.dispose();\n\t\t\t\t\tthis.batchedMesh.removeFromParent();\n\t\t\t\t\tthis.batchedMesh = null;\n\t\t\t\t\totherBatchedMesh.removeEventListener( 'dispose', this._onBatchedMeshDispose );\n\n\t\t\t\t};\n\n\t\t\t\tconst material = otherBatchedMesh.material.clone();\n\t\t\t\tmaterial.onBeforeCompile = otherBatchedMesh.material.onBeforeCompile;\n\n\t\t\t\tthis.batchedMesh = new FadeBatchedMesh( otherBatchedMesh, material );\n\t\t\t\tthis.tiles.group.add( this.batchedMesh );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\t\tthis._onBatchedMeshDispose();\n\t\t\t\tthis._onBatchedMeshDispose = null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// callback for fading to prevent tiles from being removed until the fade effect has completed\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst fadeManager = this._fadeManager;\n\n\t\t// track the fade state\n\t\tconst wasFading = fadeManager.isFading( tile );\n\t\tif ( fadeManager.isFadingOut( tile ) ) {\n\n\t\t\tthis._fadingOutCount --;\n\n\t\t}\n\n\t\t// trigger any necessary fades\n\t\tif ( ! visible ) {\n\n\t\t\tthis._fadingOutCount ++;\n\t\t\tfadeManager.fadeOut( tile );\n\n\t\t} else {\n\n\t\t\t// if this is a root renderable tile and this is the first time rendering in\n\t\t\t// then pop it in\n\t\t\tconst isRootRenderableTile = tile.__depthFromRenderedParent === 1;\n\t\t\tif ( isRootRenderableTile ) {\n\n\t\t\t\tif ( tile[ HAS_POPPED_IN ] || this.fadeRootTiles ) {\n\n\t\t\t\t\tthis._fadeManager.fadeIn( tile );\n\n\t\t\t\t}\n\n\t\t\t\ttile[ HAS_POPPED_IN ] = true;\n\n\t\t\t} else {\n\n\t\t\t\tthis._fadeManager.fadeIn( tile );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if a tile needs to be jumped in then complete the fade here\n\t\tif ( this._quickFadeTiles.has( tile ) ) {\n\n\t\t\tthis._fadeManager.completeFade( tile );\n\t\t\tthis._quickFadeTiles.delete( tile );\n\n\t\t}\n\n\t\t// if a tile was already fading then it's already marked as visible and in the scene\n\t\tif ( wasFading ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// cancel the visibility change trigger because we're fading and will call this after\n\t\t// fade completes.\n\t\tconst isFading = this._fadeManager.isFading( tile );\n\t\tif ( ! visible && isFading ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tdispose() {\n\n\t\tconst tiles = this.tiles;\n\n\t\tthis._fadeManager.completeAllFades();\n\n\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\tthis._onBatchedMeshDispose();\n\n\t\t}\n\n\t\ttiles.removeEventListener( 'load-model', this._onLoadModel );\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModel );\n\t\ttiles.removeEventListener( 'add-camera', this._onAddCamera );\n\t\ttiles.removeEventListener( 'delete-camera', this._onDeleteCamera );\n\t\ttiles.removeEventListener( 'update-before', this._onUpdateBefore );\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.removeEventListener( 'tile-visibility-change', this._onTileVisibilityChange );\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._fadeManager.deleteObject( tile );\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.visible = true; // TODO\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// helper for iterating over the batch ids for a given tile\n\tforEachBatchIds( tile, cb ) {\n\n\t\tthis.initBatchedMesh();\n\n\t\tif ( this.batchedMesh ) {\n\n\t\t\tconst batchedPlugin = this.tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' );\n\t\t\tconst instanceIds = batchedPlugin.getTileBatchIds( tile );\n\t\t\tif ( instanceIds ) {\n\n\t\t\t\tinstanceIds.forEach( id => {\n\n\t\t\t\t\tcb( id, this.batchedMesh, batchedPlugin );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { BatchedMesh, Matrix4, Vector3, Source } from 'three';\n\nconst matrix = /* @__PURE__ */ new Matrix4();\nconst vec1 = /* @__PURE__ */ new Vector3();\nconst vec2 = /* @__PURE__ */ new Vector3();\nexport class ModelViewBatchedMesh extends BatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.resetDistance = 1e4;\n\t\tthis._matricesTextureHandle = null;\n\t\tthis._lastCameraPos = new Matrix4();\n\t\tthis._forceUpdate = true;\n\n\t\tthis._matrices = [];\n\n\t}\n\n\tsetMatrixAt( instanceId, matrix ) {\n\n\t\tsuper.setMatrixAt( instanceId, matrix );\n\t\tthis._forceUpdate = true;\n\n\t\t// save the matrices in their original float64 format to avoid\n\t\t// precision errors when multiplying later\n\t\tconst matrices = this._matrices;\n\t\twhile ( matrices.length <= instanceId ) {\n\n\t\t\tmatrices.push( new Matrix4() );\n\n\t\t}\n\n\t\tmatrices[ instanceId ].copy( matrix );\n\n\t}\n\n\tsetInstanceCount( ...args ) {\n\n\t\tsuper.setInstanceCount( ...args );\n\n\t\tconst matrices = this._matrices;\n\t\twhile ( matrices.length > this.instanceCount ) {\n\n\t\t\tmatrices.pop();\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material, group ) {\n\n\t\t// ensure matrices are complete and up to date\n\t\tsuper.onBeforeRender( renderer, scene, camera, geometry, material, group );\n\n\t\t// retrieve camera before and after camera positions\n\t\tvec1.setFromMatrixPosition( camera.matrixWorld );\n\t\tvec2.setFromMatrixPosition( this._lastCameraPos );\n\n\t\t// initialize the model-view matrix texture if needed\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tlet modelViewMatricesTexture = this._modelViewMatricesTexture;\n\t\tif (\n\t\t\t! modelViewMatricesTexture ||\n\t\t\tmodelViewMatricesTexture.image.width !== matricesTexture.image.width ||\n\t\t\tmodelViewMatricesTexture.image.height !== matricesTexture.image.height\n\t\t) {\n\n\t\t\tif ( modelViewMatricesTexture ) {\n\n\t\t\t\tmodelViewMatricesTexture.dispose();\n\n\t\t\t}\n\n\t\t\tmodelViewMatricesTexture = matricesTexture.clone();\n\t\t\tmodelViewMatricesTexture.source = new Source( {\n\t\t\t\t...modelViewMatricesTexture.image,\n\t\t\t\tdata: modelViewMatricesTexture.image.data.slice(),\n\t\t\t} );\n\n\t\t\tthis._modelViewMatricesTexture = modelViewMatricesTexture;\n\n\t\t}\n\n\t\t// check if we need to update the model view matrices\n\t\tif ( this._forceUpdate || vec1.distanceTo( vec2 ) > this.resetDistance ) {\n\n\t\t\t// transform each objects matrix into local camera frame to avoid precision issues\n\t\t\tconst matrices = this._matrices;\n\t\t\tconst modelViewArray = modelViewMatricesTexture.image.data;\n\t\t\tfor ( let i = 0; i < this.maxInstanceCount; i ++ ) {\n\n\t\t\t\tconst instanceMatrix = matrices[ i ];\n\t\t\t\tif ( instanceMatrix ) {\n\n\t\t\t\t\tmatrix.copy( instanceMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t}\n\n\t\t\t\tmatrix\n\t\t\t\t\t.premultiply( this.matrixWorld )\n\t\t\t\t\t.premultiply( camera.matrixWorldInverse )\n\t\t\t\t\t.toArray( modelViewArray, i * 16 );\n\n\t\t\t}\n\n\t\t\tmodelViewMatricesTexture.needsUpdate = true;\n\t\t\tthis._lastCameraPos.copy( camera.matrixWorld );\n\t\t\tthis._forceUpdate = false;\n\n\t\t}\n\n\t\t// save handles, and transform the matrix world into the camera frame used to position the mesh instances\n\t\t// to offset the position shift.\n\t\tthis._matricesTextureHandle = this._matricesTexture;\n\t\tthis._matricesTexture = this._modelViewMatricesTexture;\n\t\tthis.matrixWorld.copy( this._lastCameraPos );\n\n\t}\n\n\tonAfterRender() {\n\n\t\tthis.updateMatrixWorld();\n\t\tthis._matricesTexture = this._matricesTextureHandle;\n\t\tthis._matricesTextureHandle = null;\n\n\t}\n\n\tonAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onAfterRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tif ( this._modelViewMatricesTexture ) {\n\n\t\t\tthis._modelViewMatricesTexture.dispose();\n\n\t\t}\n\n\t}\n\n}\n","import { Mesh, Box3, Sphere } from 'three';\nimport { ModelViewBatchedMesh } from './ModelViewBatchedMesh.js';\n\nconst _raycastMesh = /* @__PURE__ */ new Mesh();\nconst _batchIntersects = [];\n\n// Implementation of BatchedMesh that automatically expands\nexport class ExpandingBatchedMesh extends ModelViewBatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.expandPercent = 0.25;\n\t\tthis.maxInstanceExpansionSize = Infinity;\n\n\t\t// set of available geometry ids that are no longer being used\n\t\tthis._freeGeometryIds = [];\n\n\t}\n\n\t// Finds a free id that can fit the geometry with the requested ranges. Returns -1 if it could not be found.\n\tfindFreeId( geometry, reservedVertexRange, reservedIndexRange ) {\n\n\t\tconst needsIndex = Boolean( this.geometry.index );\n\t\tconst neededIndexCount = Math.max( needsIndex ? geometry.index.count : - 1, reservedIndexRange );\n\t\tconst neededVertexCount = Math.max( geometry.attributes.position.count, reservedVertexRange );\n\n\t\tlet bestIndex = - 1;\n\t\tlet bestScore = Infinity;\n\t\tconst freeGeometryIds = this._freeGeometryIds;\n\t\tfreeGeometryIds.forEach( ( id, i ) => {\n\n\t\t\t// if indices are not needed then they default to - 1\n\t\t\tconst geometryInfo = this.getGeometryRangeAt( id );\n\t\t\tconst { reservedIndexCount, reservedVertexCount } = geometryInfo;\n\t\t\tif ( reservedIndexCount >= neededIndexCount && reservedVertexCount >= neededVertexCount ) {\n\n\t\t\t\t// generate score that is a combination of how much unused space a geometry would have if used and pick the\n\t\t\t\t// one with the least amount of unused space.\n\t\t\t\tconst score = ( neededIndexCount - reservedIndexCount ) + ( neededVertexCount - reservedVertexCount );\n\t\t\t\tif ( score < bestScore ) {\n\n\t\t\t\t\tbestIndex = i;\n\t\t\t\t\tbestScore = score;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( bestIndex !== - 1 ) {\n\n\t\t\t// remove the id from the array\n\t\t\tconst id = freeGeometryIds[ bestIndex ];\n\t\t\tfreeGeometryIds.splice( bestIndex, 1 );\n\n\t\t\treturn id;\n\n\t\t} else {\n\n\t\t\treturn - 1;\n\n\t\t}\n\n\t}\n\n\t// Overrides addGeometry to find an option geometry slot, expand, or optimized if needed\n\taddGeometry( geometry, reservedVertexRange, reservedIndexRange ) {\n\n\t\t// expand the reserved range to what geometry needs since add geometry will throw an error otherwise\n\t\tconst needsIndex = Boolean( this.geometry.index );\n\t\treservedIndexRange = Math.max( needsIndex ? geometry.index.count : - 1, reservedIndexRange );\n\t\treservedVertexRange = Math.max( geometry.attributes.position.count, reservedVertexRange );\n\n\t\tconst { expandPercent, _freeGeometryIds } = this;\n\t\tlet resultId = this.findFreeId( geometry, reservedVertexRange, reservedIndexRange );\n\t\tif ( resultId !== - 1 ) {\n\n\t\t\t// insert the geometry in the found empty space\n\t\t\tthis.setGeometryAt( resultId, geometry );\n\n\t\t} else {\n\n\t\t\tconst needsMoreSpace = () => {\n\n\t\t\t\tconst vertexNeedsSpace = this.unusedVertexCount < reservedVertexRange;\n\t\t\t\tconst indexNeedsSpace = this.unusedIndexCount < reservedIndexRange;\n\t\t\t\treturn vertexNeedsSpace || indexNeedsSpace;\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\treservedVertexRange = Math.max( reservedVertexRange, position.count );\n\t\t\treservedIndexRange = Math.max( reservedIndexRange, index ? index.count : 0 );\n\n\t\t\tif ( needsMoreSpace() ) {\n\n\t\t\t\t// shift all the unused geometries to try to make space\n\t\t\t\t_freeGeometryIds.forEach( id => this.deleteGeometry( id ) );\n\t\t\t\t_freeGeometryIds.length = 0;\n\n\t\t\t\tthis.optimize();\n\n\t\t\t\tif ( needsMoreSpace() ) {\n\n\t\t\t\t\t// lastly try to expand the batched mesh size so the new geometry fits\n\n\t\t\t\t\tconst batchedIndex = this.geometry.index;\n\t\t\t\t\tconst batchedPosition = this.geometry.attributes.position;\n\n\t\t\t\t\t// compute the new geometry size to expand to accounting for the case where the geometry is not initialized\n\t\t\t\t\tlet newIndexCount, newVertexCount;\n\t\t\t\t\tif ( batchedIndex ) {\n\n\t\t\t\t\t\tconst addIndexCount = Math.ceil( expandPercent * batchedIndex.count );\n\t\t\t\t\t\tnewIndexCount = Math.max( addIndexCount, reservedIndexRange, index.count ) + batchedIndex.count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndexCount = Math.max( this.unusedIndexCount, reservedIndexRange );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( batchedPosition ) {\n\n\t\t\t\t\t\tconst addVertexCount = Math.ceil( expandPercent * batchedPosition.count );\n\t\t\t\t\t\tnewVertexCount = Math.max( addVertexCount, reservedVertexRange, position.count ) + batchedPosition.count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewVertexCount = Math.max( this.unusedVertexCount, reservedVertexRange );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setGeometrySize( newVertexCount, newIndexCount );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresultId = super.addGeometry( geometry, reservedVertexRange, reservedIndexRange );\n\n\t\t}\n\n\t\treturn resultId;\n\n\t}\n\n\t// add an instance and automatically expand the number of instances if necessary\n\taddInstance( geometryId ) {\n\n\t\tif ( this.maxInstanceCount === this.instanceCount ) {\n\n\t\t\tconst newCount = Math.ceil( this.maxInstanceCount * ( 1 + this.expandPercent ) );\n\t\t\tthis.setInstanceCount( Math.min( newCount, this.maxInstanceExpansionSize ) );\n\n\t\t}\n\n\t\treturn super.addInstance( geometryId );\n\n\t}\n\n\t// delete an instance, keeping note that the geometry id is now unused\n\tdeleteInstance( instanceId ) {\n\n\t\tconst geometryId = this.getGeometryIdAt( instanceId );\n\t\tif ( geometryId !== - 1 ) {\n\n\t\t\tthis._freeGeometryIds.push( geometryId );\n\n\t\t}\n\n\t\treturn super.deleteInstance( instanceId );\n\n\t}\n\n\t// add a function for raycasting per tile\n\traycastInstance( instanceId, raycaster, intersects ) {\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst geometryId = this.getGeometryIdAt( instanceId );\n\n\t\t// initialize the mesh\n\t\t_raycastMesh.material = this.material;\n\t\t_raycastMesh.geometry.index = batchGeometry.index;\n\t\t_raycastMesh.geometry.attributes = batchGeometry.attributes;\n\n\t\t// initialize the geometry\n\t\tconst drawRange = this.getGeometryRangeAt( geometryId );\n\t\t_raycastMesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\t\tif ( _raycastMesh.geometry.boundingBox === null ) {\n\n\t\t\t_raycastMesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _raycastMesh.geometry.boundingSphere === null ) {\n\n\t\t\t_raycastMesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\t// get the intersects\n\t\tthis.getMatrixAt( instanceId, _raycastMesh.matrixWorld ).premultiply( this.matrixWorld );\n\t\tthis.getBoundingBoxAt( geometryId, _raycastMesh.geometry.boundingBox );\n\t\tthis.getBoundingSphereAt( geometryId, _raycastMesh.geometry.boundingSphere );\n\t\t_raycastMesh.raycast( raycaster, _batchIntersects );\n\n\t\t// add batch id to the intersects\n\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\tintersect.object = this;\n\t\t\tintersect.batchId = instanceId;\n\t\t\tintersects.push( intersect );\n\n\t\t}\n\n\t\t_batchIntersects.length = 0;\n\n\t}\n\n}\n","// Returns whether the passed color is white or not\nexport function isColorWhite( color ) {\n\n\treturn color.r === 1 && color.g === 1 && color.b === 1;\n\n}\n\n// Adjusts the given material to take an ArrayTexture for a map\nexport function convertMapToArrayTexture( material ) {\n\n\tmaterial.needsUpdate = true;\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tshader.vertexShader = shader.vertexShader\n\t\t\t.replace(\n\t\t\t\t'#include <common>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#include <common>\n\t\t\t\tvarying float texture_index;\n\t\t\t\t`,\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\t'#include <uv_vertex>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#include <uv_vertex>\n\t\t\t\ttexture_index = getIndirectIndex( gl_DrawID );\n\t\t\t\t`,\n\t\t\t);\n\n\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t.replace(\n\t\t\t\t'#include <map_pars_fragment>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#ifdef USE_MAP\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tuniform sampler2DArray map;\n\t\t\t\tvarying float texture_index;\n\t\t\t\t#endif\n\t\t\t\t`,\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\t'#include <map_fragment>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#ifdef USE_MAP\n\t\t\t\t\tdiffuseColor *= texture( map, vec3( vMapUv, texture_index ) );\n\t\t\t\t#endif\n\t\t\t\t`\n\t\t\t);\n\n\t};\n\n}\n","import { WebGLArrayRenderTarget, MeshBasicMaterial, DataTexture, REVISION } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { ExpandingBatchedMesh } from './ExpandingBatchedMesh.js';\nimport { convertMapToArrayTexture, isColorWhite } from './utilities.js';\n\nconst _textureRenderQuad = new FullScreenQuad( new MeshBasicMaterial() );\nconst _whiteTex = new DataTexture( new Uint8Array( [ 255, 255, 255, 255 ] ), 1, 1 );\n_whiteTex.needsUpdate = true;\n\nexport class BatchedTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( parseInt( REVISION ) < 170 ) {\n\n\t\t\tthrow new Error( 'BatchedTilesPlugin: Three.js revision 170 or higher required.' );\n\n\t\t}\n\n\t\toptions = {\n\t\t\tinstanceCount: 500,\n\t\t\tvertexCount: 750,\n\t\t\tindexCount: 2000,\n\t\t\texpandPercent: 0.25,\n\t\t\tmaxInstanceCount: Infinity,\n\t\t\tdiscardOriginalContent: true,\n\t\t\ttextureSize: null,\n\n\t\t\tmaterial: null,\n\t\t\trenderer: null,\n\t\t\t...options\n\t\t};\n\n\t\tthis.name = 'BATCHED_TILES_PLUGIN';\n\t\tthis.priority = - 1;\n\n\t\t// limit the amount of instances to the size of a 3d texture to avoid over flowing the\n\t\tconst gl = options.renderer.getContext();\n\n\t\t// save options\n\t\tthis.instanceCount = options.instanceCount;\n\t\tthis.vertexCount = options.vertexCount;\n\t\tthis.indexCount = options.indexCount;\n\t\tthis.material = options.material ? options.material.clone() : null;\n\t\tthis.expandPercent = options.expandPercent;\n\t\tthis.maxInstanceCount = Math.min( options.maxInstanceCount, gl.getParameter( gl.MAX_3D_TEXTURE_SIZE ) );\n\t\tthis.renderer = options.renderer;\n\t\tthis.discardOriginalContent = options.discardOriginalContent;\n\t\tthis.textureSize = options.textureSize;\n\n\t\t// local variables\n\t\tthis.batchedMesh = null;\n\t\tthis.arrayTarget = null;\n\t\tthis.tiles = null;\n\t\tthis._onLoadModel = null;\n\t\tthis._onDisposeModel = null;\n\t\tthis._onVisibilityChange = null;\n\t\tthis._tileToInstanceId = new Map();\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis._onDisposeModel = ( { scene, tile } ) => {\n\n\t\t\tthis.removeSceneFromBatchedMesh( scene, tile );\n\n\t\t};\n\n\t\t// register events\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModel );\n\t\tthis.tiles = tiles;\n\n\t}\n\n\tinitTextureArray( target ) {\n\n\t\tif ( this.arrayTarget !== null || target.material.map === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { instanceCount, renderer, textureSize, batchedMesh } = this;\n\n\t\t// init the array texture render target\n\t\tconst map = target.material.map;\n\t\tconst textureOptions = {\n\t\t\tcolorSpace: map.colorSpace,\n\t\t\twrapS: map.wrapS,\n\t\t\twrapT: map.wrapT,\n\t\t\twrapR: map.wrapS,\n\t\t\t// TODO: Generating mipmaps for the volume every time a new texture is added is extremely slow\n\t\t\t// generateMipmaps: map.generateMipmaps,\n\t\t\t// minFilter: map.minFilter,\n\t\t\tmagFilter: map.magFilter,\n\t\t};\n\n\t\tconst arrayTarget = new WebGLArrayRenderTarget( textureSize || map.image.width, textureSize || map.image.height, instanceCount );\n\t\tObject.assign( arrayTarget.texture, textureOptions );\n\t\trenderer.initRenderTarget( arrayTarget );\n\n\t\t// assign the material\n\t\tbatchedMesh.material.map = arrayTarget.texture;\n\n\t\tthis.arrayTarget = arrayTarget;\n\n\t\t// once the texture array is initialized we fill in textures for all previously-initialized instances\n\t\t// since they may have been skipped due to not having textures\n\t\tthis._tileToInstanceId.forEach( value => {\n\n\t\t\tvalue.forEach( id => {\n\n\t\t\t\tthis.assignTextureToLayer( _whiteTex, id );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t// init the batched mesh if it's not ready\n\tinitBatchedMesh( target ) {\n\n\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// init the batched mesh\n\t\tconst { instanceCount, vertexCount, indexCount, tiles } = this;\n\t\tconst material = this.material ? this.material : new target.material.constructor();\n\t\tconst batchedMesh = new ExpandingBatchedMesh( instanceCount, instanceCount * vertexCount, instanceCount * indexCount, material );\n\t\tbatchedMesh.name = 'BatchTilesPlugin';\n\t\tbatchedMesh.frustumCulled = false;\n\t\ttiles.group.add( batchedMesh );\n\t\tbatchedMesh.updateMatrixWorld();\n\n\t\tconvertMapToArrayTexture( batchedMesh.material );\n\n\t\tthis.batchedMesh = batchedMesh;\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.cached.scene;\n\t\tif ( visible ) {\n\n\t\t\t// Add tileset to the batched mesh if it hasn't been added already\n\t\t\tthis.addSceneToBatchedMesh( scene, tile );\n\n\t\t}\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\t\tthis.batchedMesh.setVisibleAt( instanceId, visible );\n\n\t\t\t} );\n\n\t\t\t// TODO: this should be handled by the base tiles renderer\n\t\t\tconst tiles = this.tiles;\n\t\t\tif ( visible ) {\n\n\t\t\t\ttiles.visibleTiles.add( tile );\n\n\t\t\t} else {\n\n\t\t\t\ttiles.visibleTiles.delete( tile );\n\n\t\t\t}\n\n\t\t\t// dispatch the event that is blocked otherwise\n\t\t\ttiles.dispatchEvent( {\n\t\t\t\ttype: 'tile-visibility-change',\n\t\t\t\tscene,\n\t\t\t\ttile,\n\t\t\t\tvisible,\n\t\t\t} );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tunloadTileFromGPU( scene, tile ) {\n\n\t\tif ( ! this.discardOriginalContent && this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tthis.removeSceneFromBatchedMesh( scene, tile );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// render the given into the given layer\n\tassignTextureToLayer( texture, layer ) {\n\n\t\t// if the array target has not been created yet then skip the assignment and expansion\n\t\tif ( ! this.arrayTarget ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.expandArrayTargetIfNeeded();\n\n\t\tconst { renderer } = this;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t// render the layer\n\t\trenderer.setRenderTarget( this.arrayTarget, layer );\n\t\t_textureRenderQuad.material.map = texture;\n\t\t_textureRenderQuad.render( renderer );\n\n\t\t// TODO: perform a copy if the texture is already the appropriate size\n\n\t\t// reset state\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\t_textureRenderQuad.material.map = null;\n\t\ttexture.dispose();\n\n\t}\n\n\t// check if the array texture target needs to be expanded\n\texpandArrayTargetIfNeeded() {\n\n\t\tconst { batchedMesh, arrayTarget, renderer } = this;\n\t\tconst targetDepth = Math.min( batchedMesh.maxInstanceCount, this.maxInstanceCount );\n\t\tif ( targetDepth > arrayTarget.depth ) {\n\n\t\t\t// create a new array texture target\n\t\t\tconst textureOptions = {\n\t\t\t\tcolorSpace: arrayTarget.texture.colorSpace,\n\t\t\t\twrapS: arrayTarget.texture.wrapS,\n\t\t\t\twrapT: arrayTarget.texture.wrapT,\n\t\t\t\tgenerateMipmaps: arrayTarget.texture.generateMipmaps,\n\t\t\t\tminFilter: arrayTarget.texture.minFilter,\n\t\t\t\tmagFilter: arrayTarget.texture.magFilter,\n\t\t\t};\n\n\t\t\tconst newArrayTarget = new WebGLArrayRenderTarget( arrayTarget.width, arrayTarget.height, targetDepth );\n\t\t\tObject.assign( newArrayTarget.texture, textureOptions );\n\n\t\t\t// copy the contents\n\t\t\trenderer.initRenderTarget( newArrayTarget );\n\t\t\trenderer.copyTextureToTexture( arrayTarget.texture, newArrayTarget.texture );\n\n\t\t\t// replace the old array target\n\t\t\tarrayTarget.dispose();\n\t\t\tbatchedMesh.material.map = newArrayTarget.texture;\n\t\t\tthis.arrayTarget = newArrayTarget;\n\n\t\t}\n\n\t}\n\n\tremoveSceneFromBatchedMesh( scene, tile ) {\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\t\tthis._tileToInstanceId.delete( tile );\n\t\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\t\tthis.batchedMesh.deleteInstance( instanceId );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\taddSceneToBatchedMesh( scene, tile ) {\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// find the meshes in the scene\n\t\tconst meshes = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// don't add the geometry if it doesn't have the right attributes\n\t\tlet hasCorrectAttributes = true;\n\t\tmeshes.forEach( mesh => {\n\n\t\t\tif ( this.batchedMesh && hasCorrectAttributes ) {\n\n\t\t\t\tconst attrs = mesh.geometry.attributes;\n\t\t\t\tconst batchedAttrs = this.batchedMesh.geometry.attributes;\n\t\t\t\tfor ( const key in batchedAttrs ) {\n\n\t\t\t\t\tif ( ! ( key in attrs ) ) {\n\n\t\t\t\t\t\thasCorrectAttributes = false;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst canAddMeshes = ! this.batchedMesh || this.batchedMesh.instanceCount + meshes.length <= this.maxInstanceCount;\n\t\tif ( hasCorrectAttributes && canAddMeshes ) {\n\n\t\t\tscene.updateMatrixWorld();\n\n\t\t\tconst instanceIds = [];\n\t\t\tthis._tileToInstanceId.set( tile, instanceIds );\n\n\t\t\tmeshes.forEach( mesh => {\n\n\t\t\t\tthis.initBatchedMesh( mesh );\n\t\t\t\tthis.initTextureArray( mesh );\n\n\t\t\t\tconst { geometry, material } = mesh;\n\t\t\t\tconst { batchedMesh, expandPercent } = this;\n\n\t\t\t\t// assign expandPercent in case it has changed\n\t\t\t\tbatchedMesh.expandPercent = expandPercent;\n\n\t\t\t\tconst geometryId = batchedMesh.addGeometry( geometry, this.vertexCount, this.indexCount );\n\t\t\t\tconst instanceId = batchedMesh.addInstance( geometryId );\n\t\t\t\tinstanceIds.push( instanceId );\n\t\t\t\tbatchedMesh.setMatrixAt( instanceId, mesh.matrixWorld );\n\t\t\t\tbatchedMesh.setVisibleAt( instanceId, false );\n\t\t\t\tif ( ! isColorWhite( material.color ) ) {\n\n\t\t\t\t\tmaterial.color.setHSL( Math.random(), 0.5, 0.5 );\n\t\t\t\t\tbatchedMesh.setColorAt( instanceId, material.color );\n\n\t\t\t\t}\n\n\t\t\t\t// render the material\n\t\t\t\tconst texture = material.map;\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\tthis.assignTextureToLayer( texture, instanceId );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.assignTextureToLayer( _whiteTex, instanceId );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\n\t\t\t// discard all data if the option is set\n\t\t\t// TODO: this would be best done in a more general way\n\t\t\tif ( this.discardOriginalContent ) {\n\n\t\t\t\ttile.cached.textures.forEach( tex => {\n\n\t\t\t\t\tif ( tex.image instanceof ImageBitmap ) {\n\n\t\t\t\t\t\ttex.image.close();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\ttile.cached.scene = null;\n\t\t\t\ttile.cached.materials = [];\n\t\t\t\ttile.cached.geometries = [];\n\t\t\t\ttile.cached.textures = [];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Override raycasting per tile to defer to the batched mesh\n\traycastTile( tile, scene, raycaster, intersects ) {\n\n\t\tif ( ! this._tileToInstanceId.has( tile ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\tthis.batchedMesh.raycastInstance( instanceId, raycaster, intersects );\n\n\t\t} );\n\n\t\treturn true;\n\n\t}\n\n\tdispose() {\n\n\t\tconst { arrayTarget, tiles, batchedMesh } = this;\n\t\tif ( arrayTarget ) {\n\n\t\t\tarrayTarget.dispose();\n\n\t\t}\n\n\t\tif ( batchedMesh ) {\n\n\t\t\tbatchedMesh.material.dispose();\n\t\t\tbatchedMesh.geometry.dispose();\n\t\t\tbatchedMesh.dispose();\n\t\t\tbatchedMesh.removeFromParent();\n\n\t\t}\n\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModel );\n\n\t}\n\n\tgetTileBatchIds( tile ) {\n\n\t\treturn this._tileToInstanceId.get( tile );\n\n\t}\n\n}\n","import { Box3, DoubleSide, MathUtils, Matrix4, MeshBasicMaterial, Raycaster, Sphere, Vector3 } from 'three';\n\n// Limitations:\n// - No support for BatchedTilesPlugin when resetting or modifying geometry\n// - Sharing geometry between models may result in incorrect flattening\n\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _raycaster = /* @__PURE__ */ new Raycaster();\nconst _doubleSidedMaterial = /* @__PURE__ */ new MeshBasicMaterial( { side: DoubleSide } );\nconst _box = /* @__PURE__ */ new Box3();\nconst RAYCAST_DISTANCE = 1e5;\n\nfunction calculateSphere( object, target ) {\n\n\tif ( object.isBufferGeometry ) {\n\n\t\tif ( object.boundingSphere === null ) {\n\n\t\t\tobject.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn target.copy( object.boundingSphere );\n\n\t} else {\n\n\t\t_box.setFromObject( object );\n\t\t_box.getBoundingSphere( target );\n\t\treturn target;\n\n\t}\n\n}\n\nexport class TileFlatteningPlugin {\n\n\tconstructor() {\n\n\t\tthis.name = 'TILE_FLATTENING_PLUGIN';\n\t\tthis.priority = - 100;\n\n\t\tthis.tiles = null;\n\t\tthis.shapes = new Map();\n\t\tthis.positionsMap = new Map();\n\t\tthis.positionsUpdated = new Set();\n\t\tthis.needsUpdate = false;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\t\tthis.needsUpdate = true;\n\n\t\tthis._updateBeforeCallback = () => {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis._updateTiles();\n\t\t\t\tthis.needsUpdate = false;\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._disposeModelCallback = ( { tile } ) => {\n\n\t\t\tthis.positionsMap.delete( tile );\n\t\t\tthis.positionsUpdated.delete( tile );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'update-before', this._updateBeforeCallback );\n\t\ttiles.addEventListener( 'dispose-model', this._disposeModelCallback );\n\n\t}\n\n\t// update tile flattening state if it has not been made visible, yet\n\tsetTileActive( tile, active ) {\n\n\t\tif ( active && ! this.positionsUpdated.has( tile ) ) {\n\n\t\t\tthis._updateTile( tile );\n\n\t\t}\n\n\t}\n\n\t_updateTile( tile ) {\n\n\t\tconst { positionsUpdated, positionsMap, shapes, tiles } = this;\n\t\tpositionsUpdated.add( tile );\n\n\t\tconst scene = tile.cached.scene;\n\t\tif ( ! positionsMap.has( tile ) ) {\n\n\t\t\t// save the geometry positions for resetting after\n\t\t\tconst geomMap = new Map();\n\t\t\tpositionsMap.set( tile, geomMap );\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.geometry ) {\n\n\t\t\t\t\tgeomMap.set( c.geometry, c.geometry.attributes.position.array.slice() );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\t// reset the geometry state before re-flattening tiles\n\t\t\tconst geomMap = positionsMap.get( tile );\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.geometry ) {\n\n\t\t\t\t\tconst buffer = geomMap.get( c.geometry );\n\t\t\t\t\tif ( buffer ) {\n\n\t\t\t\t\t\tc.geometry.attributes.position.array.set( buffer );\n\t\t\t\t\t\tc.geometry.attributes.position.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// TODO: if we save the sphere of the original mesh we can check the height to limit the tiles checked\n\t\t// TODO: we should use the tile bounding volume sphere if present\n\t\tscene.updateMatrixWorld( true );\n\n\t\t// iterate over every geometry\n\t\tscene.traverse( c => {\n\n\t\t\tconst { geometry } = c;\n\n\t\t\tif ( ! geometry ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// calculate matrices\n\t\t\t_matrix.copy( c.matrixWorld );\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.premultiply( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t_invMatrix.copy( _matrix ).invert();\n\n\t\t\t// calculate sphere for mesh\n\t\t\tcalculateSphere( geometry, _sphere ).applyMatrix4( _matrix );\n\n\t\t\t// iterate over each shape\n\t\t\tshapes.forEach( ( {\n\t\t\t\tshape,\n\t\t\t\tdirection,\n\t\t\t\tsphere,\n\n\t\t\t\tthresholdMode,\n\t\t\t\tthreshold,\n\t\t\t\tflattenRange,\n\t\t\t} ) => {\n\n\t\t\t\t// check if the spheres overlap so there may actually be potential of geometry overlap\n\t\t\t\t_vec.subVectors( _sphere.center, sphere.center );\n\t\t\t\t_vec.addScaledVector( direction, - direction.dot( _vec ) );\n\n\t\t\t\tconst r2 = ( _sphere.radius + sphere.radius ) ** 2;\n\t\t\t\tif ( _vec.lengthSq() > r2 ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every vertex position\n\t\t\t\tconst { position } = geometry.attributes;\n\t\t\t\tconst { ray } = _raycaster;\n\t\t\t\tray.direction.copy( direction ).multiplyScalar( - 1 );\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\tray.origin\n\t\t\t\t\t\t.fromBufferAttribute( position, i )\n\t\t\t\t\t\t.applyMatrix4( _matrix )\n\t\t\t\t\t\t.addScaledVector( direction, RAYCAST_DISTANCE );\n\t\t\t\t\t_raycaster.far = RAYCAST_DISTANCE;\n\n\t\t\t\t\tconst hit = _raycaster.intersectObject( shape )[ 0 ];\n\t\t\t\t\tif ( hit ) {\n\n\t\t\t\t\t\tlet rangeAlpha = ( RAYCAST_DISTANCE - hit.distance ) / threshold;\n\t\t\t\t\t\tconst aboveThreshold = rangeAlpha >= 1;\n\t\t\t\t\t\tif ( ! aboveThreshold || aboveThreshold && thresholdMode === 'flatten' ) {\n\n\t\t\t\t\t\t\trangeAlpha = Math.min( rangeAlpha, 1.0 );\n\n\t\t\t\t\t\t\thit.point.addScaledVector( ray.direction, MathUtils.mapLinear( rangeAlpha, 0, 1, - flattenRange, 0 ) );\n\t\t\t\t\t\t\thit.point.applyMatrix4( _invMatrix );\n\t\t\t\t\t\t\tposition.setXYZ( i, ...hit.point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\n\t\tthis.tiles.dispatchEvent( { type: 'needs-render' } );\n\n\t}\n\n\t_updateTiles() {\n\n\t\tthis.positionsUpdated.clear();\n\t\tthis.tiles.activeTiles.forEach( tile => this._updateTile( tile ) );\n\n\t}\n\n\t// API for updating and shapes to flatten the vertices\n\thasShape( mesh ) {\n\n\t\treturn this.shapes.has( mesh );\n\n\t}\n\n\taddShape( mesh, direction = new Vector3( 0, 0, - 1 ), options = {} ) {\n\n\t\tif ( this.hasShape( mesh ) ) {\n\n\t\t\tthrow new Error( 'TileFlatteningPlugin: Shape is already used.' );\n\n\t\t}\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'TileFlatteningPlugin: \"addShape\" function signature has changed. Please use an options object, instead.' );\n\t\t\toptions = {\n\t\t\t\tthreshold: options,\n\t\t\t};\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t\tconst shape = mesh.clone();\n\t\tshape.updateMatrixWorld( true );\n\t\tshape.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tc.material = _doubleSidedMaterial;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst sphere = calculateSphere( shape, new Sphere() );\n\t\tthis.shapes.set( mesh, {\n\t\t\tshape: shape,\n\t\t\tdirection: direction.clone(),\n\t\t\tsphere: sphere,\n\n\t\t\t// \"flatten\": Flattens the vertices above the shape\n\t\t\t// \"none\": leaves the vertices above the shape as they are\n\t\t\tthresholdMode: 'none',\n\n\t\t\t// only flatten within this range above the object\n\t\t\tthreshold: Infinity,\n\n\t\t\t// the range to flatten vertices in to. 0 is completely flat\n\t\t\t// while 0.1 means a 10cm range.\n\t\t\tflattenRange: 0,\n\n\t\t\t...options,\n\t\t} );\n\n\t}\n\n\tupdateShape( mesh ) {\n\n\t\tif ( ! this.hasShape( mesh ) ) {\n\n\t\t\tthrow new Error( 'TileFlatteningPlugin: Shape is not present.' );\n\n\t\t}\n\n\t\tconst { direction, threshold, thresholdMode, flattenRange } = this.shapes.get( mesh );\n\t\tthis.deleteShape( mesh );\n\t\tthis.addShape( mesh, direction, {\n\t\t\tthreshold,\n\t\t\tthresholdMode,\n\t\t\tflattenRange,\n\t\t} );\n\n\t}\n\n\tdeleteShape( mesh ) {\n\n\t\tthis.needsUpdate = true;\n\t\treturn this.shapes.delete( mesh );\n\n\t}\n\n\tclearShapes() {\n\n\t\tif ( this.shapes.size === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\t\tthis.shapes.clear();\n\n\t}\n\n\t// reset the vertex positions and remove the update callback\n\tdispose() {\n\n\t\tthis.tiles.removeEventListener( 'before-update', this._updateBeforeCallback );\n\t\tthis.tiles.removeEventListener( 'dispose-model', this._disposeModelCallback );\n\n\t\tthis.positionsMap.forEach( geomMap => {\n\n\t\t\tgeomMap.forEach( ( buffer, geometry ) => {\n\n\t\t\t\tconst { position } = geometry.attributes;\n\t\t\t\tposition.array.set( buffer );\n\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n","import { ShaderMaterial, MathUtils, Vector2, PlaneGeometry, OrthographicCamera, Mesh, Color, DoubleSide } from 'three';\n\nconst _camera = /* @__PURE__ */ new OrthographicCamera();\nconst _color = /* @__PURE__ */ new Color();\n\n// Utility for composing a series of tiled textures together onto a target texture in a given range\nexport class TiledTextureComposer {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.renderTarget = null;\n\t\tthis.range = [ 0, 0, 1, 1 ];\n\t\tthis.quad = new Mesh( new PlaneGeometry(), new ComposeTextureMaterial() );\n\n\t}\n\n\t// set the target render texture and the range that represents the full span\n\tsetRenderTarget( renderTarget, range ) {\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.range = [ ...range ];\n\n\t}\n\n\t// draw the given texture at the given span with the provided projection\n\tdraw( texture, span ) {\n\n\t\t// draw the texture at the given sub range\n\t\tconst { range, renderer, quad, renderTarget } = this;\n\t\tconst material = quad.material;\n\t\tmaterial.map = texture;\n\n\t\t// map the range to draw the texture to\n\t\tmaterial.minRange.x = MathUtils.mapLinear( span[ 0 ], range[ 0 ], range[ 2 ], - 1, 1 );\n\t\tmaterial.minRange.y = MathUtils.mapLinear( span[ 1 ], range[ 1 ], range[ 3 ], - 1, 1 );\n\n\t\tmaterial.maxRange.x = MathUtils.mapLinear( span[ 2 ], range[ 0 ], range[ 2 ], - 1, 1 );\n\t\tmaterial.maxRange.y = MathUtils.mapLinear( span[ 3 ], range[ 1 ], range[ 3 ], - 1, 1 );\n\n\t\t// draw the texture\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.render( quad, _camera );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\tmaterial.map = null;\n\n\t}\n\n\t// clear the set target\n\tclear( color, alpha = 1 ) {\n\n\t\t// clear the texture\n\t\tconst { renderer, renderTarget } = this;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentClearColor = renderer.getClearColor( _color );\n\t\tconst currentClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.setClearColor( color, alpha );\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.clear();\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setClearColor( currentClearColor, currentClearAlpha );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.quad.material.dispose();\n\t\tthis.quad.geometry.dispose();\n\n\t}\n\n}\n\n// Draws the given texture with no depth testing at the given bounds defined by \"minRange\" and \"maxRange\"\nclass ComposeTextureMaterial extends ShaderMaterial {\n\n\t// the [ - 1, 1 ] NDC ranges to draw the texture at\n\tget minRange() {\n\n\t\treturn this.uniforms.minRange.value;\n\n\t}\n\n\tget maxRange() {\n\n\t\treturn this.uniforms.maxRange.value;\n\n\t}\n\n\t// access the map being drawn\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( {\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: false,\n\t\t\tside: DoubleSide,\n\t\t\tpremultipliedAlpha: true,\n\t\t\tuniforms: {\n\t\t\t\tmap: { value: null },\n\n\t\t\t\t// the normalized [0, 1] range of the target to draw to\n\t\t\t\tminRange: { value: new Vector2() },\n\t\t\t\tmaxRange: { value: new Vector2() },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tuniform vec2 minRange;\n\t\t\t\tuniform vec2 maxRange;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = vec4( mix( minRange, maxRange, uv ), 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform vec2 minRange;\n\t\t\t\tuniform vec2 maxRange;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// sample the texture\n\t\t\t\t\tgl_FragColor = texture( map, vUv );\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\n\t\t\t`,\n\t\t} );\n\n\n\t}\n\n}\n","import { XYZImageSource } from './XYZImageSource.js';\n\n// Bing Maps Tile System\n// https://learn.microsoft.com/en-us/bingmaps/articles/bing-maps-tile-system\nexport class QuadKeyImageSource extends XYZImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tsubdomains = [ 't0' ],\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.subdomains = subdomains;\n\t\tthis.subDomainIndex = 0;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.url\n\t\t\t.replace( /{\\s*subdomain\\s*}/gi, this._getSubdomain() )\n\t\t\t.replace( /{\\s*quadkey\\s*}/gi, this._tileToQuadKey( x, y, level ) );\n\n\t}\n\n\t_tileToQuadKey( x, y, level ) {\n\n\t\tlet quadKey = '';\n\t\tfor ( let i = level; i > 0; i -- ) {\n\n\t\t\tlet digit = 0;\n\t\t\tconst mask = 1 << ( i - 1 );\n\t\t\tif ( ( x & mask ) !== 0 ) digit += 1;\n\t\t\tif ( ( y & mask ) !== 0 ) digit += 2;\n\t\t\tquadKey += digit.toString();\n\n\t\t}\n\n\t\treturn quadKey;\n\n\t}\n\n\t_getSubdomain() {\n\n\t\t// Spread requests among different subdomains to circumvent browser URL request limits per domain\n\t\t// https://learn.microsoft.com/en-us/bingmaps/rest-services/directly-accessing-the-bing-maps-tiles\n\t\tthis.subDomainIndex = ( this.subDomainIndex + 1 ) % this.subdomains.length;\n\t\treturn this.subdomains[ this.subDomainIndex ];\n\n\t}\n\n}\n","import { Vector3, Matrix4, MathUtils } from 'three';\n\n// iterates over all present tiles in the given tileset at the given level in the given range\nexport function forEachTileInBounds( range, level, tiling, normalized, callback ) {\n\n\t// pull the bounds in a bit to avoid loading unnecessary tiles. 1e-8 was chosen since smaller values\n\t// are not larger enough and cause extra tiles to load in cases where 1-to-1 tile-to-image should occur\n\tlet [ minLon, minLat, maxLon, maxLat ] = range;\n\tminLat += 1e-8;\n\tminLon += 1e-8;\n\tmaxLat -= 1e-8;\n\tmaxLon -= 1e-8;\n\n\tconst clampedLevel = Math.max( Math.min( level, tiling.maxLevel ), tiling.minLevel );\n\tconst [ minX, minY, maxX, maxY ] = tiling.getTilesInRange( minLon, minLat, maxLon, maxLat, clampedLevel, normalized );\n\tfor ( let x = minX; x <= maxX; x ++ ) {\n\n\t\tfor ( let y = minY; y <= maxY; y ++ ) {\n\n\t\t\tcallback( x, y, clampedLevel );\n\n\t\t}\n\n\t}\n\n}\n\n// functions for generating UVs for cartographic-projected UVs\nfunction getGeometryCartographicChannel( geometry, geomToEllipsoidMatrix, ellipsoid ) {\n\n\tconst _vec = new Vector3();\n\tconst _cart = {};\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tgeometry.computeBoundingBox();\n\tgeometry.boundingBox.getCenter( _vec ).applyMatrix4( geomToEllipsoidMatrix );\n\n\t// find a rough mid lat / lon point\n\tellipsoid.getPositionToCartographic( _vec, _cart );\n\tconst centerLat = _cart.lat;\n\tconst centerLon = _cart.lon;\n\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t// get the lat / lon values per vertex\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( geomToEllipsoidMatrix );\n\t\tellipsoid.getPositionToCartographic( _vec, _cart );\n\n\t\t// The latitude calculations are not so stable at the poles so force the lat value to\n\t\t// the mid point to ensure we don't load an unnecessarily large of tiles\n\t\t// NOTE: this can distort the texture a bit at the poles\n\t\tif ( Math.abs( Math.abs( _cart.lat ) - Math.PI / 2 ) < 1e-5 ) {\n\n\t\t\t_cart.lon = centerLon;\n\n\t\t}\n\n\t\t// ensure we're not wrapping on the same geometry\n\t\tif ( Math.abs( centerLon - _cart.lon ) > Math.PI ) {\n\n\t\t\t_cart.lon += Math.sign( centerLon - _cart.lon ) * Math.PI * 2;\n\n\t\t}\n\n\t\tif ( Math.abs( centerLat - _cart.lat ) > Math.PI ) {\n\n\t\t\t_cart.lat += Math.sign( centerLat - _cart.lat ) * Math.PI * 2;\n\n\t\t}\n\n\t\tuv.push( _cart.lon, _cart.lat, _cart.height );\n\n\t\tminLat = Math.min( minLat, _cart.lat );\n\t\tmaxLat = Math.max( maxLat, _cart.lat );\n\n\t\tminLon = Math.min( minLon, _cart.lon );\n\t\tmaxLon = Math.max( maxLon, _cart.lon );\n\n\t\tminHeight = Math.min( minHeight, _cart.height );\n\t\tmaxHeight = Math.max( maxHeight, _cart.height );\n\n\t}\n\n\tconst range = [ minLon, minLat, maxLon, maxLat ];\n\tconst region = [ ...range, minHeight, maxHeight ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\tregion,\n\t};\n\n}\n\nexport function getMeshesCartographicRange( meshes, ellipsoid, meshToEllipsoidMatrix = null, tiling = null ) {\n\n\t// find the lat / lon ranges\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( meshToEllipsoidMatrix ) {\n\n\t\t\t_matrix.premultiply( meshToEllipsoidMatrix );\n\n\t\t}\n\n\t\tconst { uv, region } = getGeometryCartographicChannel( mesh.geometry, _matrix, ellipsoid );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminLat = Math.min( minLat, region[ 1 ] );\n\t\tmaxLat = Math.max( maxLat, region[ 3 ] );\n\n\t\tminLon = Math.min( minLon, region[ 0 ] );\n\t\tmaxLon = Math.max( maxLon, region[ 2 ] );\n\n\t\tminHeight = Math.min( minHeight, region[ 4 ] );\n\t\tmaxHeight = Math.max( maxHeight, region[ 5 ] );\n\n\t} );\n\n\tlet clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\tif ( tiling !== null ) {\n\n\t\t// Clamp the lat lon range to the bounds of the projection scheme. Note that clamping the data\n\t\t// allows for \"stretching\" the texture look at the edges of the projection which leads to a nicer\n\t\t// looking overlay. Eg at the poles of a web-mercator projection - otherwise there will be gaps\n\t\t// that show the underlying tile data. It's arguable which one is better but in all supported\n\t\t// ellipsoid projections (Web mercator, equirect) the projection ranges always span the entire\n\t\t// globe range.\n\t\t// const clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\t\tclampedRange = tiling.clampToProjectionBounds( [ minLon, minLat, maxLon, maxLat ] );\n\t\tconst [ minU, minV, maxU, maxV ] = tiling.toNormalizedRange( clampedRange );\n\t\tuvs.forEach( uv => {\n\n\t\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\t\tconst lon = uv[ i + 0 ];\n\t\t\t\tconst lat = uv[ i + 1 ];\n\t\t\t\tconst h = uv[ i + 2 ];\n\n\t\t\t\tconst [ u, v ] = tiling.toNormalizedPoint( lon, lat );\n\t\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\t\t\t\tuv[ i + 2 ] = MathUtils.mapLinear( h, minHeight, maxHeight, 0, 1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\treturn {\n\t\tuvs,\n\t\trange: clampedRange,\n\t\tregion: [ minLon, minLat, maxLon, maxLat, minHeight, maxHeight ],\n\t};\n\n}\n\n// functions for generating UVs for planar-projected UVs\nfunction getGeometryPlanarChannel( geometry, meshToFrame, aspectRatio ) {\n\n\tconst _vec = new Vector3();\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t// divide U by the aspect to stretch the U dimension to the aspect of the image\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( meshToFrame );\n\t\t_vec.x /= aspectRatio;\n\n\t\tuv.push( _vec.x, _vec.y, _vec.z );\n\n\t\tminU = Math.min( minU, _vec.x );\n\t\tmaxU = Math.max( maxU, _vec.x );\n\n\t\tminV = Math.min( minV, _vec.y );\n\t\tmaxV = Math.max( maxV, _vec.y );\n\n\t\tminW = Math.min( minW, _vec.z );\n\t\tmaxW = Math.max( maxW, _vec.z );\n\n\t}\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\tconst range = [ minU, minV, maxU, maxV ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n\nexport function getMeshesPlanarRange( meshes, worldToFrame, tiling ) {\n\n\t// find the U / V ranges\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( worldToFrame ) {\n\n\t\t\t_matrix.premultiply( worldToFrame );\n\n\t\t}\n\n\t\tconst { uv, range, heightRange } = getGeometryPlanarChannel( mesh.geometry, _matrix, tiling.aspectRatio );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminU = Math.min( minU, range[ 0 ] );\n\t\tmaxU = Math.max( maxU, range[ 2 ] );\n\n\t\tminV = Math.min( minV, range[ 1 ] );\n\t\tmaxV = Math.max( maxV, range[ 3 ] );\n\n\t\tminW = Math.min( minW, heightRange[ 0 ] );\n\t\tmaxW = Math.max( maxW, heightRange[ 1 ] );\n\n\t} );\n\n\tuvs.forEach( uv => {\n\n\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\tconst u = uv[ i + 0 ];\n\t\t\tconst v = uv[ i + 1 ];\n\n\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\n\t\t}\n\n\t} );\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\treturn {\n\t\tuvs,\n\t\trange: [ minU, minV, maxU, maxV ],\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n","const OVERLAY_PARAMS = Symbol( 'OVERLAY_PARAMS' );\n\n// before compile can be used to chain shader adjustments. Returns the added uniforms used for fading.\nexport function wrapOverlaysMaterial( material, previousOnBeforeCompile ) {\n\n\t// if the material has already been wrapped then return the params\n\tif ( material[ OVERLAY_PARAMS ] ) {\n\n\t\treturn material[ OVERLAY_PARAMS ];\n\n\t}\n\n\tconst params = {\n\t\tlayerMaps: { value: [] },\n\t\tlayerInfo: { value: [] },\n\t};\n\n\tmaterial[ OVERLAY_PARAMS ] = params;\n\n\tmaterial.defines = {\n\t\t...( material.defines || {} ),\n\t\tLAYER_COUNT: 0,\n\t};\n\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tif ( previousOnBeforeCompile ) {\n\n\t\t\tpreviousOnBeforeCompile( shader );\n\n\t\t}\n\n\t\tshader.uniforms = {\n\t\t\t...shader.uniforms,\n\t\t\t...params,\n\t\t};\n\n\t\tshader.vertexShader = shader\n\t\t\t.vertexShader\n\t\t\t.replace( /void main\\(\\s*\\)\\s*{/, value => /* glsl */`\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tattribute vec3 layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tv_layer_uv_UNROLLED_LOOP_INDEX = layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t` );\n\n\t\tshader.fragmentShader = shader\n\t\t\t.fragmentShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t\tstruct LayerInfo {\n\t\t\t\t\t\tvec3 color;\n\t\t\t\t\t\tfloat opacity;\n\n\t\t\t\t\t\tint alphaMask;\n\t\t\t\t\t\tint alphaInvert;\n\t\t\t\t\t};\n\n\t\t\t\t\tuniform sampler2D layerMaps[ LAYER_COUNT ];\n\t\t\t\t\tuniform LayerInfo layerInfo[ LAYER_COUNT ];\n\t\t\t\t#endif\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t` )\n\t\t\t.replace( /#include <color_fragment>/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t{\n\t\t\t\t\tvec4 tint;\n\t\t\t\t\tvec3 layerUV;\n\t\t\t\t\tfloat layerOpacity;\n\t\t\t\t\tfloat wOpacity;\n\t\t\t\t\tfloat wDelta;\n\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\t\tlayerUV = v_layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\t\ttint = texture( layerMaps[ i ], layerUV.xy );\n\n\t\t\t\t\t\t\t\t// discard texture outside 0, 1 on w - offset the stepped value by an epsilon to avoid cases\n\t\t\t\t\t\t\t\t// where wDelta is near 0 (eg a flat surface) at the w boundary, resulting in artifacts on some\n\t\t\t\t\t\t\t\t// hardware.\n\t\t\t\t\t\t\t\twDelta = max( fwidth( layerUV.z ), 1e-7 );\n\t\t\t\t\t\t\t\twOpacity =\n\t\t\t\t\t\t\t\t\tsmoothstep( - wDelta, 0.0, layerUV.z ) *\n\t\t\t\t\t\t\t\t\tsmoothstep( 1.0 + wDelta, 1.0, layerUV.z );\n\n\t\t\t\t\t\t\t\t// apply tint & opacity\n\t\t\t\t\t\t\t\ttint.rgb *= layerInfo[ i ].color;\n\t\t\t\t\t\t\t\ttint.rgba *= layerInfo[ i ].opacity * wOpacity;\n\n\t\t\t\t\t\t\t\t// invert the alpha\n\t\t\t\t\t\t\t\tif ( layerInfo[ i ].alphaInvert > 0 ) {\n\n\t\t\t\t\t\t\t\t\ttint.a = 1.0 - tint.a;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// apply the alpha across all existing layers if alpha mask is true\n\t\t\t\t\t\t\t\tif ( layerInfo[ i ].alphaMask > 0 ) {\n\n\t\t\t\t\t\t\t\t\tdiffuseColor.a *= tint.a;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// premultiplied alpha equation\n\t\t\t\t\t\t\t\t\tdiffuseColor = tint + diffuseColor * ( 1.0 - tint.a );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t}\n\t\t\t\t\t#pragma unroll_loop_end\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t` );\n\n\t};\n\n\treturn params;\n\n}\n","import { CanvasTexture, MathUtils, Vector3 } from 'three';\nimport { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { WGS84_ELLIPSOID } from '3d-tiles-renderer/three';\n\n// TODO: Add support for limited bounds\n// TODO: Add support for padding of tiles to avoid clipping \"wide\" elements\n// TODO: Need to clip / fix geojson shapes across the 180 degree boundary\n// TODO: Add support for easy regeneration when colors / styles / geojson change\n// TODO: Consider option to support world-space thickness definitions. Eg world-space point size or line thickness in meters.\n\n// function for calculating the the change in arc length at a given cartographic point\n// in order to preserve a circular look when drawing points\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\nfunction calculateArcRatioAtPoint( ellipsoid, lat, lon ) {\n\n\tconst DELTA = 0.01;\n\tellipsoid.getCartographicToPosition( lat, lon, 0, _v0 );\n\tellipsoid.getCartographicToPosition( lat + DELTA, lon, 0, _v1 );\n\n\tconst latDelta = _v0.distanceTo( _v1 );\n\tellipsoid.getCartographicToPosition( lat, lon + DELTA, 0, _v1 );\n\n\tconst lonDelta = _v0.distanceTo( _v1 );\n\treturn lonDelta / latDelta;\n\n}\n\nexport class GeoJSONImageSource extends TiledImageSource {\n\n\tconstructor( {\n\t\tgeojson = null,\n\t\turl = null, // URL or GeoJson object can be provided\n\t\ttileDimension = 256,\n\t\tlevels = 20,\n\t\tpointRadius = 6,\n\t\tstrokeStyle = 'white',\n\t\tstrokeWidth = 2,\n\t\tfillStyle = 'rgba( 255, 255, 255, 0.5 )',\n\t\t...rest\n\t} = {} ) {\n\n\t\tsuper( rest );\n\t\tthis.geojson = geojson;\n\t\tthis.url = url;\n\t\tthis.tileDimension = tileDimension;\n\t\tthis.levels = levels;\n\n\t\tthis.pointRadius = pointRadius;\n\t\tthis.strokeStyle = strokeStyle;\n\t\tthis.strokeWidth = strokeWidth;\n\t\tthis.fillStyle = fillStyle;\n\n\t}\n\n\tasync init() {\n\n\t\t// configure tiling to content bounds and levels\n\t\tconst { tiling, levels, tileDimension, geojson, url } = this;\n\t\tconst projection = new ProjectionScheme();\n\t\ttiling.setProjection( projection );\n\t\ttiling.setContentBounds( ...projection.getBounds() );\n\n\t\ttiling.generateLevels(\n\t\t\tlevels,\n\t\t\tprojection.tileCountX,\n\t\t\tprojection.tileCountY,\n\t\t\t{\n\t\t\t\ttilePixelWidth: tileDimension,\n\t\t\t\ttilePixelHeight: tileDimension,\n\t\t\t},\n\t\t);\n\n\t\t// If a URL was provided and no geojson object yet, fetch it now (use fetchData so overlay can inject headers)\n\t\tif ( ! geojson && url ) {\n\n\t\t\tconst res = await this.fetchData( url );\n\t\t\tthis.geojson = await res.json();\n\n\t\t}\n\n\t\t// TODO: If geojson present, compute bounds from data (with padding) and set as content bounds.\n\t\t// Falls back to full projection bounds if no geojson or unable to compute an extent.\n\n\t\t// seems that this approach to optimize rendering by defining bounds\n\t\t// doesn't work if not using a very large offset for the bounds, maybe an error?\n\t\tconst geoBounds = this._geoJSONBounds( 50 ).map( v => v * MathUtils.DEG2RAD );\n\t\tthis.tiling.setContentBounds( ...geoBounds );\n\n\t}\n\n\t// main fetch per tile - > returns .Texture\n\tasync fetchItem( tokens, signal ) {\n\n\t\treturn this.drawCanvasImage( tokens );\n\n\t}\n\n\tdrawCanvasImage( tokens ) {\n\n\t\tconst { tiling, tileDimension, geojson } = this;\n\t\tconst [ x, y, level ] = tokens;\n\t\tconst tileBoundsDeg = tiling.getTileBounds( x, y, level, false, false ).map( v => MathUtils.RAD2DEG * v );\n\n\t\t// create canvas\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = tileDimension;\n\t\tcanvas.height = tileDimension;\n\n\t\t// draw features\n\t\tconst ctx = canvas.getContext( '2d' );\n\t\tconst features = this._featuresFromGeoJSON( geojson );\n\t\tfor ( let i = 0; i < features.length; i ++ ) {\n\n\t\t\tconst feature = features[ i ];\n\t\t\tif ( this._featureIntersectsTile( feature, tileBoundsDeg ) ) {\n\n\t\t\t\tthis._drawFeatureOnCanvas( ctx, feature, tileBoundsDeg, canvas.width, canvas.height );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tex = new CanvasTexture( canvas );\n\t\ttex.needsUpdate = true;\n\t\treturn tex;\n\n\t}\n\n\t// bbox quick test in projected units\n\t_featureIntersectsTile( feature, boundsDeg ) {\n\n\t\tconst featureBoundsDeg = this._getFeatureBounds( feature );\n\t\tif ( ! featureBoundsDeg ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// check for intersection between bounds\n\t\tconst [ fminX, fminY, fmaxX, fmaxY ] = featureBoundsDeg;\n\t\tconst [ minX, minY, maxX, maxY ] = boundsDeg;\n\t\treturn ! ( fmaxX < minX || fminX > maxX || fmaxY < minY || fminY > maxY );\n\n\t}\n\n\t_getFeatureBounds( feature ) {\n\n\t\tconst { geometry } = feature;\n\t\tif ( ! geometry ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst { type, coordinates } = geometry;\n\t\tlet minLon = Infinity;\n\t\tlet minLat = Infinity;\n\t\tlet maxLon = - Infinity;\n\t\tlet maxLat = - Infinity;\n\n\t\tconst expandBoundsByPoint = ( lon, lat ) => {\n\n\t\t\tminLon = Math.min( minLon, lon );\n\t\t\tmaxLon = Math.max( maxLon, lon );\n\t\t\tminLat = Math.min( minLat, lat );\n\t\t\tmaxLat = Math.max( maxLat, lat );\n\n\t\t};\n\n\t\tif ( type === 'Point' ) {\n\n\t\t\texpandBoundsByPoint( coordinates[ 0 ], coordinates[ 1 ] );\n\n\t\t} else if ( type === 'MultiPoint' || type === 'LineString' ) {\n\n\t\t\tcoordinates.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) );\n\n\t\t} else if ( type === 'MultiLineString' || type === 'Polygon' ) {\n\n\t\t\tcoordinates.forEach( ring => ring.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) ) );\n\n\t\t} else if ( type === 'MultiPolygon' ) {\n\n\t\t\tcoordinates.forEach( polygon =>\n\t\t\t\tpolygon.forEach( ring => ring.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) ) ),\n\t\t\t);\n\n\t\t}\n\n\t\treturn [ minLon, minLat, maxLon, maxLat ];\n\n\t}\n\n\t// Normalize top-level geojson into an array of Feature objects\n\t_featuresFromGeoJSON( root ) {\n\n\t\tconst type = root.type;\n\t\tconst geomTypes = new Set( [ 'Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon' ] );\n\n\t\tif ( type === 'FeatureCollection' ) {\n\n\t\t\treturn root.features;\n\n\t\t} else if ( type === 'Feature' ) {\n\n\t\t\treturn [ root ];\n\n\t\t} else if ( type === 'GeometryCollection' ) {\n\n\t\t\treturn root.geometries.map( g => ( { type: 'Feature', geometry: g, properties: {} } ) );\n\n\t\t} else if ( geomTypes.has( type ) ) {\n\n\t\t\treturn [ { type: 'Feature', geometry: root, properties: {} } ];\n\n\t\t} else {\n\n\t\t\treturn [];\n\n\t\t}\n\n\t}\n\n\t// draw feature on canvas ( assumes intersects already )\n\t_drawFeatureOnCanvas( ctx, feature, tileBoundsDeg, width, height ) {\n\n\t\tconst { geometry = null, properties = {} } = feature;\n\t\tif ( ! geometry ) {\n\n\t\t\t// A feature may have null geometry in GeoJSON\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst [ minLonDeg, minLatDeg, maxLonDeg, maxLatDeg ] = tileBoundsDeg;\n\t\tconst strokeStyle = properties.strokeStyle || this.strokeStyle;\n\t\tconst fillStyle = properties.fillStyle || this.fillStyle;\n\t\tconst pointRadius = properties.pointRadius || this.pointRadius;\n\t\tconst strokeWidth = properties.strokeWidth || this.strokeWidth;\n\n\t\tctx.save();\n\t\tctx.strokeStyle = strokeStyle;\n\t\tctx.fillStyle = fillStyle;\n\t\tctx.lineWidth = strokeWidth;\n\n\t\t// Compute pixel from cartographic coordinates and tile bounds\n\t\tconst arr = new Array( 2 );\n\t\tconst projectPoint = ( lon, lat, target = arr ) => {\n\n\t\t\t// canvas y origin is top, projection y increases north -> flip\n\t\t\tconst x = MathUtils.mapLinear( lon, minLonDeg, maxLonDeg, 0, width );\n\t\t\tconst y = height - MathUtils.mapLinear( lat, minLatDeg, maxLatDeg, 0, height );\n\n\t\t\t// round to integer to gain performance\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#avoid_floating-point_coordinates_and_use_integers_instead\n\t\t\ttarget[ 0 ] = Math.round( x );\n\t\t\ttarget[ 1 ] = Math.round( y );\n\t\t\treturn target;\n\n\t\t};\n\n\t\tconst calculateAspectRatio = ( lon, lat ) => {\n\n\t\t\t// calculates the aspect ratio with which to draw points\n\t\t\tconst latRad = lat * MathUtils.DEG2RAD;\n\t\t\tconst lonRad = lon * MathUtils.DEG2RAD;\n\t\t\tconst pxLat = ( maxLatDeg - minLatDeg ) / height;\n\t\t\tconst pxLon = ( maxLonDeg - minLonDeg ) / width;\n\t\t\tconst pixelRatio = pxLon / pxLat;\n\n\t\t\t// TODO: this should use the ellipsoid defined on the relevant tiles renderer\n\t\t\treturn pixelRatio * calculateArcRatioAtPoint( WGS84_ELLIPSOID, latRad, lonRad );\n\n\t\t};\n\n\t\tconst type = geometry.type;\n\t\tif ( type === 'Point' ) {\n\n\t\t\tconst [ lon, lat ] = geometry.coordinates;\n\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\tconst drawRatio = calculateAspectRatio( lon, lat );\n\n\t\t\tctx.beginPath();\n\t\t\tctx.ellipse( px, py, pointRadius / drawRatio, pointRadius, 0, 0, Math.PI * 2 );\n\t\t\tctx.fill();\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiPoint' ) {\n\n\t\t\tgeometry.coordinates.forEach( ( [ lon, lat ] ) => {\n\n\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\tconst drawRatio = calculateAspectRatio( lon, lat );\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.ellipse( px, py, pointRadius / drawRatio, pointRadius, 0, 0, Math.PI * 2 );\n\t\t\t\tctx.fill();\n\t\t\t\tctx.stroke();\n\n\t\t\t} );\n\n\t\t} else if ( type === 'LineString' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiLineString' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( line ) => {\n\n\t\t\t\tline.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'Polygon' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( ring, rIndex ) => {\n\n\t\t\t\tring.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tctx.closePath();\n\n\t\t\t} );\n\t\t\tctx.fill( 'evenodd' );\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiPolygon' ) {\n\n\t\t\tgeometry.coordinates.forEach( ( polygon ) => {\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tpolygon.forEach( ( ring, rIndex ) => {\n\n\t\t\t\t\tring.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tctx.closePath();\n\n\t\t\t\t} );\n\t\t\t\tctx.fill( 'evenodd' );\n\t\t\t\tctx.stroke();\n\n\t\t\t} );\n\n\t\t}\n\n\t\tctx.restore();\n\n\t}\n\n\t// Compute geographic bounds in degrees from current geojson.\n\t_geoJSONBounds() {\n\n\t\t// TODO: add support for padding the bounding boxes\n\t\tconst features = this._featuresFromGeoJSON( this.geojson );\n\t\tlet minLon = Infinity;\n\t\tlet minLat = Infinity;\n\t\tlet maxLon = - Infinity;\n\t\tlet maxLat = - Infinity;\n\n\t\tfeatures.forEach( feature => {\n\n\t\t\tconst [ fMinLon, fMinLat, fMaxLon, fMaxLat ] = this._getFeatureBounds( feature );\n\t\t\tminLon = Math.min( minLon, fMinLon );\n\t\t\tminLat = Math.min( minLat, fMinLat );\n\t\t\tmaxLon = Math.max( maxLon, fMaxLon );\n\t\t\tmaxLat = Math.max( maxLat, fMaxLat );\n\n\t\t} );\n\n\t\treturn [ minLon, minLat, maxLon, maxLat ];\n\n\t}\n\n}\n","import { WebGLRenderTarget, Color, SRGBColorSpace, BufferAttribute, Matrix4, Vector3, Box3, Triangle, CanvasTexture } from 'three';\nimport { PriorityQueue, PriorityQueueItemRemovedError } from '3d-tiles-renderer/core';\nimport { CesiumIonAuth, GoogleCloudAuth } from '3d-tiles-renderer/core/plugins';\nimport { TiledTextureComposer } from './overlays/TiledTextureComposer.js';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { QuadKeyImageSource } from './sources/QuadKeyImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { forEachTileInBounds, getMeshesCartographicRange, getMeshesPlanarRange } from './overlays/utils.js';\nimport { wrapOverlaysMaterial } from './overlays/wrapOverlaysMaterial.js';\nimport { GeometryClipper } from '../utilities/GeometryClipper.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\nimport { MemoryUtils } from '3d-tiles-renderer/three';\nimport { GeoJSONImageSource } from './sources/GeoJSONImageSource.js';\nimport { WMSImageSource } from './sources/WMSImageSource.js';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _sphereCenter = /* @__PURE__ */ new Vector3();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _box = /* @__PURE__ */ new Box3();\nconst SPLIT_TILE_DATA = Symbol( 'SPLIT_TILE_DATA' );\nconst SPLIT_HASH = Symbol( 'SPLIT_HASH' );\n\n// function for marking and releasing images in the given overlay\nfunction markOverlayImages( range, level, overlay, doRelease ) {\n\n\t// return null immediately if possible to allow for drawing without delay where possible\n\tif ( Array.isArray( overlay ) ) {\n\n\t\tconst promises = overlay\n\t\t\t.map( o => markOverlayImages( range, level, o, doRelease ) )\n\t\t\t.filter( p => p !== null );\n\n\t\tif ( promises.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t} else {\n\n\t\t\treturn Promise.all( promises );\n\n\t\t}\n\n\t}\n\n\tif ( ! overlay.isReady ) {\n\n\t\treturn overlay.whenReady().then( markImages );\n\n\t} else {\n\n\t\treturn markImages();\n\n\t}\n\n\tfunction markImages() {\n\n\t\tconst promises = [];\n\t\tconst { imageSource, tiling } = overlay;\n\t\tforEachTileInBounds( range, level, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\tif ( doRelease ) {\n\n\t\t\t\timageSource.release( tx, ty, tl );\n\n\t\t\t} else {\n\n\t\t\t\tpromises.push( imageSource.lock( tx, ty, tl ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst filteredPromises = promises.filter( p => p instanceof Promise );\n\t\tif ( filteredPromises.length !== 0 ) {\n\n\t\t\treturn Promise.all( filteredPromises );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n// returns the total number of tiles that will be drawn for the provided range\nfunction countTilesInRange( range, level, overlay ) {\n\n\tlet total = 0;\n\tforEachTileInBounds( range, level, overlay.tiling, overlay.isPlanarProjection, ( x, y, l ) => {\n\n\t\ttotal ++;\n\n\t} );\n\n\treturn total;\n\n}\n\n// Plugin for overlaying tiled image data on top of 3d tiles geometry.\nexport class ImageOverlayPlugin {\n\n\tget enableTileSplitting() {\n\n\t\treturn this._enableTileSplitting;\n\n\t}\n\n\tset enableTileSplitting( v ) {\n\n\t\tif ( this._enableTileSplitting !== v ) {\n\n\t\t\tthis._enableTileSplitting = v;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\toverlays = [],\n\t\t\tresolution = 256,\n\t\t\trenderer = null,\n\t\t\tenableTileSplitting = true,\n\t\t} = options;\n\n\t\t// plugin needs to run before other plugins that fetch data since content\n\t\t// is handled and loaded in a custom way\n\t\tthis.name = 'IMAGE_OVERLAY_PLUGIN';\n\t\tthis.priority = - 15;\n\n\t\t// options\n\t\tthis.renderer = renderer;\n\t\tthis.resolution = resolution;\n\t\tthis._enableTileSplitting = enableTileSplitting;\n\t\tthis.overlays = [];\n\n\t\t// internal\n\t\tthis.needsUpdate = false;\n\t\tthis.tiles = null;\n\t\tthis.tileComposer = null;\n\t\tthis.tileControllers = new Map();\n\t\tthis.overlayInfo = new Map();\n\t\tthis.usedTextures = new Set();\n\t\tthis.meshParams = new WeakMap();\n\t\tthis.pendingTiles = new Map();\n\t\tthis.processedTiles = new Set();\n\t\tthis.processQueue = null;\n\t\tthis._onUpdateAfter = null;\n\t\tthis._onTileDownloadStart = null;\n\t\tthis._cleanupScheduled = false;\n\t\tthis._virtualChildResetId = 0;\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.addOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\t// plugin functions\n\tinit( tiles ) {\n\n\t\tif ( ! this.renderer ) {\n\n\t\t\tthrow new Error( 'ImageOverlayPlugin: \"renderer\" instance must be provided.' );\n\n\t\t}\n\n\t\tconst tileComposer = new TiledTextureComposer( this.renderer );\n\t\tconst processQueue = new PriorityQueue();\n\t\tprocessQueue.maxJobs = 10;\n\t\tprocessQueue.priorityCallback = ( a, b ) => {\n\n\t\t\tconst tileA = a.tile;\n\t\t\tconst tileB = b.tile;\n\n\t\t\tconst visibleA = tiles.visibleTiles.has( tileA );\n\t\t\tconst visibleB = tiles.visibleTiles.has( tileB );\n\t\t\tif ( visibleA !== visibleB ) {\n\n\t\t\t\t// load visible tiles first\n\t\t\t\treturn visibleA ? 1 : - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// the fallback to the download queue tile priority\n\t\t\t\treturn tiles.downloadQueue.priorityCallback( tileA, tileB );\n\n\t\t\t}\n\n\t\t\t// TODO: we could prioritize by overlay order here to ensure consistency\n\n\t\t};\n\n\t\t// save variables\n\t\tthis.tiles = tiles;\n\t\tthis.tileComposer = tileComposer;\n\t\tthis.processQueue = processQueue;\n\n\t\t// init all existing tiles\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._processTileModel( scene, tile, true );\n\n\t\t} );\n\n\t\t// update callback for when overlays have changed\n\t\tthis._onUpdateAfter = async () => {\n\n\t\t\t// check if the projection changed for any of the overlays and refresh them\n\t\t\tlet overlayChanged = false;\n\t\t\tthis.overlayInfo.forEach( ( info, overlay ) => {\n\n\t\t\t\tif (\n\t\t\t\t\tBoolean( overlay.frame ) !== Boolean( info.frame ) ||\n\t\t\t\t\toverlay.frame && info.frame && ! info.frame.equals( overlay.frame )\n\t\t\t\t) {\n\n\t\t\t\t\tconst order = info.order;\n\t\t\t\t\tthis.deleteOverlay( overlay );\n\t\t\t\t\tthis.addOverlay( overlay, order );\n\n\t\t\t\t\toverlayChanged = true;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// trigger redraws for visible tiles if overlays updated\n\t\t\tif ( overlayChanged ) {\n\n\t\t\t\tconst maxJobs = processQueue.maxJobs;\n\t\t\t\tlet count = 0;\n\t\t\t\tprocessQueue.items.forEach( info => {\n\n\t\t\t\t\tif ( tiles.visibleTiles.has( info.tile ) ) {\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tprocessQueue.maxJobs = count + processQueue.currJobs;\n\t\t\t\tprocessQueue.tryRunJobs();\n\t\t\t\tprocessQueue.maxJobs = maxJobs;\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\t// update all the layer uvs\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.needsUpdate = false;\n\n\t\t\t\tconst { overlays, overlayInfo } = this;\n\t\t\t\toverlays.sort( ( a, b ) => {\n\n\t\t\t\t\treturn overlayInfo.get( a ).order - overlayInfo.get( b ).order;\n\n\t\t\t\t} );\n\n\t\t\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\t\t\tthis._updateLayers( tile );\n\n\t\t\t\t} );\n\n\t\t\t\tthis.resetVirtualChildren( ! this.enableTileSplitting );\n\t\t\t\ttiles.recalculateBytesUsed();\n\n\t\t\t\ttiles.dispatchEvent( { type: 'needs-rerender' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._onTileDownloadStart = ( { tile, url } ) => {\n\n\t\t\t// TODO: it's not super straight forward to detect whether a tile is \"geometry\" or not ahead of time. Checking\n\t\t\t// for \"subtree\" or \"json\" are good broad strokes but some cases will still be missed.\n\t\t\tif ( ! /\\.json$/i.test( url ) && ! /\\.subtree/i.test( url ) ) {\n\n\t\t\t\tthis.processedTiles.add( tile );\n\t\t\t\tthis._initTileOverlayInfo( tile );\n\n\t\t\t}\n\n\t\t};\n\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.addEventListener( 'tile-download-start', this._onTileDownloadStart );\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tconst { overlayInfo, tileControllers, processQueue, pendingTiles, processedTiles } = this;\n\n\t\tprocessedTiles.delete( tile );\n\n\t\t// Cancel any ongoing tasks. If a tile is cancelled while downloading\n\t\t// this will not have been created, yet.\n\t\tif ( tileControllers.has( tile ) ) {\n\n\t\t\ttileControllers.get( tile ).abort();\n\t\t\ttileControllers.delete( tile );\n\t\t\tpendingTiles.delete( tile );\n\n\t\t}\n\n\t\t// stop any tile loads\n\t\toverlayInfo.forEach( ( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { meshInfo, range, meshRange, level, target, meshRangeMarked, rangeMarked } = tileInfo.get( tile );\n\n\t\t\t\t// release the ranges\n\t\t\t\tif ( meshRange !== null && meshRangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( meshRange, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( range !== null && rangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( range, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( target !== null ) {\n\n\t\t\t\t\t// release the render targets\n\t\t\t\t\ttarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t\ttileInfo.delete( tile );\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t}\n\n\t\t} ) );\n\n\t\t// Remove any items that reference the tile being disposed\n\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\treturn item.tile === tile;\n\n\t\t} );\n\n\t}\n\n\tcalculateBytesUsed( tile ) {\n\n\t\tconst { overlayInfo } = this;\n\t\tconst bytesUsed = this._bytesUsed;\n\n\t\tlet bytes = null;\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { target } = tileInfo.get( tile );\n\t\t\t\tbytes = bytes || 0;\n\t\t\t\tbytes += MemoryUtils.getTextureByteLength( target?.texture );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( bytes !== null ) {\n\n\t\t\tbytesUsed.set( tile, bytes );\n\t\t\treturn bytes;\n\n\t\t} else if ( bytesUsed.has( tile ) ) {\n\n\t\t\treturn bytesUsed.get( tile );\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tprocessTileModel( scene, tile ) {\n\n\t\treturn this._processTileModel( scene, tile );\n\n\t}\n\n\tasync _processTileModel( scene, tile, initialization = false ) {\n\n\t\tconst { tileControllers, processedTiles, pendingTiles } = this;\n\n\t\ttileControllers.set( tile, new AbortController() );\n\n\t\tif ( ! initialization ) {\n\n\t\t\t// we save all these pending tiles so that they can be correctly initialized if an\n\t\t\t// overlay is added in the time between when this function starts and after the async\n\t\t\t// await call. Otherwise the tile could be missed. But if we're initializing the plugin\n\t\t\t// then we don't need to do this because the tiles are already included in the traversal.\n\t\t\tpendingTiles.set( tile, scene );\n\n\t\t}\n\n\t\t// track which tiles we have been processed and remove them in \"disposeTile\"\n\t\tprocessedTiles.add( tile );\n\n\t\tthis._wrapMaterials( scene );\n\t\tthis._initTileOverlayInfo( tile );\n\t\tawait this._initTileSceneOverlayInfo( scene, tile );\n\t\tthis.expandVirtualChildren( scene, tile );\n\t\tthis._updateLayers( tile );\n\n\t\tpendingTiles.delete( tile );\n\n\t}\n\n\tdispose() {\n\n\t\tconst { tileComposer, tiles } = this;\n\n\t\t// dispose textures\n\t\ttileComposer.dispose();\n\n\t\t// dispose of all overlays\n\t\tconst overlays = [ ...this.overlays ];\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.deleteOverlay( overlay );\n\n\t\t} );\n\n\t\t// reset the textures of the meshes\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._updateLayers( tile );\n\t\t\tthis.disposeTile( tile );\n\n\t\t\tdelete tile[ SPLIT_HASH ];\n\n\t\t} );\n\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfter );\n\n\t\tthis.resetVirtualChildren( true );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tif ( overlay.opacity > 0 ) {\n\n\t\t\t\toverlay.getAttributions( target );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tparseToMesh( buffer, tile, extension, uri ) {\n\n\t\tif ( extension === 'image_overlay_tile_split' ) {\n\n\t\t\treturn tile[ SPLIT_TILE_DATA ];\n\n\t\t}\n\n\t}\n\n\tasync resetVirtualChildren( fullDispose = false ) {\n\n\t\t// only run this if all the overlays are ready and tile targets have been generated, etc\n\t\t// so we can make an effort to only remove the necessary tiles.\n\t\tthis._virtualChildResetId ++;\n\t\tconst id = this._virtualChildResetId;\n\n\t\tawait Promise.all( this.overlays.map( o => o.whenReady() ) );\n\n\t\tif ( id !== this._virtualChildResetId ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// collect the tiles split into virtual tiles\n\t\tconst { tiles } = this;\n\t\tconst parents = new Set();\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tif ( SPLIT_HASH in tile ) {\n\n\t\t\t\tparents.add( tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// dispose of the virtual children if this tile would not be split or the spilt could change\n\t\t// under the current overlays used.\n\t\tparents.forEach( parent => {\n\n\t\t\tif ( parent.parent === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst clone = parent.cached.scene.clone();\n\t\t\tclone.updateMatrixWorld();\n\n\t\t\tconst { hash } = this._getSplitVectors( clone, parent );\n\t\t\tif ( parent[ SPLIT_HASH ] !== hash || fullDispose ) {\n\n\t\t\t\t// TODO: if are parent tile is forcibly remove then we should make sure that all the children are, too?\n\t\t\t\tconst children = collectChildren( parent );\n\t\t\t\tchildren.sort( ( a, b ) => ( b.__depth || 0 ) - ( a.__depth || 0 ) );\n\n\t\t\t\t// note that we need to remove children from the processing queue in this case\n\t\t\t\t// because we are forcibly evicting them from the cache.\n\t\t\t\tchildren.forEach( child => {\n\n\t\t\t\t\ttiles.processNodeQueue.remove( child );\n\t\t\t\t\ttiles.lruCache.remove( child );\n\t\t\t\t\tchild.parent = null;\n\n\t\t\t\t} );\n\n\t\t\t\tparent.children.length = 0;\n\t\t\t\tparent.__childrenProcessed = 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// re-expand tiles if needed\n\t\tif ( ! fullDispose ) {\n\n\t\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\t\tthis.expandVirtualChildren( scene, tile );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction collectChildren( root, target = [] ) {\n\n\t\t\troot.children.forEach( child => {\n\n\t\t\t\ttarget.push( child );\n\t\t\t\tcollectChildren( child, target );\n\n\t\t\t} );\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n\t_getSplitVectors( scene, tile, centerTarget = _center ) {\n\n\t\tconst { tiles, overlayInfo } = this;\n\n\t\t// get the center of the content\n\t\tconst box = new Box3();\n\t\tbox.setFromObject( scene );\n\t\tbox.getCenter( centerTarget );\n\n\t\t// find the vectors that are orthogonal to every overlay projection\n\t\tconst splitDirections = [];\n\t\tconst hashTokens = [];\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\t// if the tile has a render target associated with the overlay and the last level of detail\n\t\t\t// is not being displayed, yet, then we need to split\n\t\t\tconst info = tileInfo.get( tile );\n\t\t\tif ( info && info.target && overlay.tiling.maxLevel > info.level ) {\n\n\t\t\t\t// get the vector representing the projection direction\n\t\t\t\tif ( overlay.frame ) {\n\n\t\t\t\t\t_normal.set( 0, 0, 1 ).transformDirection( overlay.frame );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttiles.ellipsoid.getPositionToNormal( centerTarget, _normal );\n\t\t\t\t\tif ( _normal.length() < 1e-6 ) {\n\n\t\t\t\t\t\t_normal.set( 1, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// dedupe vectors in the hash\n\t\t\t\tconst token = `${ _normal.x.toFixed( 3 ) },${ _normal.y.toFixed( 3 ) },${ _normal.z.toFixed( 3 ) }_`;\n\t\t\t\tif ( ! hashTokens.includes( token ) ) {\n\n\t\t\t\t\thashTokens.push( token );\n\n\t\t\t\t}\n\n\t\t\t\t// construct the orthogonal vectors\n\t\t\t\tconst other = _vec.set( 0, 0, 1 );\n\t\t\t\tif ( Math.abs( _normal.dot( other ) ) > 1 - 1e-4 ) {\n\n\t\t\t\t\tother.set( 1, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tconst ortho0 = new Vector3().crossVectors( _normal, other ).normalize();\n\t\t\t\tconst ortho1 = new Vector3().crossVectors( _normal, ortho0 ).normalize();\n\t\t\t\tsplitDirections.push( ortho0, ortho1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Generate a reduced set of vectors by averages directions in a 45 degree cone so\n\t\t// we don't split unnecessarily\n\t\tconst directions = [];\n\t\twhile ( splitDirections.length !== 0 ) {\n\n\t\t\tconst normalized = splitDirections.pop().clone();\n\t\t\tconst average = normalized.clone();\n\t\t\tfor ( let i = 0; i < splitDirections.length; i ++ ) {\n\n\t\t\t\tconst dir = splitDirections[ i ];\n\t\t\t\tconst dotProduct = normalized.dot( dir );\n\t\t\t\tif ( Math.abs( dotProduct ) > Math.cos( Math.PI / 8 ) ) {\n\n\t\t\t\t\taverage.addScaledVector( dir, Math.sign( dotProduct ) );\n\t\t\t\t\tnormalized.copy( average ).normalize();\n\t\t\t\t\tsplitDirections.splice( i, 1 );\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdirections.push( average.normalize() );\n\n\t\t}\n\n\t\treturn { directions, hash: hashTokens.join( '' ) };\n\n\t}\n\n\tasync expandVirtualChildren( scene, tile ) {\n\n\t\tif ( tile.children.length !== 0 || this.enableTileSplitting === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// create a copy of the content to transform and split\n\t\tconst clone = scene.clone();\n\t\tclone.updateMatrixWorld();\n\n\t\t// get the directions to split on\n\t\tconst { directions, hash } = this._getSplitVectors( clone, tile, _center );\n\t\ttile[ SPLIT_HASH ] = hash;\n\n\t\t// if there are no directions to split on then exit early\n\t\tif ( directions.length === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// set up the splitter to ignore overlay uvs\n\t\tconst clipper = new GeometryClipper();\n\t\tclipper.attributeList = key => ! /^layer_uv_\\d+/.test( key );\n\t\tdirections.map( splitDirection => {\n\n\t\t\tclipper.addSplitOperation( ( geometry, i0, i1, i2, barycoord, matrixWorld ) => {\n\n\t\t\t\tTriangle.getInterpolatedAttribute( geometry.attributes.position, i0, i1, i2, barycoord, _vec );\n\t\t\t\treturn _vec.applyMatrix4( matrixWorld ).sub( _center ).dot( splitDirection );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// run the clipping operations by performing every permutation of sides\n\t\t// defined by the split directions\n\t\tconst children = [];\n\t\tclipper.forEachSplitPermutation( () => {\n\n\t\t\t// clip the object itself\n\t\t\tconst result = clipper.clipObject( clone );\n\n\t\t\t// remove the parent transform because it will be multiplied back in after the fact\n\t\t\tresult.matrix\n\t\t\t\t.premultiply( tile.cached.transformInverse )\n\t\t\t\t.decompose( result.position, result.quaternion, result.scale );\n\n\t\t\t// collect the meshes\n\t\t\tconst meshes = [];\n\t\t\tresult.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst material = c.material.clone();\n\t\t\t\t\tc.material = material;\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\t\tif ( value.source.data instanceof ImageBitmap ) {\n\n\t\t\t\t\t\t\t\t// clone any image bitmap textures using canvas because if we share the texture then when\n\t\t\t\t\t\t\t\t// the clipped child is disposed then it will dispose of the parent tile texture data, as well.\n\t\t\t\t\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\t\t\t\t\tcanvas.width = value.image.width;\n\t\t\t\t\t\t\t\tcanvas.height = value.image.height;\n\n\t\t\t\t\t\t\t\tconst ctx = canvas.getContext( '2d' );\n\t\t\t\t\t\t\t\tctx.scale( 1, - 1 );\n\t\t\t\t\t\t\t\tctx.drawImage( value.source.data, 0, 0, canvas.width, - canvas.height );\n\n\t\t\t\t\t\t\t\tconst tex = new CanvasTexture( canvas );\n\t\t\t\t\t\t\t\ttex.mapping = value.mapping;\n\t\t\t\t\t\t\t\ttex.wrapS = value.wrapS;\n\t\t\t\t\t\t\t\ttex.wrapT = value.wrapT;\n\t\t\t\t\t\t\t\ttex.minFilter = value.minFilter;\n\t\t\t\t\t\t\t\ttex.magFilter = value.magFilter;\n\t\t\t\t\t\t\t\ttex.format = value.format;\n\t\t\t\t\t\t\t\ttex.type = value.type;\n\t\t\t\t\t\t\t\ttex.anisotropy = value.anisotropy;\n\t\t\t\t\t\t\t\ttex.colorSpace = value.colorSpace;\n\t\t\t\t\t\t\t\ttex.generateMipmaps = value.generateMipmaps;\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = tex;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( meshes.length === 0 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// generate a region bounding volume\n\t\t\tconst boundingVolume = {};\n\t\t\tif ( tile.boundingVolume.region ) {\n\n\t\t\t\tboundingVolume.region = getMeshesCartographicRange( meshes, this.tiles.ellipsoid ).region;\n\n\t\t\t}\n\n\t\t\t// create a sphere bounding volume\n\t\t\tif ( tile.boundingVolume.box || tile.boundingVolume.sphere ) {\n\n\t\t\t\t// TODO: we create a sphere even when a region is present because currently the handling of region volumes\n\t\t\t\t// is a bit flaky especially at small scales. OBBs are generated which can be imperfect resulting rays passing\n\t\t\t\t// through tiles. The same may be the case with frustum checks. In theory, though, we should not need a sphere\n\t\t\t\t// bounds if a region bounds are present.\n\n\t\t\t\t// compute the sphere center\n\t\t\t\t_box\n\t\t\t\t\t.setFromObject( result, true )\n\t\t\t\t\t.getCenter( _sphereCenter );\n\n\t\t\t\t// calculate the sq radius from all vertices\n\t\t\t\tlet maxSqRadius = 0;\n\t\t\t\tresult.traverse( c => {\n\n\t\t\t\t\tconst geometry = c.geometry;\n\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst sqRadius = _vec\n\t\t\t\t\t\t\t\t.fromBufferAttribute( position, i )\n\t\t\t\t\t\t\t\t.applyMatrix4( c.matrixWorld )\n\t\t\t\t\t\t\t\t.distanceToSquared( _sphereCenter );\n\n\t\t\t\t\t\t\tmaxSqRadius = Math.max( maxSqRadius, sqRadius );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tboundingVolume.sphere = [ ..._sphereCenter, Math.sqrt( maxSqRadius ) ];\n\n\t\t\t}\n\n\t\t\tchildren.push( {\n\t\t\t\trefine: 'REPLACE',\n\t\t\t\tgeometricError: tile.geometricError * 0.5,\n\t\t\t\tboundingVolume: boundingVolume,\n\t\t\t\tcontent: { uri: './child.image_overlay_tile_split' },\n\t\t\t\tchildren: [],\n\t\t\t\t[ SPLIT_TILE_DATA ]: result,\n\t\t\t} );\n\n\t\t} );\n\n\t\t// force the tile \"refine\" mode to be set to \"REPLACE\" if we're splitting tiles\n\t\t// TODO: If a tile is of type \"ADD\" refine and it has children then it will not be split\n\t\t// as expected since only geometry tiles with no children are split. Instead we'd want\n\t\t// to split this tiles geometry in addition to adding the child tiles.\n\t\ttile.refine = 'REPLACE';\n\t\ttile.children.push( ...children );\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\t// if this is our custom url indicating a tile split then return fake response\n\t\tif ( /image_overlay_tile_split/.test( uri ) ) {\n\n\t\t\treturn new ArrayBuffer();\n\n\t\t}\n\n\t}\n\n\t// public\n\taddOverlay( overlay, order = null ) {\n\n\t\tconst { tiles, overlays, overlayInfo } = this;\n\n\t\tif ( order === null ) {\n\n\t\t\t// set the order to the next largest order value\n\t\t\torder = overlays.reduce( ( v, o ) => Math.max( v, o.order + 1 ), 0 );\n\n\t\t}\n\n\t\tconst controller = new AbortController();\n\t\toverlays.push( overlay );\n\t\toverlayInfo.set( overlay, {\n\t\t\torder: order,\n\t\t\tuniforms: {},\n\t\t\ttileInfo: new Map(),\n\t\t\tcontroller: controller,\n\t\t\tframe: overlay.frame ? overlay.frame.clone() : null,\n\t\t} );\n\n\t\tif ( tiles !== null ) {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t}\n\n\t}\n\n\tsetOverlayOrder( overlay, order ) {\n\n\t\tconst index = this.overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.overlayInfo.get( overlay ).order = order;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tdeleteOverlay( overlay ) {\n\n\t\tconst { overlays, overlayInfo, processQueue, processedTiles } = this;\n\t\tconst index = overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\t// delete tile info explicitly instead of blindly dispose of the full overlay\n\t\t\tconst { tileInfo, controller } = overlayInfo.get( overlay );\n\t\t\tprocessedTiles.forEach( tile => {\n\n\t\t\t\tif ( ! tileInfo.has( tile ) ) {\n\n\t\t\t\t\t// check for the case where tiles have been added but not properly initialized with the\n\t\t\t\t\t// given overlay, yet\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\tmeshInfo,\n\t\t\t\t\trange,\n\t\t\t\t\tmeshRange,\n\t\t\t\t\tlevel,\n\t\t\t\t\ttarget,\n\t\t\t\t\tmeshRangeMarked,\n\t\t\t\t\trangeMarked,\n\t\t\t\t} = tileInfo.get( tile );\n\n\t\t\t\t// release the ranges\n\t\t\t\tif ( meshRange !== null && meshRangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( meshRange, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( range !== null && rangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( range, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( target !== null ) {\n\n\t\t\t\t\t// release the render targets\n\t\t\t\t\ttarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t\ttileInfo.delete( tile );\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t} );\n\n\t\t\ttileInfo.clear();\n\t\t\toverlayInfo.delete( overlay );\n\t\t\tcontroller.abort();\n\n\t\t\t// Remove any items that reference the overlay being disposed\n\t\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\t\treturn item.overlay === overlay;\n\n\t\t\t} );\n\n\t\t\toverlays.splice( index, 1 );\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\t// internal\n\t_calculateLevelFromOverlay( overlay, range, tile, normalized = false ) {\n\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\tconst { resolution } = this;\n\t\t\tconst { tiling } = overlay;\n\n\t\t\tconst normalizedRange = normalized ? range : tiling.toNormalizedRange( range );\n\t\t\tconst [ minX, minY, maxX, maxY ] = normalizedRange;\n\t\t\tconst w = maxX - minX;\n\t\t\tconst h = maxY - minY;\n\n\t\t\tlet level = 0;\n\t\t\tconst { maxLevel } = tiling;\n\t\t\tfor ( ; level < maxLevel; level ++ ) {\n\n\t\t\t\t// the number of pixels per image on each axis\n\t\t\t\tconst wProj = resolution / w;\n\t\t\t\tconst hProj = resolution / h;\n\n\t\t\t\tconst { pixelWidth, pixelHeight } = tiling.getLevel( level );\n\t\t\t\tif ( pixelWidth >= wProj || pixelHeight >= hProj ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: should this be one layer higher LoD?\n\t\t\treturn level;\n\n\t\t} else {\n\n\t\t\treturn tile.__depthFromRenderedParent - 1;\n\n\t\t}\n\n\t}\n\n\t// initialize the overlay to use the right fetch options, load all data for existing tiles\n\t_initOverlay( overlay ) {\n\n\t\tconst { tiles } = this;\n\n\t\tif ( ! overlay.isInitialized ) {\n\n\t\t\toverlay.init();\n\n\t\t\toverlay.whenReady().then( () => {\n\n\t\t\t\toverlay.imageSource.fetchData = ( ...args ) => tiles\n\t\t\t\t\t.downloadQueue\n\t\t\t\t\t.add( { priority: - performance.now() }, () => {\n\n\t\t\t\t\t\treturn overlay.fetch( ...args );\n\n\t\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst promises = [];\n\t\tconst initTile = async ( scene, tile ) => {\n\n\t\t\tthis._initTileOverlayInfo( tile, overlay );\n\n\t\t\tconst promise = this._initTileSceneOverlayInfo( scene, tile, overlay );\n\t\t\tpromises.push( promise );\n\n\t\t\t// mark tiles as needing an update after initialized so we get a trickle in of tiles\n\t\t\tawait promise;\n\t\t\tthis._updateLayers( tile );\n\n\t\t};\n\n\t\ttiles.forEachLoadedModel( initTile );\n\t\tthis.pendingTiles.forEach( ( scene, tile ) => {\n\n\t\t\tinitTile( scene, tile );\n\n\t\t} );\n\n\t\tPromise.all( promises ).then( () => {\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t} );\n\n\t}\n\n\t// wrap all materials in the given scene wit the overlay material shader\n\t_wrapMaterials( scene ) {\n\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst params = wrapOverlaysMaterial( c.material, c.material.onBeforeCompile );\n\t\t\t\tthis.meshParams.set( c, params );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Initialize per-tile overlay information. This function triggers an async function but\n\t// does not need to be awaited for use since it's just locking textures which are awaited later.\n\t_initTileOverlayInfo( tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\toverlay.forEach( o => this._initTileOverlayInfo( tile, o ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// This function is resilient to multiple calls in case an overlay is added after a tile starts loading\n\t\t// and before it is loaded, meaning this function needs to be called twice to ensure it's initialized.\n\t\tconst { overlayInfo, processQueue } = this;\n\t\tif ( overlayInfo.get( overlay ).tileInfo.has( tile ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst info = {\n\t\t\trange: null,\n\t\t\tmeshRange: null,\n\t\t\tlevel: null,\n\t\t\ttarget: null,\n\t\t\tmeshInfo: new Map(),\n\n\t\t\trangeMarked: false,\n\t\t\tmeshRangeMarked: false,\n\t\t};\n\n\t\toverlayInfo\n\t\t\t.get( overlay )\n\t\t\t.tileInfo\n\t\t\t.set( tile, info );\n\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t// TODO: we could project the shape into the frame, compute 2d bounds, and then mark tiles\n\n\t\t} else {\n\n\t\t\t// If the tile has a region bounding volume then mark the tiles to preload\n\t\t\tif ( tile.boundingVolume.region ) {\n\n\t\t\t\tconst [ minLon, minLat, maxLon, maxLat ] = tile.boundingVolume.region;\n\t\t\t\tconst range = [ minLon, minLat, maxLon, maxLat ];\n\t\t\t\tinfo.range = range;\n\t\t\t\tinfo.level = this._calculateLevelFromOverlay( overlay, range, tile );\n\n\t\t\t\tprocessQueue\n\t\t\t\t\t.add( { tile, overlay }, () => {\n\n\t\t\t\t\t\tinfo.rangeMarked = true;\n\t\t\t\t\t\treturn markOverlayImages( range, info.level, overlay, false );\n\n\t\t\t\t\t} )\n\t\t\t\t\t.catch( err => {\n\n\t\t\t\t\t\tif ( ! ( err instanceof PriorityQueueItemRemovedError ) ) {\n\n\t\t\t\t\t\t\tthrow err;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the scene meshes\n\tasync _initTileSceneOverlayInfo( scene, tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\treturn Promise.all( overlay.map( o => this._initTileSceneOverlayInfo( scene, tile, o ) ) );\n\n\t\t}\n\n\t\tconst { tiles, overlayInfo, resolution, tileComposer, tileControllers, usedTextures, processQueue } = this;\n\t\tconst { ellipsoid } = tiles;\n\t\tconst { controller, tileInfo } = overlayInfo.get( overlay );\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// wait for the overlay to be completely loaded so projection and tiling are available\n\t\tif ( ! overlay.isReady ) {\n\n\t\t\tawait overlay.whenReady();\n\n\t\t}\n\n\t\t// check if the overlay or tile have been disposed since starting this function\n\t\t// if the tileController is not present then the tile has been disposed of already\n\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// find all meshes to project on and ensure matrices are up to date\n\t\tconst meshes = [];\n\t\tscene.updateMatrixWorld();\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst { tiling, imageSource } = overlay;\n\t\tconst info = tileInfo.get( tile );\n\t\tlet range, uvs, heightInRange;\n\n\t\t// retrieve the uvs and range for all the meshes\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t_matrix.copy( overlay.frame );\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.multiply( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tlet heightRange;\n\t\t\t( { range, uvs, heightRange } = getMeshesPlanarRange( meshes, _matrix, tiling ) );\n\t\t\theightInRange = ! ( heightRange[ 0 ] > 1 || heightRange[ 1 ] < 0 );\n\n\t\t} else {\n\n\t\t\t_matrix.identity();\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.copy( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t( { range, uvs } = getMeshesCartographicRange( meshes, ellipsoid, _matrix, tiling ) );\n\t\t\theightInRange = true;\n\n\t\t}\n\n\t\tlet normalizedRange;\n\t\tif ( ! overlay.isPlanarProjection ) {\n\n\t\t\tnormalizedRange = tiling.toNormalizedRange( range );\n\n\t\t} else {\n\n\t\t\tnormalizedRange = range;\n\n\t\t}\n\n\t\t// calculate the tiling level here if not already created\n\t\tif ( info.level === null ) {\n\n\t\t\tinfo.level = this._calculateLevelFromOverlay( overlay, normalizedRange, tile, true );\n\n\t\t}\n\n\t\t// if the image projection is outside the 0, 1 uvw range or there are no textures to draw in\n\t\t// the tiled image set the don't allocate a texture for it.\n\t\tlet target = null;\n\t\tif ( heightInRange && countTilesInRange( range, info.level, overlay ) !== 0 ) {\n\n\t\t\ttarget = new WebGLRenderTarget( resolution, resolution, {\n\t\t\t\tdepthBuffer: false,\n\t\t\t\tstencilBuffer: false,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tcolorSpace: SRGBColorSpace,\n\t\t\t} );\n\n\t\t}\n\n\t\tinfo.meshRange = range;\n\t\tinfo.target = target;\n\n\t\tmeshes.forEach( ( mesh, i ) => {\n\n\t\t\tconst array = new Float32Array( uvs[ i ] );\n\t\t\tconst attribute = new BufferAttribute( array, 3 );\n\t\t\tinfo.meshInfo.set( mesh, { attribute } );\n\n\t\t} );\n\n\t\tif ( target !== null ) {\n\n\t\t\tawait processQueue\n\t\t\t\t.add( { tile, overlay }, async () => {\n\n\t\t\t\t\tinfo.meshRangeMarked = true;\n\n\t\t\t\t\tconst promise = markOverlayImages( range, info.level, overlay, false );\n\t\t\t\t\tif ( promise ) {\n\n\t\t\t\t\t\t// if the previous layer is present then draw it as an overlay to fill in any gaps while we wait for\n\t\t\t\t\t\t// the next set of textures\n\t\t\t\t\t\ttileComposer.setRenderTarget( target, normalizedRange );\n\t\t\t\t\t\ttileComposer.clear( 0xffffff, 0 );\n\n\t\t\t\t\t\tforEachTileInBounds( range, info.level - 1, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\t\t\t\t\t// draw using normalized bounds since the mercator bounds are non-linear\n\t\t\t\t\t\t\tconst span = tiling.getTileBounds( tx, ty, tl, true, false );\n\t\t\t\t\t\t\tconst tex = imageSource.get( tx, ty, tl );\n\t\t\t\t\t\t\tif ( tex && ! ( tex instanceof Promise ) ) {\n\n\t\t\t\t\t\t\t\ttileComposer.draw( tex, span );\n\t\t\t\t\t\t\t\tusedTextures.add( tex );\n\t\t\t\t\t\t\t\tthis._scheduleCleanup();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tawait promise;\n\n\t\t\t\t\t\t} catch {\n\n\t\t\t\t\t\t\t// skip errors since this will throw when aborted\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if the overlay has been disposed since starting this function\n\t\t\t\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// draw the textures\n\t\t\t\t\ttileComposer.setRenderTarget( target, normalizedRange );\n\t\t\t\t\ttileComposer.clear( 0xffffff, 0 );\n\n\t\t\t\t\tforEachTileInBounds( range, info.level, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\t\t\t\t// draw using normalized bounds since the mercator bounds are non-linear\n\t\t\t\t\t\tconst span = tiling.getTileBounds( tx, ty, tl, true, false );\n\t\t\t\t\t\tconst tex = imageSource.get( tx, ty, tl );\n\t\t\t\t\t\ttileComposer.draw( tex, span );\n\t\t\t\t\t\tusedTextures.add( tex );\n\t\t\t\t\t\tthis._scheduleCleanup();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.catch( err => {\n\n\t\t\t\t\tif ( ! ( err instanceof PriorityQueueItemRemovedError ) ) {\n\n\t\t\t\t\t\tthrow err;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t_updateLayers( tile ) {\n\n\t\tconst { overlayInfo, overlays, tileControllers } = this;\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// by this point all targets should be present and we can force the memory to update\n\t\tthis.tiles.recalculateBytesUsed( tile );\n\n\t\t// if the tile has been disposed before this function is called then exit early\n\t\tif ( ! tileController || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// update the uvs and texture overlays for each mesh\n\t\toverlays.forEach( ( overlay, i ) => {\n\n\t\t\tconst { tileInfo } = overlayInfo.get( overlay );\n\t\t\tconst { meshInfo, target } = tileInfo.get( tile );\n\t\t\tmeshInfo.forEach( ( { attribute }, mesh ) => {\n\n\t\t\t\tconst { geometry, material } = mesh;\n\t\t\t\tconst params = this.meshParams.get( mesh );\n\n\t\t\t\t// assign the new uvs\n\t\t\t\tconst key = `layer_uv_${ i }`;\n\t\t\t\tif ( geometry.getAttribute( key ) !== attribute ) {\n\n\t\t\t\t\tgeometry.setAttribute( key, attribute );\n\t\t\t\t\tgeometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t\t// set the uniform array lengths\n\t\t\t\tparams.layerMaps.length = overlays.length;\n\t\t\t\tparams.layerInfo.length = overlays.length;\n\n\t\t\t\t// assign the uniforms\n\t\t\t\tparams.layerMaps.value[ i ] = target !== null ? target.texture : null;\n\t\t\t\tparams.layerInfo.value[ i ] = overlay;\n\n\t\t\t\t// mark per-layer defines\n\t\t\t\tmaterial.defines[ `LAYER_${ i }_EXISTS` ] = Number( target !== null );\n\t\t\t\tmaterial.defines[ `LAYER_${ i }_ALPHA_INVERT` ] = Number( overlay.alphaInvert );\n\t\t\t\tmaterial.defines[ `LAYER_${ i }_ALPHA_MASK` ] = Number( overlay.alphaMask );\n\n\t\t\t\tmaterial.defines.LAYER_COUNT = overlays.length;\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t_scheduleCleanup() {\n\n\t\t// clean up textures used for drawing the tile overlays\n\t\tif ( ! this._cleanupScheduled ) {\n\n\t\t\tthis._cleanupScheduled = true;\n\t\t\trequestAnimationFrame( () => {\n\n\t\t\t\tconst { usedTextures } = this;\n\t\t\t\tusedTextures.forEach( tex => {\n\n\t\t\t\t\ttex.dispose();\n\n\t\t\t\t} );\n\n\t\t\t\tusedTextures.clear();\n\t\t\t\tthis._cleanupScheduled = false;\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t_markNeedsUpdate() {\n\n\t\tif ( this.needsUpdate === false ) {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tif ( this.tiles !== null ) {\n\n\t\t\t\tthis.tiles.dispatchEvent( { type: 'needs-update' } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nclass ImageOverlay {\n\n\tget tiling() {\n\n\t\treturn this.imageSource.tiling;\n\n\t}\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tget isPlanarProjection() {\n\n\t\treturn Boolean( this.frame );\n\n\t}\n\n\tget aspectRatio() {\n\n\t\treturn this.tiling && this.isReady ? this.tiling.aspectRatio : 1;\n\n\t}\n\n\tget fetchOptions() {\n\n\t\treturn this.imageSource.fetchOptions;\n\n\t}\n\n\tset fetchOptions( v ) {\n\n\t\tthis.imageSource.fetchOptions = v;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\topacity = 1,\n\t\t\tcolor = 0xffffff,\n\t\t\tframe = null,\n\t\t\tpreprocessURL = null,\n\t\t\talphaMask = false,\n\t\t\talphaInvert = false,\n\t\t} = options;\n\t\tthis.imageSource = null;\n\n\t\tthis.preprocessURL = preprocessURL;\n\t\tthis.opacity = opacity;\n\t\tthis.color = new Color( color );\n\t\tthis.frame = frame !== null ? frame.clone() : null;\n\t\tthis.alphaMask = alphaMask;\n\t\tthis.alphaInvert = alphaInvert;\n\n\t\tthis.isReady = false;\n\t\tthis.isInitialized = false;\n\n\t}\n\n\tinit() {\n\n\t\tthis.isInitialized = true;\n\t\tthis.whenReady().then( () => {\n\n\t\t\tthis.isReady = true;\n\n\t\t} );\n\n\t}\n\n\tfetch( url, options = {} ) {\n\n\t\tif ( this.preprocessURL ) {\n\n\t\t\turl = this.preprocessURL( url );\n\n\t\t}\n\n\t\treturn fetch( url, options );\n\n\t}\n\n\twhenReady() {\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.imageSource.dispose();\n\n\t}\n\n}\n\nexport class XYZTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new XYZImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class GeoJSONOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new GeoJSONImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class WMSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new WMSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class WMTSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new WMTSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class TMSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new TMSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis.url = options.url;\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class CesiumIonOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, autoRefreshToken, assetId } = options;\n\t\tthis.options = options;\n\t\tthis.assetId = assetId;\n\t\tthis.auth = new CesiumIonAuth( { apiToken, autoRefreshToken } );\n\n\t\tthis.auth.authURL = `https://api.cesium.com/v1/assets/${ assetId }/endpoint`;\n\t\tthis._attributions = [];\n\n\t\tthis.externalType = false;\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( async ( json ) => {\n\n\t\t\t\tthis._attributions = json.attributions.map( att => ( {\n\t\t\t\t\tvalue: att.html,\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\tcollapsible: att.collapsible,\n\t\t\t\t} ) );\n\n\t\t\t\tif ( json.type !== 'IMAGERY' ) {\n\n\t\t\t\t\tthrow new Error( 'CesiumIonOverlay: Only IMAGERY is supported as overlay type.' );\n\n\t\t\t\t}\n\n\t\t\t\tthis.externalType = Boolean( json.externalType );\n\n\t\t\t\tswitch ( json.externalType ) {\n\n\t\t\t\t\tcase 'GOOGLE_2D_MAPS': {\n\n\t\t\t\t\t\tconst { url, session, key, tileWidth } = json.options;\n\t\t\t\t\t\tconst xyzUrl = `${ url }/v1/2dtiles/{z}/{x}/{y}?session=${ session }&key=${ key }`;\n\t\t\t\t\t\tthis.imageSource = new XYZImageSource( {\n\t\t\t\t\t\t\t...this.options,\n\t\t\t\t\t\t\turl: xyzUrl,\n\t\t\t\t\t\t\ttileDimension: tileWidth,\n\n\t\t\t\t\t\t\t// Google maps tiles have a fixed depth of 22\n\t\t\t\t\t\t\t// https://developers.google.com/maps/documentation/tile/2d-tiles-overview\n\t\t\t\t\t\t\tlevels: 22,\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'BING': {\n\n\t\t\t\t\t\tconst { url, mapStyle, key } = json.options;\n\t\t\t\t\t\tconst metadataUrl = `${ url }/REST/v1/Imagery/Metadata/${ mapStyle }?incl=ImageryProviders&key=${ key }&uriScheme=https`;\n\t\t\t\t\t\tconst response = await fetch( metadataUrl ).then( res => res.json() );\n\t\t\t\t\t\tconst metadata = response.resourceSets[ 0 ].resources[ 0 ];\n\n\t\t\t\t\t\tthis.imageSource = new QuadKeyImageSource( {\n\t\t\t\t\t\t\t...this.options,\n\t\t\t\t\t\t\turl: metadata.imageUrl,\n\t\t\t\t\t\t\tsubdomains: metadata.imageUrlSubdomains,\n\t\t\t\t\t\t\ttileDimension: metadata.tileWidth,\n\t\t\t\t\t\t\tlevels: metadata.zoomMax,\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.imageSource = new TMSImageSource( {\n\t\t\t\t\t\t\t...this.options,\n\t\t\t\t\t\t\turl: json.url,\n\t\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t\tsuper.init();\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\t// bypass auth fetch if asset is external type to prevent CORS error due to wrong bearer token\n\t\treturn this.externalType ? super.fetch( ...args ) : this.auth.fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\ttarget.push( ...this._attributions );\n\n\t}\n\n}\n\nexport class GoogleMapsOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, sessionOptions, autoRefreshToken, logoUrl } = options;\n\t\tthis.logoUrl = logoUrl;\n\t\tthis.auth = new GoogleCloudAuth( { apiToken, sessionOptions, autoRefreshToken } );\n\t\tthis.imageSource = new XYZImageSource();\n\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis._logoAttribution = {\n\t\t\tvalue: '',\n\t\t\ttype: 'image',\n\t\t\tcollapsible: false,\n\t\t};\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis.imageSource.tileDimension = json.tileWidth;\n\t\t\t\tthis.imageSource.url = 'https://tile.googleapis.com/v1/2dtiles/{z}/{x}/{y}';\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t\tsuper.init();\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn this.auth.fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.logoUrl ) {\n\n\t\t\tthis._logoAttribution.value = this.logoUrl;\n\t\t\ttarget.push( this._logoAttribution );\n\n\t\t}\n\n\t}\n\n}\n","import { Ray, Sphere } from 'three';\nimport { OBB } from '3d-tiles-renderer/three';\n\nexport class LoadRegionPlugin {\n\n\tconstructor() {\n\n\t\tthis.name = 'LOAD_REGION_PLUGIN';\n\t\tthis.regions = [];\n\t\tthis.tiles = null;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t}\n\n\taddRegion( region ) {\n\n\t\tif ( this.regions.indexOf( region ) === - 1 ) {\n\n\t\t\tthis.regions.push( region );\n\n\t\t}\n\n\t}\n\n\tremoveRegion( region ) {\n\n\t\tconst index = this.regions.indexOf( region );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.regions.splice( index, 1 );\n\n\t\t}\n\n\t}\n\n\thasRegion( region ) {\n\n\t\treturn this.regions.indexOf( region ) !== - 1;\n\n\t}\n\n\tclearRegions() {\n\n\t\tthis.regions = [];\n\n\t}\n\n\t// Calculates shape intersections and associated error values to use. If \"mask\" shapes are present then\n\t// tiles are only loaded if they are within those shapes.\n\tcalculateTileViewError( tile, target ) {\n\n\t\tconst boundingVolume = tile.cached.boundingVolume;\n\t\tconst { regions, tiles } = this;\n\n\t\tlet inShape = false;\n\t\tlet inMask = null;\n\t\tlet maxError = - Infinity;\n\t\tfor ( const region of regions ) {\n\n\t\t\t// Check if the tile is intersecting the shape and calculate the\n\t\t\t// view and error values.\n\t\t\tconst intersects = region.intersectsTile( boundingVolume, tile, tiles );\n\t\t\tinShape = inShape || intersects;\n\t\t\tmaxError = Math.max( region.calculateError( tile, tiles ), maxError );\n\n\t\t\t// Store whether the tile is in a \"mask\" shape if they exist. If \"inMask\" is\n\t\t\t// still \"null\" by the end of the loop then there are no mask elements.\n\t\t\tif ( region.mask ) {\n\n\t\t\t\tinMask = inMask || intersects;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// A tile should only be visible if it intersects a shape and a mask shape or there\n\t\t// are no masks.\n\t\ttarget.inView = inShape && inMask !== false;\n\t\ttarget.error = maxError;\n\n\t\t// Returning \"false\" indicates \"no operation\" and all results will be ignored.\n\t\treturn target.inView || inMask !== null;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.regions = [];\n\n\t}\n\n}\n\n// Definitions of predefined regions\nexport class BaseRegion {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'LoadRegionPlugin: Region constructor has been changed to take options as an object.' );\n\t\t\toptions = { errorTarget: options };\n\n\t\t}\n\n\t\tconst {\n\t\t\terrorTarget = 10,\n\t\t\tmask = false,\n\t\t} = options;\n\n\t\tthis.errorTarget = errorTarget;\n\t\tthis.mask = mask;\n\n\t}\n\n\tintersectsTile() {}\n\n\tcalculateError( tile, tilesRenderer ) {\n\n\t\treturn tile.geometricError - this.errorTarget + tilesRenderer.errorTarget;\n\n\t}\n\n}\n\nexport class SphereRegion extends BaseRegion {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'SphereRegion: Region constructor has been changed to take options as an object.' );\n\t\t\toptions = {\n\t\t\t\terrorTarget: arguments[ 0 ],\n\t\t\t\tsphere: arguments[ 1 ],\n\t\t\t};\n\n\t\t}\n\n\t\tconst { sphere = new Sphere() } = options;\n\n\t\tsuper( options );\n\t\tthis.sphere = sphere.clone();\n\n\t}\n\n\tintersectsTile( boundingVolume ) {\n\n\t\treturn boundingVolume.intersectsSphere( this.sphere );\n\n\t}\n\n}\n\nexport class RayRegion extends BaseRegion {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'RayRegion: Region constructor has been changed to take options as an object.' );\n\t\t\toptions = {\n\t\t\t\terrorTarget: arguments[ 0 ],\n\t\t\t\tray: arguments[ 1 ],\n\t\t\t};\n\n\t\t}\n\n\t\tconst { ray = new Ray() } = options;\n\n\t\tsuper( options );\n\t\tthis.ray = ray.clone();\n\n\t}\n\n\tintersectsTile( boundingVolume ) {\n\n\t\treturn boundingVolume.intersectsRay( this.ray );\n\n\t}\n\n}\n\nexport class OBBRegion extends BaseRegion {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'RayRegion: Region constructor has been changed to take options as an object.' );\n\t\t\toptions = {\n\t\t\t\terrorTarget: arguments[ 0 ],\n\t\t\t\tobb: arguments[ 1 ],\n\t\t\t};\n\n\t\t}\n\n\t\tconst { obb = new OBB() } = options;\n\n\t\tsuper( options );\n\t\tthis.obb = obb.clone();\n\t\tthis.obb.update();\n\n\t}\n\n\tintersectsTile( boundingVolume ) {\n\n\t\treturn boundingVolume.intersectsOBB( this.obb );\n\n\t}\n\n}\n","import { LineSegments, BufferGeometry, Vector3, BufferAttribute, LineBasicMaterial } from 'three';\n\nconst _vector = /* @__PURE__ */ new Vector3();\nconst axes = [ 'x', 'y', 'z' ];\nexport class SphereHelper extends LineSegments {\n\n\tconstructor( sphere, color = 0xffff00, angleSteps = 40 ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst positions = [];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis1 = axes[ i ];\n\t\t\tconst axis2 = axes[ ( i + 1 ) % 3 ];\n\t\t\t_vector.set( 0, 0, 0 );\n\n\t\t\tfor ( let a = 0; a < angleSteps; a ++ ) {\n\n\t\t\t\tlet angle;\n\t\t\t\tangle = 2 * Math.PI * a / ( angleSteps - 1 );\n\t\t\t\t_vector[ axis1 ] = Math.sin( angle );\n\t\t\t\t_vector[ axis2 ] = Math.cos( angle );\n\n\t\t\t\tpositions.push( _vector.x, _vector.y, _vector.z );\n\n\t\t\t\tangle = 2 * Math.PI * ( a + 1 ) / ( angleSteps - 1 );\n\t\t\t\t_vector[ axis1 ] = Math.sin( angle );\n\t\t\t\t_vector[ axis2 ] = Math.cos( angle );\n\n\t\t\t\tpositions.push( _vector.x, _vector.y, _vector.z );\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( positions ), 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.sphere = sphere;\n\t\tthis.type = 'SphereHelper';\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst sphere = this.sphere;\n\t\tthis.position.copy( sphere.center );\n\t\tthis.scale.setScalar( sphere.radius );\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n","import { Mesh, Vector3, MathUtils, BoxGeometry, BufferGeometry, EdgesGeometry, LineSegments, BufferAttribute } from 'three';\nimport { EllipsoidRegion } from '3d-tiles-renderer/three';\n\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _norm2 = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _vec1 = /* @__PURE__ */ new Vector3();\nconst _vec2 = /* @__PURE__ */ new Vector3();\n\n// Converts a geometry with a given set of groups rendering a smaller set of\n// geometry into a new one with only the relevant triangles.\nfunction toGroupGeometry( geometry ) {\n\n\t// non indexed makes this process easier\n\tgeometry = geometry.toNonIndexed();\n\n\t// prep the arrays\n\tconst { groups } = geometry;\n\tconst { position, normal } = geometry.attributes;\n\tconst newNorm = [];\n\tconst newPos = [];\n\n\t// add the normals and the positions\n\tfor ( const group of groups ) {\n\n\t\tconst { start, count } = group;\n\t\tfor ( let i = start, l = ( start + count ); i < l; i ++ ) {\n\n\t\t\t_vec1.fromBufferAttribute( position, i );\n\t\t\t_vec2.fromBufferAttribute( normal, i );\n\n\t\t\tnewPos.push( ..._vec1 );\n\t\t\tnewNorm.push( ..._vec2 );\n\n\t\t}\n\n\t}\n\n\t// set the new geometry\n\tconst newGeometry = new BufferGeometry();\n\tnewGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( newPos ), 3 ) );\n\tnewGeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( newNorm ), 3 ) );\n\n\treturn newGeometry;\n\n}\n\nfunction getRegionGeometry( ellipsoidRegion, { computeNormals = false } = {} ) {\n\n\t// retrieve the relevant fields\n\tconst {\n\t\tlatStart = - Math.PI / 2, latEnd = Math.PI / 2,\n\t\tlonStart = 0, lonEnd = 2 * Math.PI,\n\t\theightStart = 0, heightEnd = 0,\n\t} = ellipsoidRegion;\n\n\t// get the attributes\n\tconst geometry = new BoxGeometry( 1, 1, 1, 32, 32 );\n\tconst { normal, position } = geometry.attributes;\n\n\t// clone the position buffer so we can reference it for normal calculations later\n\tconst refPosition = position.clone();\n\n\t// perturb the position buffer into an ellipsoid region\n\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t_pos.fromBufferAttribute( position, i );\n\n\t\tconst lat = MathUtils.mapLinear( _pos.x, - 0.5, 0.5, latStart, latEnd );\n\t\tconst lon = MathUtils.mapLinear( _pos.y, - 0.5, 0.5, lonStart, lonEnd );\n\n\t\tlet height = heightStart;\n\t\tellipsoidRegion.getCartographicToNormal( lat, lon, _norm );\n\t\tif ( _pos.z < 0 ) {\n\n\t\t\theight = heightEnd;\n\n\t\t}\n\n\t\tellipsoidRegion.getCartographicToPosition( lat, lon, height, _pos );\n\t\tposition.setXYZ( i, ..._pos );\n\n\t}\n\n\tif ( computeNormals ) {\n\n\t\t// compute the vertex normals so we can get the edge normals\n\t\tgeometry.computeVertexNormals();\n\n\t}\n\n\t// compute the top and bottom cap normals\n\tfor ( let i = 0, l = refPosition.count; i < l; i ++ ) {\n\n\t\t_pos.fromBufferAttribute( refPosition, i );\n\n\t\tconst lat = MathUtils.mapLinear( _pos.x, - 0.5, 0.5, latStart, latEnd );\n\t\tconst lon = MathUtils.mapLinear( _pos.y, - 0.5, 0.5, lonStart, lonEnd );\n\n\t\t_norm.fromBufferAttribute( normal, i );\n\t\tellipsoidRegion.getCartographicToNormal( lat, lon, _norm2 );\n\n\t\t// exclude the sides so we get sharp corners\n\t\tif ( Math.abs( _norm.dot( _norm2 ) ) > 0.1 ) {\n\n\t\t\tif ( _pos.z > 0 ) {\n\n\t\t\t\t_norm2.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tnormal.setXYZ( i, ..._norm2 );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport class EllipsoidRegionLineHelper extends LineSegments {\n\n\tconstructor( ellipsoidRegion = new EllipsoidRegion(), color = 0xffff00 ) {\n\n\t\tsuper();\n\t\tthis.ellipsoidRegion = ellipsoidRegion;\n\t\tthis.material.color.set( color );\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = getRegionGeometry( this.ellipsoidRegion );\n\t\tthis.geometry.dispose();\n\t\tthis.geometry = new EdgesGeometry( geometry, 80 );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nexport class EllipsoidRegionHelper extends Mesh {\n\n\tconstructor( ellipsoidRegion = new EllipsoidRegion(), color = 0xffff00 ) {\n\n\t\tsuper();\n\t\tthis.ellipsoidRegion = ellipsoidRegion;\n\t\tthis.material.color.set( color );\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\t// dispose of the existing geometry\n\t\tthis.geometry.dispose();\n\n\t\t// retrieve the relevant fields\n\t\tconst geometry = getRegionGeometry( this.ellipsoidRegion, { computeNormals: true } );\n\t\tconst { lonStart, lonEnd } = this;\n\n\t\t// exclude the side tris if the region wraps around\n\t\tif ( lonEnd - lonStart >= 2 * Math.PI ) {\n\n\t\t\tgeometry.groups.splice( 2, 2 );\n\t\t\tthis.geometry = toGroupGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tthis.geometry = geometry;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n","import { Box3Helper, Group, MeshStandardMaterial, PointsMaterial, Sphere, Color, MeshBasicMaterial } from 'three';\nimport { SphereHelper } from './objects/SphereHelper.js';\nimport { EllipsoidRegionLineHelper } from './objects/EllipsoidRegionHelper.js';\nimport { TraversalUtils } from '3d-tiles-renderer/core';\n\nconst ORIGINAL_MATERIAL = Symbol( 'ORIGINAL_MATERIAL' );\nconst HAS_RANDOM_COLOR = Symbol( 'HAS_RANDOM_COLOR' );\nconst HAS_RANDOM_NODE_COLOR = Symbol( 'HAS_RANDOM_NODE_COLOR' );\nconst LOAD_TIME = Symbol( 'LOAD_TIME' );\nconst PARENT_BOUND_REF_COUNT = Symbol( 'PARENT_BOUND_REF_COUNT' );\n\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst emptyRaycast = () => {};\n\nconst colors = {};\n\n// Return a consistent random color for an index\nfunction getIndexedRandomColor( index ) {\n\n\tif ( ! colors[ index ] ) {\n\n\t\tconst h = Math.random();\n\t\tconst s = 0.5 + Math.random() * 0.5;\n\t\tconst l = 0.375 + Math.random() * 0.25;\n\n\t\tcolors[ index ] = new Color().setHSL( h, s, l );\n\n\t}\n\n\treturn colors[ index ];\n\n}\n\n// color modes\nconst NONE = 0;\nconst SCREEN_ERROR = 1;\nconst GEOMETRIC_ERROR = 2;\nconst DISTANCE = 3;\nconst DEPTH = 4;\nconst RELATIVE_DEPTH = 5;\nconst IS_LEAF = 6;\nconst RANDOM_COLOR = 7;\nconst RANDOM_NODE_COLOR = 8;\nconst CUSTOM_COLOR = 9;\nconst LOAD_ORDER = 10;\n\nconst ColorModes = Object.freeze( {\n\tNONE,\n\tSCREEN_ERROR,\n\tGEOMETRIC_ERROR,\n\tDISTANCE,\n\tDEPTH,\n\tRELATIVE_DEPTH,\n\tIS_LEAF,\n\tRANDOM_COLOR,\n\tRANDOM_NODE_COLOR,\n\tCUSTOM_COLOR,\n\tLOAD_ORDER,\n} );\n\nexport class DebugTilesPlugin {\n\n\tstatic get ColorModes() {\n\n\t\treturn ColorModes;\n\n\t}\n\n\tget unlit() {\n\n\t\treturn this._unlit;\n\n\t}\n\n\tset unlit( v ) {\n\n\t\tif ( v !== this._unlit ) {\n\n\t\t\tthis._unlit = v;\n\t\t\tthis.materialsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tget colorMode() {\n\n\t\treturn this._colorMode;\n\n\t}\n\n\tset colorMode( v ) {\n\n\t\tif ( v !== this._colorMode ) {\n\n\t\t\tthis._colorMode = v;\n\t\t\tthis.materialsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tget enabled() {\n\n\t\treturn this._enabled;\n\n\t}\n\n\tset enabled( v ) {\n\n\t\tif ( v !== this._enabled && this.tiles !== null ) {\n\n\t\t\tif ( v ) {\n\n\t\t\t\tthis.init( this.tiles );\n\n\t\t\t} else {\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._enabled = v;\n\n\t}\n\n\tget displayParentBounds() {\n\n\t\treturn this._displayParentBounds;\n\n\t}\n\n\tset displayParentBounds( v ) {\n\n\t\tif ( this._displayParentBounds !== v ) {\n\n\t\t\tthis._displayParentBounds = v;\n\n\t\t\tif ( ! v ) {\n\n\t\t\t\t// Reset all ref counts\n\t\t\t\tthis.tiles.traverse( tile => {\n\n\t\t\t\t\ttile[ PARENT_BOUND_REF_COUNT ] = null;\n\t\t\t\t\tthis._onTileVisibilityChange( tile, tile.__visible );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t// Initialize ref count for existing tiles\n\t\t\t\tthis.tiles.traverse( tile => {\n\n\t\t\t\t\tif ( tile.__visible ) {\n\n\t\t\t\t\t\tthis._onTileVisibilityChange( tile, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\t\t\tdisplayParentBounds: false,\n\t\t\tdisplayBoxBounds: false,\n\t\t\tdisplaySphereBounds: false,\n\t\t\tdisplayRegionBounds: false,\n\t\t\tcolorMode: NONE,\n\t\t\tmaxDebugDepth: - 1,\n\t\t\tmaxDebugDistance: - 1,\n\t\t\tmaxDebugError: - 1,\n\t\t\tcustomColorCallback: null,\n\t\t\tunlit: false,\n\t\t\tenabled: true,\n\t\t\t...options,\n\t\t};\n\n\t\tthis.name = 'DEBUG_TILES_PLUGIN';\n\t\tthis.tiles = null;\n\n\t\tthis._colorMode = null;\n\t\tthis._unlit = null;\n\t\tthis.materialsNeedUpdate = false;\n\n\t\tthis.extremeDebugDepth = - 1;\n\t\tthis.extremeDebugError = - 1;\n\t\tthis.boxGroup = null;\n\t\tthis.sphereGroup = null;\n\t\tthis.regionGroup = null;\n\n\t\t// options\n\t\tthis._enabled = options.enabled;\n\t\tthis._displayParentBounds = options.displayParentBounds;\n\t\tthis.displayBoxBounds = options.displayBoxBounds;\n\t\tthis.displaySphereBounds = options.displaySphereBounds;\n\t\tthis.displayRegionBounds = options.displayRegionBounds;\n\t\tthis.colorMode = options.colorMode;\n\t\tthis.maxDebugDepth = options.maxDebugDepth;\n\t\tthis.maxDebugDistance = options.maxDebugDistance;\n\t\tthis.maxDebugError = options.maxDebugError;\n\t\tthis.customColorCallback = options.customColorCallback;\n\t\tthis.unlit = options.unlit;\n\n\t\tthis.getDebugColor = ( value, target ) => {\n\n\t\t\ttarget.setRGB( value, value, value );\n\n\t\t};\n\n\t}\n\n\t// initialize the groups for displaying helpers, register events, and initialize existing tiles\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\t// initialize groups\n\t\tconst tilesGroup = tiles.group;\n\t\tthis.boxGroup = new Group();\n\t\tthis.boxGroup.name = 'DebugTilesRenderer.boxGroup';\n\t\ttilesGroup.add( this.boxGroup );\n\t\tthis.boxGroup.updateMatrixWorld();\n\n\t\tthis.sphereGroup = new Group();\n\t\tthis.sphereGroup.name = 'DebugTilesRenderer.sphereGroup';\n\t\ttilesGroup.add( this.sphereGroup );\n\t\tthis.sphereGroup.updateMatrixWorld();\n\n\t\tthis.regionGroup = new Group();\n\t\tthis.regionGroup.name = 'DebugTilesRenderer.regionGroup';\n\t\ttilesGroup.add( this.regionGroup );\n\t\tthis.regionGroup.updateMatrixWorld();\n\n\t\t// register events\n\t\tthis._onLoadTilesetCB = () => {\n\n\t\t\tthis._initExtremes();\n\n\t\t};\n\n\t\tthis._onLoadModelCB = ( { scene, tile } ) => {\n\n\t\t\tthis._onLoadModel( scene, tile );\n\n\t\t};\n\n\t\tthis._onDisposeModelCB = ( { tile } ) => {\n\n\t\t\tthis._onDisposeModel( tile );\n\n\t\t};\n\n\t\tthis._onUpdateAfterCB = () => {\n\n\t\t\tthis._onUpdateAfter();\n\n\t\t};\n\n\t\tthis._onTileVisibilityChangeCB = ( { scene, tile, visible } ) => {\n\n\t\t\tthis._onTileVisibilityChange( tile, visible );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'load-tileset', this._onLoadTilesetCB );\n\t\ttiles.addEventListener( 'load-model', this._onLoadModelCB );\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModelCB );\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfterCB );\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onTileVisibilityChangeCB );\n\n\t\tthis._initExtremes();\n\n\t\t// initialize an already-loaded tiles\n\t\ttiles.traverse( tile => {\n\n\t\t\tif ( tile.cached.scene ) {\n\n\t\t\t\tthis._onLoadModel( tile.cached.scene, tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttiles.visibleTiles.forEach( tile => {\n\n\t\t\tthis._onTileVisibilityChange( tile, true );\n\n\t\t} );\n\n\t}\n\n\tgetTileInformationFromActiveObject( object ) {\n\n\t\t// Find which tile this scene is associated with. This is slow and\n\t\t// intended for debug purposes only.\n\t\tlet targetTile = null;\n\t\tconst activeTiles = this.tiles.activeTiles;\n\t\tactiveTiles.forEach( tile => {\n\n\t\t\tif ( targetTile ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.traverse( c => {\n\n\t\t\t\t\tif ( c === object ) {\n\n\t\t\t\t\t\ttargetTile = tile;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( targetTile ) {\n\n\t\t\treturn {\n\n\t\t\t\tdistanceToCamera: targetTile.__distanceFromCamera,\n\t\t\t\tgeometricError: targetTile.geometricError,\n\t\t\t\tscreenSpaceError: targetTile.__error,\n\t\t\t\tdepth: targetTile.__depth,\n\t\t\t\tisLeaf: targetTile.__isLeaf\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t_initExtremes() {\n\n\t\tif ( ! ( this.tiles && this.tiles.root ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// initialize the extreme values of the hierarchy\n\t\tlet maxDepth = - 1;\n\t\tlet maxError = - 1;\n\n\t\t// Note that we are not using this.tiles.traverse()\n\t\t// as we don't want to pay the cost of preprocessing tiles.\n\t\tthis.tiles.traverse( null, ( tile, _, depth ) => {\n\n\t\t\tmaxDepth = Math.max( maxDepth, depth );\n\t\t\tmaxError = Math.max( maxError, tile.geometricError );\n\n\t\t}, false );\n\n\t\tthis.extremeDebugDepth = maxDepth;\n\t\tthis.extremeDebugError = maxError;\n\n\t}\n\n\t_onUpdateAfter() {\n\n\t\tconst { tiles, colorMode } = this;\n\n\t\tif ( ! tiles.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.materialsNeedUpdate ) {\n\n\t\t\ttiles.forEachLoadedModel( scene => {\n\n\t\t\t\tthis._updateMaterial( scene );\n\n\t\t\t} );\n\t\t\tthis.materialsNeedUpdate = false;\n\n\t\t}\n\n\t\t// set box or sphere visibility\n\t\tthis.boxGroup.visible = this.displayBoxBounds;\n\t\tthis.sphereGroup.visible = this.displaySphereBounds;\n\t\tthis.regionGroup.visible = this.displayRegionBounds;\n\n\t\t// get max values to use for materials\n\t\tlet maxDepth = - 1;\n\t\tif ( this.maxDebugDepth === - 1 ) {\n\n\t\t\tmaxDepth = this.extremeDebugDepth;\n\n\t\t} else {\n\n\t\t\tmaxDepth = this.maxDebugDepth;\n\n\t\t}\n\n\t\tlet maxError = - 1;\n\t\tif ( this.maxDebugError === - 1 ) {\n\n\t\t\tmaxError = this.extremeDebugError;\n\n\t\t} else {\n\n\t\t\tmaxError = this.maxDebugError;\n\n\t\t}\n\n\t\tlet maxDistance = - 1;\n\t\tif ( this.maxDebugDistance === - 1 ) {\n\n\t\t\ttiles.getBoundingSphere( _sphere );\n\t\t\tmaxDistance = _sphere.radius;\n\n\t\t} else {\n\n\t\t\tmaxDistance = this.maxDebugDistance;\n\n\t\t}\n\n\t\tconst { errorTarget, visibleTiles } = tiles;\n\t\tlet sortedTiles;\n\t\tif ( colorMode === LOAD_ORDER ) {\n\n\t\t\tsortedTiles = Array.from( visibleTiles ).sort( ( a, b ) => {\n\n\t\t\t\treturn a[ LOAD_TIME ] - b[ LOAD_TIME ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// update plugins\n\t\tvisibleTiles.forEach( tile => {\n\n\t\t\tconst scene = tile.cached.scene;\n\n\t\t\t// create a random color per-tile\n\t\t\tlet h, s, l;\n\t\t\tif ( colorMode === RANDOM_COLOR ) {\n\n\t\t\t\th = Math.random();\n\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t}\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( colorMode === RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\th = Math.random();\n\t\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t\t}\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tif ( colorMode !== RANDOM_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( colorMode !== RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_NODE_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the color on the basic material\n\t\t\t\t\tswitch ( colorMode ) {\n\n\t\t\t\t\t\tcase DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depth / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase RELATIVE_DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depthFromRenderedParent / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase SCREEN_ERROR: {\n\n\t\t\t\t\t\t\tconst val = tile.__error / errorTarget;\n\t\t\t\t\t\t\tif ( val > 1.0 ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setRGB( 1.0, 0.0, 0.0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase GEOMETRIC_ERROR: {\n\n\t\t\t\t\t\t\tconst val = Math.min( tile.geometricError / maxError, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase DISTANCE: {\n\n\t\t\t\t\t\t\t// We don't update the distance if the geometric error is 0.0 so\n\t\t\t\t\t\t\t// it will always be black.\n\t\t\t\t\t\t\tconst val = Math.min( tile.__distanceFromCamera / maxDistance, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase IS_LEAF: {\n\n\t\t\t\t\t\t\tif ( ! tile.children || tile.children.length === 0 ) {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 1.0, c.material.color );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 0.0, c.material.color );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase RANDOM_NODE_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_NODE_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_NODE_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase RANDOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase CUSTOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( this.customColorCallback ) {\n\n\t\t\t\t\t\t\t\tthis.customColorCallback( tile, c );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'DebugTilesRenderer: customColorCallback not defined' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase LOAD_ORDER: {\n\n\t\t\t\t\t\t\tconst value = sortedTiles.indexOf( tile );\n\t\t\t\t\t\t\tthis.getDebugColor( value / ( sortedTiles.length - 1 ), c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t_onTileVisibilityChange( tile, visible ) {\n\n\t\tif ( this.displayParentBounds ) {\n\n\t\t\tTraversalUtils.traverseAncestors( tile, current => {\n\n\t\t\t\tif ( current[ PARENT_BOUND_REF_COUNT ] == null ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( visible ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] ++;\n\n\t\t\t\t} else if ( current[ PARENT_BOUND_REF_COUNT ] > 0 ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] --;\n\n\t\t\t\t}\n\n\t\t\t\tconst tileVisible = ( current === tile && visible ) || ( this.displayParentBounds && current[ PARENT_BOUND_REF_COUNT ] > 0 );\n\n\t\t\t\tthis._updateBoundHelper( current, tileVisible );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tthis._updateBoundHelper( tile, visible );\n\n\t\t}\n\n\t}\n\n\t_createBoundHelper( tile ) {\n\n\t\tconst tiles = this.tiles;\n\t\tconst cached = tile.cached;\n\t\tconst { sphere, obb, region } = cached.boundingVolume;\n\t\tif ( obb ) {\n\n\t\t\t// Create debug bounding box\n\t\t\t// In some cases the bounding box may have a scale of 0 in one dimension resulting\n\t\t\t// in the NaNs in an extracted rotation so we disable matrix updates instead.\n\t\t\tconst boxHelperGroup = new Group();\n\t\t\tboxHelperGroup.name = 'DebugTilesRenderer.boxHelperGroup';\n\t\t\tboxHelperGroup.matrix.copy( obb.transform );\n\t\t\tboxHelperGroup.matrixAutoUpdate = false;\n\n\t\t\tconst boxHelper = new Box3Helper( obb.box, getIndexedRandomColor( tile.__depth ) );\n\t\t\tboxHelper.raycast = emptyRaycast;\n\t\t\tboxHelperGroup.add( boxHelper );\n\n\t\t\tcached.boxHelperGroup = boxHelperGroup;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displayBoxBounds ) {\n\n\t\t\t\tthis.boxGroup.add( boxHelperGroup );\n\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sphere ) {\n\n\t\t\t// Create debug bounding sphere\n\t\t\tconst sphereHelper = new SphereHelper( sphere, getIndexedRandomColor( tile.__depth ) );\n\t\t\tsphereHelper.raycast = emptyRaycast;\n\t\t\tcached.sphereHelper = sphereHelper;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displaySphereBounds ) {\n\n\t\t\t\tthis.sphereGroup.add( sphereHelper );\n\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( region ) {\n\n\t\t\t// Create debug bounding region\n\t\t\tconst regionHelper = new EllipsoidRegionLineHelper( region, getIndexedRandomColor( tile.__depth ) );\n\t\t\tregionHelper.raycast = emptyRaycast;\n\n\t\t\t// recenter the geometry to avoid rendering artifacts\n\t\t\tconst sphere = new Sphere();\n\t\t\tregion.getBoundingSphere( sphere );\n\t\t\tregionHelper.position.copy( sphere.center );\n\n\t\t\tsphere.center.multiplyScalar( - 1 );\n\t\t\tregionHelper.geometry.translate( ...sphere.center );\n\n\t\t\tcached.regionHelper = regionHelper;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displayRegionBounds ) {\n\n\t\t\t\tthis.regionGroup.add( regionHelper );\n\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateHelperMaterial( tile, material ) {\n\n\t\tif ( tile.__visible || ! this.displayParentBounds ) {\n\n\t\t\tmaterial.opacity = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.opacity = 0.2;\n\n\t\t}\n\n\t\tconst transparent = material.transparent;\n\t\tmaterial.transparent = material.opacity < 1;\n\t\tif ( material.transparent !== transparent ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t_updateBoundHelper( tile, visible ) {\n\n\t\tconst cached = tile.cached;\n\n\t\tif ( ! cached ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst sphereGroup = this.sphereGroup;\n\t\tconst boxGroup = this.boxGroup;\n\t\tconst regionGroup = this.regionGroup;\n\n\t\tif ( visible && ( cached.boxHelperGroup == null && cached.sphereHelper == null && cached.regionHelper == null ) ) {\n\n\t\t\tthis._createBoundHelper( tile );\n\n\t\t}\n\n\t\tconst boxHelperGroup = cached.boxHelperGroup;\n\t\tconst sphereHelper = cached.sphereHelper;\n\t\tconst regionHelper = cached.regionHelper;\n\n\t\tif ( ! visible ) {\n\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.remove( boxHelperGroup );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.remove( sphereHelper );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.remove( regionHelper );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// TODO: consider updating the volumes based on the bounding regions here in case they've been changed\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.add( boxHelperGroup );\n\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, boxHelperGroup.children[ 0 ].material );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.add( sphereHelper );\n\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, sphereHelper.material );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.add( regionHelper );\n\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, regionHelper.material );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateMaterial( scene ) {\n\n\t\t// update the materials for debug rendering\n\t\tconst { colorMode, unlit } = this;\n\t\tscene.traverse( c => {\n\n\t\t\tif ( ! c.material ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currMaterial = c.material;\n\t\t\tconst originalMaterial = c[ ORIGINAL_MATERIAL ];\n\n\t\t\t// dispose the previous material\n\t\t\tif ( currMaterial !== originalMaterial ) {\n\n\t\t\t\tcurrMaterial.dispose();\n\n\t\t\t}\n\n\t\t\t// assign the new material\n\t\t\tif ( colorMode !== NONE || unlit ) {\n\n\t\t\t\tif ( c.isPoints ) {\n\n\t\t\t\t\tconst pointsMaterial = new PointsMaterial();\n\t\t\t\t\tpointsMaterial.size = originalMaterial.size;\n\t\t\t\t\tpointsMaterial.sizeAttenuation = originalMaterial.sizeAttenuation;\n\t\t\t\t\tc.material = pointsMaterial;\n\n\t\t\t\t} else if ( unlit ) {\n\n\t\t\t\t\tc.material = new MeshBasicMaterial();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = new MeshStandardMaterial();\n\t\t\t\t\tc.material.flatShading = true;\n\n\t\t\t\t}\n\n\t\t\t\t// if no debug rendering is happening then assign the material properties\n\t\t\t\tif ( colorMode === NONE ) {\n\n\t\t\t\t\tc.material.map = originalMaterial.map;\n\t\t\t\t\tc.material.color.set( originalMaterial.color );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tc.material = originalMaterial;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t_onLoadModel( scene, tile ) {\n\n\t\ttile[ LOAD_TIME ] = performance.now();\n\n\t\t// Cache the original materials\n\t\tscene.traverse( c => {\n\n\t\t\tconst material = c.material;\n\t\t\tif ( material ) {\n\n\t\t\t\tc[ ORIGINAL_MATERIAL ] = material;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Update the materials to align with the settings\n\t\tthis._updateMaterial( scene );\n\n\t}\n\n\t_onDisposeModel( tile ) {\n\n\t\tconst cached = tile.cached;\n\t\tif ( cached.boxHelperGroup ) {\n\n\t\t\tcached.boxHelperGroup.children[ 0 ].geometry.dispose();\n\t\t\tdelete cached.boxHelperGroup;\n\n\t\t}\n\n\t\tif ( cached.sphereHelper ) {\n\n\t\t\tcached.sphereHelper.geometry.dispose();\n\t\t\tdelete cached.sphereHelper;\n\n\t\t}\n\n\t\tif ( cached.regionHelper ) {\n\n\t\t\tcached.regionHelper.geometry.dispose();\n\t\t\tdelete cached.regionHelper;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst tiles = this.tiles;\n\n\t\ttiles.removeEventListener( 'load-tileset', this._onLoadTilesetCB );\n\t\ttiles.removeEventListener( 'load-model', this._onLoadModelCB );\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModelCB );\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfterCB );\n\t\ttiles.removeEventListener( 'tile-visibility-change', this._onTileVisibilityChangeCB );\n\n\t\t// reset all materials\n\t\tthis.colorMode = NONE;\n\t\tthis.unlit = false;\n\t\ttiles.forEachLoadedModel( scene => {\n\n\t\t\tthis._updateMaterial( scene );\n\n\t\t} );\n\n\t\t// dispose of all helper objects\n\t\ttiles.traverse( tile => {\n\n\t\t\tthis._onDisposeModel( tile );\n\n\t\t} );\n\n\t\tthis.boxGroup?.removeFromParent();\n\t\tthis.sphereGroup?.removeFromParent();\n\t\tthis.regionGroup?.removeFromParent();\n\n\t}\n\n}\n","import { TiledImageSource } from './TiledImageSource.js';\n\nexport class DeepZoomImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst { url = null, ...rest } = options;\n\t\tsuper( rest );\n\n\t\tthis.url = url;\n\t\tthis.format = null;\n\t\tthis.stem = null;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn `${ this.stem }_files/${ level }/${ x }_${ y }.${ this.format }`;\n\n\t}\n\n\tinit() {\n\n\t\tconst { url } = this;\n\n\t\t// If implementing DeepZoom with limitations like a fixed orthographic camera perspective then\n\t\t// the target tile level can be immediately 'jumped' to for the entire image and in-view tiles\n\t\t// can be immediately queried without any hierarchy traversal. Due the flexibility of camera\n\t\t// type, rotation, and per-tile error calculation we generate a hierarchy.\n\t\treturn this\n\t\t\t.fetchData( url, this.fetchOptions )\n\t\t\t.then( res => res.text() )\n\t\t\t.then( text => {\n\n\t\t\t\tconst xml = new DOMParser().parseFromString( text, 'text/xml' );\n\t\t\t\tif ( xml.querySelector( 'DisplayRects' ) || xml.querySelector( 'Collection' ) ) {\n\n\t\t\t\t\tthrow new Error( 'DeepZoomImagesPlugin: DisplayRect and Collection DZI files not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\t// Elements\n\t\t\t\tconst image = xml.querySelector( 'Image' );\n\t\t\t\tconst size = image.querySelector( 'Size' );\n\n\t\t\t\t// Image properties\n\t\t\t\tconst width = parseInt( size.getAttribute( 'Width' ) );\n\t\t\t\tconst height = parseInt( size.getAttribute( 'Height' ) );\n\t\t\t\tconst tileSize = parseInt( image.getAttribute( 'TileSize' ) );\n\t\t\t\tconst overlap = parseInt( image.getAttribute( 'Overlap' ) );\n\t\t\t\tconst format = image.getAttribute( 'Format' );\n\n\t\t\t\t// Assign deep zoom properties\n\t\t\t\tthis.format = format;\n\t\t\t\tthis.stem = url.split( /\\.[^.]+$/g )[ 0 ];\n\n\t\t\t\t// Assign tiling properties\n\t\t\t\tconst { tiling } = this;\n\t\t\t\tconst levels = Math.ceil( Math.log2( Math.max( width, height ) ) ) + 1;\n\t\t\t\ttiling.flipY = true;\n\t\t\t\ttiling.pixelOverlap = overlap;\n\t\t\t\ttiling.generateLevels( levels, 1, 1, {\n\t\t\t\t\ttilePixelWidth: tileSize,\n\t\t\t\t\ttilePixelHeight: tileSize,\n\t\t\t\t\tpixelWidth: width,\n\t\t\t\t\tpixelHeight: height,\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t}\n\n}\n","import { ImageFormatPlugin } from './ImageFormatPlugin.js';\nimport { DeepZoomImageSource } from './sources/DeepZoomImageSource.js';\n\n// Support for Deep Zoom Image format\n// https://openseadragon.github.io/\n\n// https://learn.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc645077(v=vs.95)\nexport class DeepZoomImagePlugin extends ImageFormatPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst { url, ...rest } = options;\n\t\tsuper( rest );\n\n\t\tthis.name = 'DZI_TILES_PLUGIN';\n\t\tthis.imageSource = new DeepZoomImageSource( { url } );\n\n\t}\n\n}\n","import { WGS84_RADIUS, LoaderBase } from '3d-tiles-renderer/core';\nimport { ProjectionScheme } from '../images/utils/ProjectionScheme.js';\nimport { MathUtils } from 'three';\n\nconst EQUATOR_CIRCUMFERENCE = WGS84_RADIUS * Math.PI * 2;\nconst mercatorProjection = /* @__PURE__ */ new ProjectionScheme( 'EPSG:3857' );\n\nfunction isEPSG4326( crs ) {\n\n\treturn /:4326$/i.test( crs );\n\n}\n\nfunction isWebMercator( crs ) {\n\n\treturn /:3857$/i.test( crs );\n\n}\n\n// parse a series of space-separated numbers\nfunction parseTuple( tuple ) {\n\n\treturn tuple.trim().split( /\\s+/ ).map( v => parseFloat( v ) );\n\n}\n\n// swap the tuple order to lon, lat if crs is EPSG:4326 since the tiles renderer project\n// expects lon, lat order\nfunction correctTupleOrder( tuple, crs ) {\n\n\tif ( isEPSG4326( crs ) ) {\n\n\t\t[ tuple[ 1 ], tuple[ 0 ] ] = [ tuple[ 0 ], tuple[ 1 ] ];\n\n\t}\n\n}\n\n// web mercator specifies bounding boxes etc as meters assuming the width and height of the full image span\n// is aligned to the globe equator circumference.\nfunction correctTupleUnits( tuple, crs ) {\n\n\tif ( isWebMercator( crs ) ) {\n\n\t\ttuple[ 0 ] = mercatorProjection.convertProjectionToLongitude( 0.5 + tuple[ 0 ] / EQUATOR_CIRCUMFERENCE );\n\t\ttuple[ 1 ] = mercatorProjection.convertProjectionToLatitude( 0.5 + tuple[ 1 ] / EQUATOR_CIRCUMFERENCE );\n\n\t\t// to degrees\n\t\ttuple[ 0 ] *= MathUtils.RAD2DEG;\n\t\ttuple[ 1 ] *= MathUtils.RAD2DEG;\n\n\t\treturn tuple;\n\n\t}\n\n}\n\nfunction tupleToRadians( tuple ) {\n\n\ttuple[ 0 ] *= MathUtils.DEG2RAD;\n\ttuple[ 1 ] *= MathUtils.DEG2RAD;\n\n}\n\nexport class WMTSCapabilitiesLoader extends LoaderBase {\n\n\tparse( buffer ) {\n\n\t\tconst str = new TextDecoder( 'utf-8' ).decode( new Uint8Array( buffer ) );\n\t\tconst xml = new DOMParser().parseFromString( str, 'text/xml' );\n\t\tconst contents = xml.querySelector( 'Contents' );\n\n\t\tconst tileMatrixSets = getChildrenByTag( contents, 'TileMatrixSet' ).map( el => parseTileMatrixSet( el ) );\n\t\tconst layers = getChildrenByTag( contents, 'Layer' ).map( el => parseLayer( el ) );\n\t\tconst serviceIdentification = parseServiceIdentification( xml.querySelector( 'ServiceIdentification' ) );\n\n\t\tlayers.forEach( layer => {\n\n\t\t\tlayer.tileMatrixSets = layer.tileMatrixSetLinks.map( key => {\n\n\t\t\t\treturn tileMatrixSets.find( tms => tms.identifier === key );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\treturn {\n\t\t\tserviceIdentification,\n\t\t\ttileMatrixSets,\n\t\t\tlayers,\n\t\t};\n\n\t}\n\n}\n\n// parse <ows:ServiceIdentification> tag\nfunction parseServiceIdentification( el ) {\n\n\tconst title = el.querySelector( 'Title' ).textContent;\n\tconst abstract = el.querySelector( 'Abstract' )?.textContent || '';\n\tconst serviceType = el.querySelector( 'ServiceType' ).textContent;\n\tconst serviceTypeVersion = el.querySelector( 'ServiceTypeVersion' ).textContent;\n\n\treturn {\n\t\ttitle,\n\t\tabstract,\n\t\tserviceType,\n\t\tserviceTypeVersion,\n\t};\n\n}\n\n// parse <Layers> tag\nfunction parseLayer( el ) {\n\n\tconst title = el.querySelector( 'Title' ).textContent;\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst format = el.querySelector( 'Format' ).textContent;\n\tconst resourceUrls = getChildrenByTag( el, 'ResourceURL' ).map( el => {\n\n\t\treturn parseResourceUrl( el );\n\n\t} );\n\tconst tileMatrixSetLinks = getChildrenByTag( el, 'TileMatrixSetLink' ).map( el => {\n\n\t\treturn getChildrenByTag( el, 'TileMatrixSet' )[ 0 ].textContent;\n\n\t} );\n\tconst styles = getChildrenByTag( el, 'Style' ).map( el => {\n\n\t\treturn parseStyle( el );\n\n\t} );\n\tconst dimensions = getChildrenByTag( el, 'Dimension' ).map( el => {\n\n\t\treturn parseDimension( el );\n\n\t} );\n\n\tlet boundingBox = parseBoundingBox( el.querySelector( 'WGS84BoundingBox' ) );\n\tif ( ! boundingBox ) {\n\n\t\tboundingBox = parseBoundingBox( el.querySelector( 'BoundingBox' ) );\n\n\t}\n\n\treturn {\n\t\ttitle,\n\t\tidentifier,\n\t\tformat,\n\t\tdimensions,\n\t\ttileMatrixSetLinks,\n\t\tstyles,\n\t\tboundingBox,\n\t\tresourceUrls,\n\t};\n\n}\n\n// parse layer <ResourceURL> tag\nfunction parseResourceUrl( el ) {\n\n\tconst template = el.getAttribute( 'template' );\n\tconst format = el.getAttribute( 'format' );\n\tconst resourceType = el.getAttribute( 'resourceType' );\n\n\treturn {\n\t\ttemplate,\n\t\tformat,\n\t\tresourceType,\n\t};\n\n}\n\n// parse layer <Dimension> tag\nfunction parseDimension( el ) {\n\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst uom = el.querySelector( 'UOM' )?.textContent || '';\n\tconst defaultValue = el.querySelector( 'Default' ).textContent;\n\tconst current = el.querySelector( 'Current' )?.textContent === 'true';\n\tconst values = getChildrenByTag( el, 'Value' ).map( el => el.textContent );\n\treturn {\n\t\tidentifier,\n\t\tuom,\n\t\tdefaultValue,\n\t\tcurrent,\n\t\tvalues,\n\t};\n\n}\n\n// parse <ows:WGS84BoundingBox> and <BoundingBox> tags\nfunction parseBoundingBox( el ) {\n\n\tif ( ! el ) {\n\n\t\treturn null;\n\n\t}\n\n\tconst crs = el.nodeName.endsWith( 'WGS84BoundingBox' ) ? 'urn:ogc:def:crs:CRS::84' : el.getAttribute( 'crs' );\n\tconst lowerCorner = parseTuple( el.querySelector( 'LowerCorner' ).textContent );\n\tconst upperCorner = parseTuple( el.querySelector( 'UpperCorner' ).textContent );\n\n\tcorrectTupleOrder( lowerCorner, crs );\n\tcorrectTupleOrder( upperCorner, crs );\n\n\tcorrectTupleUnits( lowerCorner, crs );\n\tcorrectTupleUnits( upperCorner, crs );\n\n\ttupleToRadians( lowerCorner );\n\ttupleToRadians( upperCorner );\n\n\treturn {\n\t\tcrs,\n\t\tlowerCorner,\n\t\tupperCorner,\n\t\tbounds: [ ...lowerCorner, ...upperCorner ],\n\t};\n\n}\n\n// parse layer <Style> tag\nfunction parseStyle( el ) {\n\n\tconst title = el.querySelector( 'Title' )?.textContent || null;\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst isDefault = el.getAttribute( 'isDefault' ) === 'true';\n\n\treturn {\n\t\ttitle,\n\t\tidentifier,\n\t\tisDefault,\n\t};\n\n}\n\n// parse <TileMatrixSet> tag\nfunction parseTileMatrixSet( el ) {\n\n\tconst supportedCRS = el.querySelector( 'SupportedCRS' ).textContent;\n\tconst title = el.querySelector( 'Title' )?.textContent || '';\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst abstract = el.querySelector( 'Abstract' )?.textContent || '';\n\tconst tileMatrices = [];\n\tel\n\t\t.querySelectorAll( 'TileMatrix' )\n\t\t.forEach( ( el, i ) => {\n\n\t\t\tconst tm = parseTileMatrix( el );\n\n\t\t\tconst pixelSpan = 0.00028 * tm.scaleDenominator;\n\t\t\tconst groundWidth = tm.tileWidth * tm.matrixWidth * pixelSpan;\n\t\t\tconst groundHeight = tm.tileHeight * tm.matrixHeight * pixelSpan;\n\t\t\tlet bottomRightCorner;\n\n\t\t\tcorrectTupleOrder( tm.topLeftCorner, supportedCRS );\n\n\t\t\tif ( isWebMercator( supportedCRS ) ) {\n\n\t\t\t\tbottomRightCorner = [\n\t\t\t\t\ttm.topLeftCorner[ 0 ] + groundWidth,\n\t\t\t\t\ttm.topLeftCorner[ 1 ] - groundHeight,\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\tbottomRightCorner = [\n\t\t\t\t\ttm.topLeftCorner[ 0 ] + 360 * groundWidth / EQUATOR_CIRCUMFERENCE,\n\t\t\t\t\ttm.topLeftCorner[ 1 ] - 360 * groundHeight / EQUATOR_CIRCUMFERENCE,\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t\tcorrectTupleUnits( bottomRightCorner, supportedCRS );\n\t\t\tcorrectTupleUnits( tm.topLeftCorner, supportedCRS );\n\n\t\t\ttupleToRadians( bottomRightCorner );\n\t\t\ttupleToRadians( tm.topLeftCorner );\n\n\t\t\t// construct the bounds\n\t\t\ttm.bounds = [ ...tm.topLeftCorner, ...bottomRightCorner ];\n\n\t\t\t// ensure min and max order is correct\n\t\t\t[ tm.bounds[ 1 ], tm.bounds[ 3 ] ] = [ tm.bounds[ 3 ], tm.bounds[ 1 ] ];\n\n\t\t\ttileMatrices.push( tm );\n\n\t\t} );\n\n\treturn {\n\t\ttitle,\n\t\tidentifier,\n\t\tabstract,\n\t\tsupportedCRS,\n\t\ttileMatrices,\n\t};\n\n}\n\n// parse tile matrix set <TileMatrix> tag\nfunction parseTileMatrix( el ) {\n\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst tileWidth = parseFloat( el.querySelector( 'TileWidth' ).textContent );\n\tconst tileHeight = parseFloat( el.querySelector( 'TileHeight' ).textContent );\n\tconst matrixWidth = parseFloat( el.querySelector( 'MatrixWidth' ).textContent );\n\tconst matrixHeight = parseFloat( el.querySelector( 'MatrixHeight' ).textContent );\n\tconst scaleDenominator = parseFloat( el.querySelector( 'ScaleDenominator' ).textContent );\n\tconst topLeftCorner = parseTuple( el.querySelector( 'TopLeftCorner' ).textContent );\n\n\treturn {\n\t\tidentifier,\n\t\ttileWidth,\n\t\ttileHeight,\n\t\tmatrixWidth,\n\t\tmatrixHeight,\n\t\tscaleDenominator,\n\t\ttopLeftCorner,\n\t\tbounds: null,\n\t};\n\n}\n\n// utility for finding immediate children by tag name\nfunction getChildrenByTag( el, tag ) {\n\n\treturn [ ...el.children ].filter( c => c.tagName === tag );\n\n}\n","import { LoaderBase, WGS84_RADIUS } from '3d-tiles-renderer/core';\nimport { ProjectionScheme } from '../images/utils/ProjectionScheme';\nimport { MathUtils } from 'three';\n\nconst EQUATOR_CIRCUMFERENCE = WGS84_RADIUS * Math.PI * 2;\nconst mercatorProjection = /* @__PURE__ */ new ProjectionScheme( 'EPSG:3857' );\n\n// helper CRS checks (same logic used in WMTSCapabilitiesLoader)\n// TODO: Share these helpers with the WMTSCapabilitiesLoader\nfunction isEPSG4326( crs ) {\n\n\treturn /:4326$/i.test( crs );\n\n}\n\nfunction isWebMercator( crs ) {\n\n\treturn /:3857$/i.test( crs );\n\n}\n\n// convert from meters (web mercator) to degrees using the mercator projection helper\nfunction correctTupleUnits( tuple, crs ) {\n\n\t// TODO: consolidate this Mercator-units with WMTSLoader / move a helper onto ProjectionScheme?\n\tif ( isWebMercator( crs ) ) {\n\n\t\ttuple[ 0 ] = mercatorProjection.convertProjectionToLongitude( 0.5 + tuple[ 0 ] / ( Math.PI * 2 * EQUATOR_CIRCUMFERENCE ) );\n\t\ttuple[ 1 ] = mercatorProjection.convertProjectionToLatitude( 0.5 + tuple[ 1 ] / ( Math.PI * 2 * EQUATOR_CIRCUMFERENCE ) );\n\n\t\t// to degrees\n\t\ttuple[ 0 ] *= MathUtils.RAD2DEG;\n\t\ttuple[ 1 ] *= MathUtils.RAD2DEG;\n\n\t}\n\n\treturn tuple;\n\n}\n\n// swap order when CRS is EPSG:4326 (WMS 1.3 axis order)\nfunction correctTupleOrder( tuple, crs, version ) {\n\n\t// Before WMS 1.3.0 the latitude, longitude order for EPSG:4326 was declared to be in reverse and has\n\t// been fixed in later versions. Correct the tuple order for consistency if loading a file from a prior version.\n\t// See https://gis.stackexchange.com/questions/23347/getmap-wms-1-1-1-vs-1-3-0\n\tconst [ major, minor ] = version.split( '.' ).map( v => parseInt( v ) );\n\tconst shouldFixTupleOrder = major === 1 && minor < 3 || major < 1;\n\tif ( isEPSG4326( crs ) && shouldFixTupleOrder ) {\n\n\t\t[ tuple[ 0 ], tuple[ 1 ] ] = [ tuple[ 1 ], tuple[ 0 ] ];\n\n\t}\n\n}\n\n// convert degrees to radians in-place\nfunction tupleToRadians( tuple ) {\n\n\ttuple[ 0 ] *= MathUtils.DEG2RAD;\n\ttuple[ 1 ] *= MathUtils.DEG2RAD;\n\n}\n\n// parse \"BoundingBox\" tag for WMS using same normalization as WMTS (lower/upper corners, unit & order correction)\nfunction parseBoundingBox( el, version ) {\n\n\tif ( ! el ) {\n\n\t\treturn null;\n\n\t}\n\n\t// WMS may use CRS / crs / SRS attribute\n\tconst crs = el.getAttribute( 'CRS' ) || el.getAttribute( 'crs' ) || el.getAttribute( 'SRS' ) || '';\n\n\tconst minx = parseFloat( el.getAttribute( 'minx' ) );\n\tconst miny = parseFloat( el.getAttribute( 'miny' ) );\n\tconst maxx = parseFloat( el.getAttribute( 'maxx' ) );\n\tconst maxy = parseFloat( el.getAttribute( 'maxy' ) );\n\n\tconst lowerCorner = [ minx, miny ];\n\tconst upperCorner = [ maxx, maxy ];\n\n\tcorrectTupleOrder( lowerCorner, crs, version );\n\tcorrectTupleOrder( upperCorner, crs, version );\n\n\t// correct units if web mercator meters were provided\n\tcorrectTupleUnits( lowerCorner, crs );\n\tcorrectTupleUnits( upperCorner, crs );\n\n\t// convert degrees to radians for internal consistency with other loaders\n\ttupleToRadians( lowerCorner );\n\ttupleToRadians( upperCorner );\n\n\t// bounds in order [minLon, minLat, maxLon, maxLat] (in radians)\n\treturn { crs, bounds: [ ...lowerCorner, ...upperCorner ] };\n\n}\n\n// EX_GeographicBoundingBox (>= 1.3.0) and LatLonBoundingBox (<= 1.1.1) define the bounds of content\nfunction parseEXGeographicBoundingBox( el ) {\n\n\tconst west = parseFloat( el.querySelector( 'westBoundLongitude' ).textContent );\n\tconst east = parseFloat( el.querySelector( 'eastBoundLongitude' ).textContent );\n\tconst south = parseFloat( el.querySelector( 'southBoundLatitude' ).textContent );\n\tconst north = parseFloat( el.querySelector( 'northBoundLatitude' ).textContent );\n\n\tconst lowerCorner = [ west, south ];\n\tconst upperCorner = [ east, north ];\n\n\ttupleToRadians( lowerCorner );\n\ttupleToRadians( upperCorner );\n\n\treturn [ ...lowerCorner, ...upperCorner ];\n\n}\n\nfunction parseLatLonBoundingBox( el ) {\n\n\tconst west = parseFloat( el.getAttribute( 'minx' ).textContent );\n\tconst east = parseFloat( el.getAttribute( 'maxx' ).textContent );\n\tconst south = parseFloat( el.getAttribute( 'miny' ).textContent );\n\tconst north = parseFloat( el.getAttribute( 'maxy' ).textContent );\n\n\tconst lowerCorner = [ west, south ];\n\tconst upperCorner = [ east, north ];\n\n\ttupleToRadians( lowerCorner );\n\ttupleToRadians( upperCorner );\n\n\treturn [ ...lowerCorner, ...upperCorner ];\n\n}\n\n// Parse the \"Style\" tag along with the associated legend elements\nfunction parseStyle( el ) {\n\n\tconst name = el.querySelector( 'Name' ).textContent;\n\tconst title = el.querySelector( 'Title' ).textContent;\n\tconst legends = [ ...el.querySelectorAll( 'LegendURL' ) ].map( legendEl => {\n\n\t\t// width/height attrs on LegendURL\n\t\tconst width = parseInt( legendEl.getAttribute( 'width' ) );\n\t\tconst height = parseInt( legendEl.getAttribute( 'height' ) );\n\n\t\t// collect Format elements inside LegendURL\n\t\tconst format = legendEl.querySelector( 'Format' ).textContent;\n\n\t\t// OnlineResource may use xlink namespace\n\t\tconst online = legendEl.querySelector( 'OnlineResource' );\n\t\tconst url = readOnlineResourceHref( online );\n\n\t\treturn {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tformat,\n\t\t\turl,\n\t\t};\n\n\t} );\n\n\treturn {\n\t\tname,\n\t\ttitle,\n\t\tlegends,\n\t};\n\n}\n\n// Parse a <Layer> element in addition to the child layers\nfunction parseLayer( el, version, inheritedProperties = {} ) {\n\n\t// TODO:\n\t// - Dimension\n\t// - Attribution\n\t// - AuthorityURL\n\t// - MinScaleDenominator\n\t// - MaxScaleDenominator\n\t// - cascaded, noSubsets, fixedWidth, fixedHeight attributes\n\n\tlet {\n\t\tstyles = [],\n\t\tcrs = [],\n\t\tcontentBoundingBox = null,\n\t\tqueryable = false,\n\t\topaque = false,\n\t} = inheritedProperties;\n\n\tconst name = el.querySelector( ':scope > Name' )?.textContent || null;\n\tconst title = el.querySelector( ':scope > Title' )?.textContent || '';\n\tconst abstract = el.querySelector( ':scope > Abstract' )?.textContent || '';\n\tconst keywords = [ ...el.querySelectorAll( ':scope > Keyword' ) ].map( k => k.textContent );\n\tconst boundingBoxEl = [ ...el.querySelectorAll( ':scope > BoundingBox' ) ];\n\tconst boundingBoxes = boundingBoxEl.map( el => parseBoundingBox( el, version ) );\n\n\t// See section 7.2.4.8 in the specification\n\t// Handle added inherited properties\n\tcrs = [\n\t\t...crs,\n\t\t...Array.from( el.querySelectorAll( 'CRS' ) ).map( c => c.textContent ),\n\t];\n\tstyles = [\n\t\t...styles,\n\t\t...Array.from( el.querySelectorAll( ':scope > Style' ) ).map( el => parseStyle( el ) ),\n\t];\n\n\t// Handle replaced inherited properties\n\tif ( el.hasAttribute( 'queryable' ) ) {\n\n\t\tqueryable = el.getAttribute( 'queryable' ) === '1';\n\n\t}\n\n\tif ( el.hasAttribute( 'opaque' ) ) {\n\n\t\topaque = el.getAttribute( 'opaque' ) === '1';\n\n\t}\n\n\t// These bounding boxes define the range of data present in the data set in a cartographic range\n\tif ( el.querySelector( 'EX_GeographicBoundingBox' ) ) {\n\n\t\tcontentBoundingBox = parseEXGeographicBoundingBox( el.querySelector( 'EX_GeographicBoundingBox' ) );\n\n\t} else if ( el.querySelector( 'LatLonBoundingBox' ) ) {\n\n\t\tcontentBoundingBox = parseLatLonBoundingBox( el.querySelector( 'LatLonBoundingBox' ) );\n\n\t}\n\n\t// Recursively parse sublayers\n\tconst subLayers = Array.from( el.querySelectorAll( ':scope > Layer' ) ).map( el => {\n\n\t\treturn parseLayer( el, version, {\n\t\t\t// add\n\t\t\tstyles,\n\t\t\tcrs,\n\n\t\t\t// replace\n\t\t\tcontentBoundingBox,\n\t\t\tqueryable,\n\t\t\topaque,\n\t\t} );\n\n\t} );\n\n\treturn {\n\t\tname,\n\t\ttitle,\n\t\tabstract,\n\t\tqueryable,\n\t\topaque,\n\t\tkeywords,\n\t\tcrs,\n\t\tboundingBoxes,\n\t\tcontentBoundingBox,\n\t\tstyles,\n\t\tsubLayers,\n\t};\n\n}\n\n// Parse the \"Service\" tag\nfunction parseService( el ) {\n\n\treturn {\n\t\tname: el.querySelector( 'Name' )?.textContent || '',\n\t\ttitle: el.querySelector( 'Title' )?.textContent || '',\n\t\tabstract: el.querySelector( 'Abstract' )?.textContent || '',\n\t\tkeywords: Array.from( el.querySelectorAll( 'Keyword' ) ).map( k => k.textContent ),\n\n\t\tmaxWidth: parseFloat( el.querySelector( 'MaxWidth' ) ) || null,\n\t\tmaxHeight: parseFloat( el.querySelector( 'MaxHeight' ) ) || null,\n\t\tlayerLimit: parseFloat( el.querySelector( 'LayerLimit' ) ) || null,\n\t};\n\n}\n\n// helper: read OnlineResource href (handles xlink namespace)\nfunction readOnlineResourceHref( el ) {\n\n\tif ( ! el ) {\n\n\t\treturn '';\n\n\t}\n\n\treturn (\n\t\tel.getAttribute( 'xlink:href' ) ||\n\t\tel.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) ||\n\t\t''\n\t).trim();\n\n}\n\n// parse a single operation (e.g. GetMap, GetCapabilities, GetFeatureInfo)\nfunction parseRequestOperation( opEl ) {\n\n\tconst formats = Array.from( opEl.querySelectorAll( 'Format' ) ).map( f => f.textContent.trim() );\n\tconst dcp = Array.from( opEl.querySelectorAll( 'DCPType' ) ).map( dcp => {\n\n\t\tconst httpEl = dcp.querySelector( 'HTTP' );\n\n\t\tconst getEl = httpEl.querySelector( 'Get OnlineResource' ) || httpEl.querySelector( 'Get > OnlineResource' ) || httpEl.querySelector( 'Get' );\n\t\tconst postEl = httpEl.querySelector( 'Post OnlineResource' ) || httpEl.querySelector( 'Post > OnlineResource' ) || httpEl.querySelector( 'Post' );\n\t\tconst getHref = readOnlineResourceHref( getEl );\n\t\tconst postHref = readOnlineResourceHref( postEl );\n\t\treturn { type: 'HTTP', get: getHref, post: postHref };\n\n\t} );\n\n\treturn { formats, dcp, href: dcp[ 0 ].get };\n\n}\n\n// parse the whole Request section, returning an object keyed by operation local name\nfunction parseRequest( el ) {\n\n\tconst ops = {};\n\tArray\n\t\t.from( el.querySelectorAll( ':scope > *' ) )\n\t\t.forEach( ( child ) => {\n\n\t\t\tconst requestType = child.localName;\n\t\t\tops[ requestType ] = parseRequestOperation( child );\n\n\t\t} );\n\treturn ops;\n\n}\n\n// Collect all sub layers with a valid name into a flat array for easier access\nfunction collectLayers( layers, target = [] ) {\n\n\tlayers.forEach( l => {\n\n\t\tif ( l.name !== null ) {\n\n\t\t\ttarget.push( l );\n\n\t\t}\n\n\t\tcollectLayers( l.subLayers, target );\n\n\t} );\n\n\treturn target;\n\n}\n\nexport class WMSCapabilitiesLoader extends LoaderBase {\n\n\tparse( buffer ) {\n\n\t\tconst str = new TextDecoder( 'utf-8' ).decode( new Uint8Array( buffer ) );\n\t\tconst xml = new DOMParser().parseFromString( str, 'text/xml' );\n\t\tconst rootEl = xml.querySelector( 'WMS_Capabilities' ) || xml.querySelector( 'WMT_MS_Capabilities' );\n\t\tconst version = rootEl.getAttribute( 'version' );\n\n\t\tconst capabilityEl = xml.querySelector( 'Capability' );\n\t\tconst service = parseService( xml.querySelector( ':scope > Service' ) );\n\t\tconst request = parseRequest( capabilityEl.querySelector( ':scope > Request' ) );\n\t\tconst rootLayers = Array.from( capabilityEl.querySelectorAll( ':scope > Layer' ) ).map( el => parseLayer( el, version ) );\n\t\tconst layers = collectLayers( rootLayers );\n\n\t\treturn { version, service, layers, request };\n\n\t}\n\n}\n"],"names":["_uv","Vector2","TILE_X","TILE_Y","TILE_LEVEL","ImageFormatPlugin","options","pixelSize","center","useRecommendedSettings","imageSource","tiles","url","plugin","buffer","tile","extension","uri","abortSignal","tx","ty","level","texture","sx","sy","x","y","z","boundingBox","geometry","PlaneGeometry","mesh","Mesh","MeshBasicMaterial","uvRange","uv","i","MathUtils","tiling","maxLevel","baseUrl","minLevel","tileCountX","tileCountY","children","child","tileset","pixelWidth","pixelHeight","minX","minY","maxX","maxY","extentsX","extentsY","centerX","centerY","geometricError","maxLevelInfo","cx","cy","_v0","Vector3","_v1","getCartographicToMeterDerivative","ellipsoid","lat","lon","lonp","latp","dy","MIN_LON_VERTS","MIN_LAT_VERTS","_pos","_norm","_sphere","Sphere","EllipsoidProjectionTilesPlugin","shape","endCaps","rest","args","projection","west","south","east","north","latVerts","lonVerts","yVerts","xVerts","minU","minV","maxU","maxV","position","normal","vertCount","latLimit","vStep","prevLat","nextLat","u","v","isRoot","normalizedBounds","cartBounds","tilePixelWidth","tilePixelHeight","tileUWidth","tileVWidth","midLat","midV","lonFactor","latFactor","xDeriv","yDeriv","projectedPixelWidth","ProjectionScheme","scheme","ratio","mercatorN","value","yp","hash","DataCache","item","cache","data","key","abortController","info","res","e","force","disposeCallback","result","doBoundsIntersect","b","aMinX","aMinY","aMaxX","aMaxY","bMinX","bMinY","bMaxX","bMaxY","TilingScheme","levels","_a","tileBounds","rootTileX","rootTileY","invLevel","levelPixelWidth","levelPixelHeight","bx","by","normalized","flipY","xStride","yStride","range","contentBounds","clampedMinX","clampedMinY","clampedMaxX","clampedMaxY","minTile","maxTile","minTileX","minTileY","maxTileX","maxTileY","rminx","rminy","rmaxx","rmaxy","tminx","tminy","tmaxx","tmaxy","bounds","fullMinU","fullMinV","fullMaxU","fullMaxV","clampToProjection","pixelOverlap","tileLeft","tileTop","tileRight","tileBottom","extents","invCenterY","normBounds","clampBounds","TiledImageSource","fetchOptions","blob","imageBitmap","Texture","SRGBColorSpace","tex","format","type","image","generateMipmaps","width","height","bytes","TextureUtils","tokens","signal","XYZImageSource","tileDimension","TMSImageSource","tileSets","text","xml","tileFormat","tileSetList","ts","a","tileWidth","tileHeight","srs","order","isCRS84","crs","WMTSImageSource","capabilities","layer","tileMatrixSet","style","dimensions","l","tms","supportedCRS","tm","matrixWidth","matrixHeight","dim","WMSImageSource","styles","contentBoundingBox","version","transparent","crsParam","bboxParam","minx","miny","maxx","maxy","params","XYZTilesPlugin","TMSTilesPlugin","WMTSTilesPlugin","WMSTilesPlugin","_tri","Triangle","_uvh","QuantizedMeshLoader","QuantizedMeshLoaderBase","manager","DefaultLoadingManager","Ellipsoid","solid","skirtLength","smoothSkirtNormals","generateNormals","minLat","maxLat","minLon","maxLon","header","indices","vertexData","edgeIndices","extensions","BufferGeometry","material","MeshStandardMaterial","hasNormalExtension","includeNormals","vertexCount","positions","uvs","indexArr","normals","groupOffset","materialIndex","readUVHeight","readPosition","extNormals","tempGeometry","tempIndexBuffer","BufferAttribute","generatedNormals","indexOffset","westIndices","eastIndices","southIndices","northIndices","offset","westStrip","constructEdgeStrip","eastStrip","southStrip","northStrip","indexBuffer","mask","size","maskBuffer","map","DataTexture","RGFormat","UnsignedByteType","LinearMipMapLinearFilter","LinearFilter","index","target","h","heightOffset","topUvs","topPos","botUvs","botPos","sideIndices","triCount","t0","t1","b0","b1","total","botOffset","i3","nx","ny","nz","SPLIT_VALUE","vertNames","_vec","Vector4","_v2","GeometryClipper","ClipTrianglePool","callback","splitOperations","runPermutations","keepPositive","object","toRemove","c","m","trianglePool","attributeList","sourceGeometry","nextIndex","vertToNewIndexMap","start","count","i0","i1","i2","tri","triangles","s","t","barycoord","pushTriangle","attributes","sourceMesh","attr","cons","newAttr","keepNegative","edges","lerpValues","nv","pValue","npValue","tri0","tri1","tri2","minBound","negativeSide","ClipTriangle","vn","bc","name","readInterpolatedAttribute","hashVertex","arr","other","e0","e1","alpha","targetVertex","fromVertex","attribute","_cart","_pos0","_pos1","_pos2","_pos3","_temp","_temp2","_uv0","_uv1","_uv2","QuantizedMeshClipper","left","bottom","getUvSplitOperation","botResult","skirtResult","capGroup","capResult","pushVertex","pos","norm","capIndex","capUv","capPosition","capNormal","capTriangles","triOffset","ne","u0","u1","capLength","xUvOffset","yUvOffset","resultMesh","vertexIsClipped","posArr","uvArr","point","axis","TILE_AVAILABLE","INITIAL_HEIGHT_RANGE","isTileAvailable","available","availableSet","startX","startY","endX","endY","getMaxLevel","maxzoom","getMetadataAvailability","metadataAvailability","getTileHasMetadata","getContentUrl","QuantizedMeshPlugin","json","layerProjection","attribution","searchParams","clipper","loader","minHeight","maxHeight","metadata","isAvailable","region","hasChildren","CesiumIonAuthPluginImpl","asset","_matrix","Matrix4","UpdateOnChangePlugin","camera","didCamerasChange","matrix","needsUpdate","compressAttribute","arrayType","minValue","array","newAttribute","itemSize","j","compressPositionAttribute","min","max","maxValue","bbMinValue","bbMaxValue","TileCompressionPlugin","scene","disableMipmaps","compressIndex","compressUvs","compressNormals","compressPosition","uvType","normalType","positionType","uv1","uv2","uv3","getField","def","isNumericType","isFloatComponentType","isVectorType","isMatrixType","readDataFromBufferToType","getTypeInstance","property","componentType","Matrix2","Matrix3","isTypeInstance","getArrayConstructorFromComponentType","resolveDefault","resolveDefaultElement","defaultValue","resolveNoData","noData","performResolution","isNoDataEqual","elements","normalizeValue","adjustValueScaleOffset","scale","adjustFromType","adjustMatrix","adjustVector","adjustScalar","initializeFromProperty","overrideCount","initializeFromClass","properties","prop","typeToComponentCount","ClassProperty","enums","accessorProperty","countOverride","enumSet","getEnumName","match","PropertySetAccessor","definition","classes","propertyClass","PropertyAttributeClassProperty","classProperty","attributeProperty","PropertyAttributeAccessor","id","PropertyTableClassProperty","tableProperty","buffers","arrayOffsets","arrayOffsetType","bufferCons","PropertyTableAccessor","bufferView","dataArray","stringIndex","stringLength","stringOffsets","stringOffsetType","stringOffsetBuffer","byteArray","byteIndex","bitIndex","_box","Box2","_TextureReadUtility","WebGLRenderer","WebGLRenderTarget","FullScreenQuad","ShaderMaterial","CustomBlending","ZeroFactor","OneFactor","_renderer","_target","pixel","dstPixel","TextureReadUtility","reader","getTextureCoordAttribute","getTriangleVertexIndices","faceIndex","getTexCoord","texCoord","getTexelIndices","fx","fy","px","py","_srcPixel","_dstPixel","PropertyTextureClassProperty","textureProperty","PropertyTextureAccessor","names","results","n","textures","accessorProperties","readTextureSampleResults","length","BufferCons","readBuffer","lj","StructuralMetadata","nodeMetadata","schema","propertyTables","propertyTextures","propertyAttributes","tableAccessors","textureAccessors","attributeAccessors","tableIndices","ids","table","triangle","accessor","promises","promise","attributeIndex","acc","EXT_NAME","getRelevantTextures","parser","textureCount","getRelevantBuffers","values","GLTFStructuralMetadataExtension","extensionsUsed","schemaPromise","rootExtension","path","requestHeader","crossOrigin","finalUri","fileLoader","FileLoader","rootMetadata","meshes","primitives","primitive","_pixel","getMaxBarycoordIndex","MeshFeatures","featureIds","closestIndex","featureId","nullFeatureId","channels","forEachPrimitiveExtension","GLTFMeshFeaturesExtension","GLTFCesiumRTCExtension","GLTFExtensionsPlugin","GLTFLoader","sphere","ReorientationPlugin","up","azimuth","elevation","roll","recenter","minRadii","cart","group","OBJECT_FRAME","UnloadTilesPlugin","delay","bytesTarget","LRUCache","DeferCallbackManager","lruCache","deferCallbacks","unloadCallback","visible","clamp","FadeManager","fadeState","state","cb","noState","time","delta","fadeOutTarget","fadeInTarget","fadeOut","fadeIn","fadeInSign","fadeOutSign","FADE_PARAMS","wrapFadeMaterial","previousOnBeforeCompile","shader","FadeMaterialManager","fadeParams","PassThroughBatchedMesh","proxyTarget","instanceInfo","otherInstanceInfo","FadeBatchedMesh","oldFadeTexture","fadeArray","fadeTexture","InstanceDataTexture","src","dst","len","instance","prevValue","newValue","HAS_POPPED_IN","_fromPos","_toPos","_fromQuat","Quaternion","_toQuat","_scale","onUpdateBefore","fadeManager","onUpdateAfter","fadeMaterialManager","displayActiveTiles","fadingBefore","prevCameraTransforms","maximumFadeOutTiles","batchedMesh","cameras","fadingAfter","isMovingFast","currMatrix","prevMatrix","angleTo","positionTo","isFadingOut","TilesFadePlugin","otherBatchedMesh","wasFading","isFading","batchedPlugin","instanceIds","vec1","vec2","ModelViewBatchedMesh","BatchedMesh","instanceId","matrices","renderer","matricesTexture","modelViewMatricesTexture","Source","modelViewArray","instanceMatrix","shadowCamera","depthMaterial","_raycastMesh","_batchIntersects","ExpandingBatchedMesh","reservedVertexRange","reservedIndexRange","needsIndex","neededIndexCount","neededVertexCount","bestIndex","bestScore","freeGeometryIds","geometryInfo","reservedIndexCount","reservedVertexCount","score","expandPercent","_freeGeometryIds","resultId","needsMoreSpace","vertexNeedsSpace","indexNeedsSpace","batchedIndex","batchedPosition","newIndexCount","newVertexCount","addIndexCount","addVertexCount","geometryId","newCount","raycaster","intersects","batchGeometry","drawRange","Box3","intersect","isColorWhite","color","convertMapToArrayTexture","_textureRenderQuad","_whiteTex","BatchedTilesPlugin","REVISION","gl","instanceCount","textureSize","textureOptions","arrayTarget","WebGLArrayRenderTarget","indexCount","currentRenderTarget","targetDepth","newArrayTarget","hasCorrectAttributes","attrs","batchedAttrs","canAddMeshes","_invMatrix","_raycaster","Raycaster","_doubleSidedMaterial","DoubleSide","RAYCAST_DISTANCE","calculateSphere","TileFlatteningPlugin","active","positionsUpdated","positionsMap","shapes","geomMap","direction","thresholdMode","threshold","flattenRange","r2","ray","hit","rangeAlpha","aboveThreshold","_camera","OrthographicCamera","_color","Color","TiledTextureComposer","ComposeTextureMaterial","renderTarget","span","quad","currentAutoClear","currentClearColor","currentClearAlpha","QuadKeyImageSource","subdomains","quadKey","digit","forEachTileInBounds","clampedLevel","getGeometryCartographicChannel","geomToEllipsoidMatrix","posAttr","centerLat","centerLon","getMeshesCartographicRange","meshToEllipsoidMatrix","clampedRange","getGeometryPlanarChannel","meshToFrame","aspectRatio","minW","maxW","getMeshesPlanarRange","worldToFrame","heightRange","OVERLAY_PARAMS","wrapOverlaysMaterial","calculateArcRatioAtPoint","latDelta","GeoJSONImageSource","geojson","pointRadius","strokeStyle","strokeWidth","fillStyle","geoBounds","tileBoundsDeg","canvas","ctx","features","feature","CanvasTexture","boundsDeg","featureBoundsDeg","fminX","fminY","fmaxX","fmaxY","coordinates","expandBoundsByPoint","ring","polygon","root","geomTypes","g","minLonDeg","minLatDeg","maxLonDeg","maxLatDeg","projectPoint","calculateAspectRatio","latRad","lonRad","pxLat","WGS84_ELLIPSOID","drawRatio","line","rIndex","fMinLon","fMinLat","fMaxLon","fMaxLat","_center","_sphereCenter","_normal","SPLIT_TILE_DATA","SPLIT_HASH","markOverlayImages","overlay","doRelease","o","p","markImages","tl","filteredPromises","countTilesInRange","ImageOverlayPlugin","overlays","resolution","enableTileSplitting","tileComposer","processQueue","PriorityQueue","tileA","tileB","visibleA","visibleB","overlayChanged","maxJobs","overlayInfo","tileControllers","pendingTiles","processedTiles","tileInfo","meshInfo","meshRange","meshRangeMarked","rangeMarked","bytesUsed","MemoryUtils.getTextureByteLength","initialization","fullDispose","parents","parent","clone","collectChildren","centerTarget","box","splitDirections","hashTokens","token","ortho0","ortho1","directions","average","dir","dotProduct","splitDirection","matrixWorld","boundingVolume","maxSqRadius","sqRadius","controller","normalizedRange","w","wProj","hProj","initTile","err","PriorityQueueItemRemovedError","usedTextures","tileController","heightInRange","ImageOverlay","opacity","frame","preprocessURL","alphaMask","alphaInvert","XYZTilesOverlay","GeoJSONOverlay","WMSTilesOverlay","WMTSTilesOverlay","TMSTilesOverlay","CesiumIonOverlay","apiToken","autoRefreshToken","assetId","CesiumIonAuth","att","session","xyzUrl","mapStyle","metadataUrl","GoogleMapsOverlay","sessionOptions","logoUrl","GoogleCloudAuth","LoadRegionPlugin","regions","inShape","inMask","maxError","BaseRegion","errorTarget","tilesRenderer","SphereRegion","RayRegion","Ray","OBBRegion","obb","OBB","_vector","axes","SphereHelper","LineSegments","angleSteps","axis1","axis2","angle","LineBasicMaterial","_norm2","getRegionGeometry","ellipsoidRegion","computeNormals","latStart","latEnd","lonStart","lonEnd","heightStart","heightEnd","BoxGeometry","refPosition","EllipsoidRegionLineHelper","EllipsoidRegion","EdgesGeometry","ORIGINAL_MATERIAL","HAS_RANDOM_COLOR","HAS_RANDOM_NODE_COLOR","LOAD_TIME","PARENT_BOUND_REF_COUNT","emptyRaycast","colors","getIndexedRandomColor","NONE","SCREEN_ERROR","GEOMETRIC_ERROR","DISTANCE","DEPTH","RELATIVE_DEPTH","IS_LEAF","RANDOM_COLOR","RANDOM_NODE_COLOR","CUSTOM_COLOR","LOAD_ORDER","ColorModes","DebugTilesPlugin","tilesGroup","Group","targetTile","maxDepth","_","depth","colorMode","maxDistance","visibleTiles","sortedTiles","val","TraversalUtils.traverseAncestors","current","tileVisible","cached","boxHelperGroup","boxHelper","Box3Helper","sphereHelper","regionHelper","sphereGroup","boxGroup","regionGroup","unlit","currMaterial","originalMaterial","pointsMaterial","PointsMaterial","_b","_c","DeepZoomImageSource","tileSize","overlap","DeepZoomImagePlugin","EQUATOR_CIRCUMFERENCE","WGS84_RADIUS","mercatorProjection","isEPSG4326","isWebMercator","parseTuple","tuple","correctTupleOrder","correctTupleUnits","tupleToRadians","WMTSCapabilitiesLoader","LoaderBase","str","contents","tileMatrixSets","getChildrenByTag","el","parseTileMatrixSet","layers","parseLayer","serviceIdentification","parseServiceIdentification","title","abstract","serviceType","serviceTypeVersion","identifier","resourceUrls","parseResourceUrl","tileMatrixSetLinks","parseStyle","parseDimension","parseBoundingBox","template","resourceType","uom","lowerCorner","upperCorner","isDefault","tileMatrices","parseTileMatrix","pixelSpan","groundWidth","groundHeight","bottomRightCorner","scaleDenominator","topLeftCorner","tag","major","minor","shouldFixTupleOrder","parseEXGeographicBoundingBox","parseLatLonBoundingBox","legends","legendEl","online","readOnlineResourceHref","inheritedProperties","queryable","opaque","keywords","k","boundingBoxes","subLayers","parseService","parseRequestOperation","opEl","formats","f","dcp","httpEl","getEl","postEl","getHref","postHref","parseRequest","ops","requestType","collectLayers","WMSCapabilitiesLoader","capabilityEl","service","request","rootLayers"],"mappings":"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"}