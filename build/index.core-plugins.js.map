{"version":3,"file":"index.core-plugins.js","sources":["../src/core/plugins/SUBTREELoader.js","../src/core/plugins/ImplicitTilingPlugin.js","../src/core/plugins/EnforceNonZeroErrorPlugin.js"],"sourcesContent":["/**\n * Structure almost identical to Cesium, also the comments and the names are kept\n * https://github.com/CesiumGS/cesium/blob/0a69f67b393ba194eefb7254600811c4b712ddc0/packages/engine/Source/Scene/Implicit3DTileContent.js\n */\nimport { LoaderBase, LoaderUtils } from '3d-tiles-renderer/core';\n\nfunction isOctreeSubdivision( tile ) {\n\n\treturn tile.__implicitRoot.implicitTiling.subdivisionScheme === 'OCTREE';\n\n}\n\nfunction getBoundsDivider( tile ) {\n\n\treturn isOctreeSubdivision( tile ) ? 8 : 4;\n\n}\n\nfunction getSubtreeCoordinates( tile, parentTile ) {\n\n\tif ( ! parentTile ) {\n\n\t\treturn [ 0, 0, 0 ];\n\n\t}\n\n\tconst x = 2 * parentTile.__x + ( tile.__subtreeIdx % 2 );\n\tconst y = 2 * parentTile.__y + ( Math.floor( tile.__subtreeIdx / 2 ) % 2 );\n\tconst z = isOctreeSubdivision( tile ) ?\n\t\t2 * parentTile.__z + ( Math.floor( tile.__subtreeIdx / 4 ) % 2 ) : 0;\n\treturn [ x, y, z ];\n\n}\n\nclass SubtreeTile {\n\n\tconstructor( parentTile, childMortonIndex ) {\n\n\t\tthis.parent = parentTile;\n\t\tthis.children = [];\n\t\tthis.__level = parentTile.__level + 1;\n\t\tthis.__implicitRoot = parentTile.__implicitRoot;\n\t\t// Index inside the tree\n\t\tthis.__subtreeIdx = childMortonIndex;\n\t\t[ this.__x, this.__y, this.__z ] = getSubtreeCoordinates( this, parentTile );\n\n\t}\n\n\tstatic copy( tile ) {\n\n\t\tconst copyTile = {};\n\t\tcopyTile.children = [];\n\t\tcopyTile.__level = tile.__level;\n\t\tcopyTile.__implicitRoot = tile.__implicitRoot;\n\t\t// Index inside the tree\n\t\tcopyTile.__subtreeIdx = tile.__subtreeIdx;\n\t\t[ copyTile.__x, copyTile.__y, copyTile.__z ] = [ tile.__x, tile.__y, tile.__z ];\n\t\tcopyTile.boundingVolume = tile.boundingVolume;\n\t\tcopyTile.geometricError = tile.geometricError;\n\t\treturn copyTile;\n\n\t}\n\n}\n\nexport class SUBTREELoader extends LoaderBase {\n\n\tconstructor( tile ) {\n\n\t\tsuper();\n\t\tthis.tile = tile;\n\t\tthis.rootTile = tile.__implicitRoot;\t// The implicit root tile\n\t\tthis.workingPath = null;\n\n\t}\n\n\t/**\n\t * A helper object for storing the two parts of the subtree binary\n\t *\n\t * @typedef {object} Subtree\n\t * @property {number} version\n\t * @property {JSON} subtreeJson\n\t * @property {ArrayBuffer} subtreeByte\n\t * @private\n\t */\n\n\t/**\n\t *\n\t * @param buffer\n\t * @return {Subtree}\n\t */\n\tparseBuffer( buffer ) {\n\n\t\tconst dataView = new DataView( buffer );\n\t\tlet offset = 0;\n\t\t// 16-byte header\n\t\t// 4 bytes\n\t\tconst magic = LoaderUtils.readMagicBytes( dataView );\n\t\tconsole.assert( magic === 'subt', 'SUBTREELoader: The magic bytes equal \"subt\".' );\n\t\toffset += 4;\n\t\t// 4 bytes\n\t\tconst version = dataView.getUint32( offset, true );\n\t\tconsole.assert( version === 1, 'SUBTREELoader: The version listed in the header is \"1\".' );\n\t\toffset += 4;\n\t\t// From Cesium\n\t\t// Read the bottom 32 bits of the 64-bit byte length.\n\t\t// This is ok for now because:\n\t\t// 1) not all browsers have native 64-bit operations\n\t\t// 2) the data is well under 4GB\n\t\t// 8 bytes\n\t\tconst jsonLength = dataView.getUint32( offset, true );\n\t\toffset += 8;\n\t\t// 8 bytes\n\t\tconst byteLength = dataView.getUint32( offset, true );\n\t\toffset += 8;\n\t\tconst subtreeJson = JSON.parse( LoaderUtils.arrayToString( new Uint8Array( buffer, offset, jsonLength ) ) );\n\t\toffset += jsonLength;\n\t\tconst subtreeByte = buffer.slice( offset, offset + byteLength );\n\t\treturn {\n\t\t\tversion,\n\t\t\tsubtreeJson,\n\t\t\tsubtreeByte\n\t\t};\n\n\t}\n\n\n\tasync parse( buffer ) {\n\n\t\t// todo here : handle json\n\t\tconst subtree = this.parseBuffer( buffer );\n\t\tconst subtreeJson = subtree.subtreeJson;\n\n\t\t// TODO Handle metadata\n\t\t/*\n\t\t const subtreeMetadata = subtreeJson.subtreeMetadata;\n\t\t subtree._metadata = subtreeMetadata;\n\t\t*/\n\n\t\t/*\n\t\t\tTile availability indicates which tiles exist within the subtree\n\t\t\tContent availability indicates which tiles have associated content resources\n\t\t\tChild subtree availability indicates what subtrees are reachable from this subtree\n\t\t*/\n\n\t\t// After identifying how availability is stored, put the results in this new array for consistent processing later\n\t\tsubtreeJson.contentAvailabilityHeaders = [].concat( subtreeJson.contentAvailability );\n\t\tconst bufferHeaders = this.preprocessBuffers( subtreeJson.buffers );\n\t\tconst bufferViewHeaders = this.preprocessBufferViews(\n\t\t\tsubtreeJson.bufferViews,\n\t\t\tbufferHeaders\n\t\t);\n\n\t\t// Buffers and buffer views are inactive until explicitly marked active.\n\t\t// This way we can avoid fetching buffers that will not be used.\n\t\tthis.markActiveBufferViews( subtreeJson, bufferViewHeaders );\n\n\t\t// Await the active buffers. If a buffer is external (isExternal === true),\n\t\t// fetch it from its URI.\n\t\tconst buffersU8 = await this.requestActiveBuffers(\n\t\t\tbufferHeaders,\n\t\t\tsubtree.subtreeByte\n\t\t);\n\t\tconst bufferViewsU8 = this.parseActiveBufferViews( bufferViewHeaders, buffersU8 );\n\t\tthis.parseAvailability( subtree, subtreeJson, bufferViewsU8 );\n\t\tthis.expandSubtree( this.tile, subtree );\n\n\t}\n\n\t/**\n\t * Determine which buffer views need to be loaded into memory. This includes:\n\t *\n\t * <ul>\n\t * <li>The tile availability bitstream (if a bitstream is defined)</li>\n\t * <li>The content availability bitstream(s) (if a bitstream is defined)</li>\n\t * <li>The child subtree availability bitstream (if a bitstream is defined)</li>\n\t * </ul>\n\t *\n\t * <p>\n\t * This function modifies the buffer view headers' isActive flags in place.\n\t * </p>\n\t *\n\t * @param {JSON} subtreeJson The JSON chunk from the subtree\n\t * @param {BufferViewHeader[]} bufferViewHeaders The preprocessed buffer view headers\n\t * @private\n\t */\n\tmarkActiveBufferViews( subtreeJson, bufferViewHeaders ) {\n\n\t\tlet header;\n\t\tconst tileAvailabilityHeader = subtreeJson.tileAvailability;\n\t\t// Check for bitstream first, which is part of the current schema.\n\t\t// bufferView is the name of the bitstream from an older schema.\n\t\tif ( ! isNaN( tileAvailabilityHeader.bitstream ) ) {\n\n\t\t\theader = bufferViewHeaders[ tileAvailabilityHeader.bitstream ];\n\n\t\t} else if ( ! isNaN( tileAvailabilityHeader.bufferView ) ) {\n\n\t\t\theader = bufferViewHeaders[ tileAvailabilityHeader.bufferView ];\n\n\t\t}\n\n\t\tif ( header ) {\n\n\t\t\theader.isActive = true;\n\t\t\theader.bufferHeader.isActive = true;\n\n\t\t}\n\n\t\tconst contentAvailabilityHeaders = subtreeJson.contentAvailabilityHeaders;\n\t\tfor ( let i = 0; i < contentAvailabilityHeaders.length; i ++ ) {\n\n\t\t\theader = undefined;\n\t\t\tif ( ! isNaN( contentAvailabilityHeaders[ i ].bitstream ) ) {\n\n\t\t\t\theader = bufferViewHeaders[ contentAvailabilityHeaders[ i ].bitstream ];\n\n\t\t\t} else if ( ! isNaN( contentAvailabilityHeaders[ i ].bufferView ) ) {\n\n\t\t\t\theader = bufferViewHeaders[ contentAvailabilityHeaders[ i ].bufferView ];\n\n\t\t\t}\n\n\t\t\tif ( header ) {\n\n\t\t\t\theader.isActive = true;\n\t\t\t\theader.bufferHeader.isActive = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\theader = undefined;\n\t\tconst childSubtreeAvailabilityHeader = subtreeJson.childSubtreeAvailability;\n\t\tif ( ! isNaN( childSubtreeAvailabilityHeader.bitstream ) ) {\n\n\t\t\theader = bufferViewHeaders[ childSubtreeAvailabilityHeader.bitstream ];\n\n\t\t} else if ( ! isNaN( childSubtreeAvailabilityHeader.bufferView ) ) {\n\n\t\t\theader = bufferViewHeaders[ childSubtreeAvailabilityHeader.bufferView ];\n\n\t\t}\n\n\t\tif ( header ) {\n\n\t\t\theader.isActive = true;\n\t\t\theader.bufferHeader.isActive = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Go through the list of buffers and gather all the active ones into\n\t * a dictionary.\n\t * <p>\n\t * The results are put into a dictionary object. The keys are indices of\n\t * buffers, and the values are Uint8Arrays of the contents. Only buffers\n\t * marked with the isActive flag are fetched.\n\t * </p>\n\t * <p>\n\t * The internal buffer (the subtree's binary chunk) is also stored in this\n\t * dictionary if it is marked active.\n\t * </p>\n\t * @param {BufferHeader[]} bufferHeaders The preprocessed buffer headers\n\t * @param {ArrayBuffer} internalBuffer The binary chunk of the subtree file\n\t * @returns {object} buffersU8 A dictionary of buffer index to a Uint8Array of its contents.\n\t * @private\n\t */\n\tasync requestActiveBuffers( bufferHeaders, internalBuffer ) {\n\n\t\tconst promises = [];\n\t\tfor ( let i = 0; i < bufferHeaders.length; i ++ ) {\n\n\t\t\tconst bufferHeader = bufferHeaders[ i ];\n\t\t\t// If the buffer is not active, resolve with undefined.\n\t\t\tif ( ! bufferHeader.isActive ) {\n\n\t\t\t\tpromises.push( Promise.resolve( ) );\n\n\t\t\t} else if ( bufferHeader.isExternal ) {\n\n\t\t\t\t// Get the absolute URI of the external buffer.\n\t\t\t\tconst url = this.parseImplicitURIBuffer(\n\t\t\t\t\tthis.tile,\n\t\t\t\t\tthis.rootTile.implicitTiling.subtrees.uri,\n\t\t\t\t\tbufferHeader.uri\n\t\t\t\t);\n\n\t\t\t\tconst fetchPromise = fetch( url, this.fetchOptions )\n\t\t\t\t\t.then( response => {\n\n\t\t\t\t\t\tif ( ! response.ok ) {\n\n\t\t\t\t\t\t\tthrow new Error( `SUBTREELoader: Failed to load external buffer from ${ bufferHeader.uri } with error code ${ response.status }.` );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn response.arrayBuffer();\n\n\t\t\t\t\t} )\n\t\t\t\t\t.then( arrayBuffer => new Uint8Array( arrayBuffer ) );\n\n\t\t\t\tpromises.push( fetchPromise );\n\n\t\t\t} else {\n\n\t\t\t\tpromises.push( Promise.resolve( new Uint8Array( internalBuffer ) ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferResults = await Promise.all( promises );\n\t\tconst buffersU8 = {};\n\t\tfor ( let i = 0; i < bufferResults.length; i ++ ) {\n\n\t\t\tconst result = bufferResults[ i ];\n\t\t\tif ( result ) {\n\n\t\t\t\tbuffersU8[ i ] = result;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn buffersU8;\n\n\t}\n\n\t/**\n\t * Go through the list of buffer views, and if they are marked as active,\n\t * extract a subarray from one of the active buffers.\n\t *\n\t * @param {BufferViewHeader[]} bufferViewHeaders\n\t * @param {object} buffersU8 A dictionary of buffer index to a Uint8Array of its contents.\n\t * @returns {object} A dictionary of buffer view index to a Uint8Array of its contents.\n\t * @private\n\t */\n\tparseActiveBufferViews( bufferViewHeaders, buffersU8 ) {\n\n\t\tconst bufferViewsU8 = {};\n\t\tfor ( let i = 0; i < bufferViewHeaders.length; i ++ ) {\n\n\t\t\tconst bufferViewHeader = bufferViewHeaders[ i ];\n\t\t\tif ( ! bufferViewHeader.isActive ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst start = bufferViewHeader.byteOffset;\n\t\t\tconst end = start + bufferViewHeader.byteLength;\n\t\t\tconst buffer = buffersU8[ bufferViewHeader.buffer ];\n\t\t\tbufferViewsU8[ i ] = buffer.slice( start, end );\n\n\t\t}\n\n\t\treturn bufferViewsU8;\n\n\t}\n\n\t/**\n\t * A buffer header is the JSON header from the subtree JSON chunk plus\n\t * a couple extra boolean flags for easy reference.\n\t *\n\t * Buffers are assumed inactive until explicitly marked active. This is used\n\t * to avoid fetching unneeded buffers.\n\t *\n\t * @typedef {object} BufferHeader\n\t * @property {boolean} isActive Whether this buffer is currently used.\n\t * @property {string} [uri] The URI of the buffer (external buffers only)\n\t * @property {number} byteLength The byte length of the buffer, including any padding contained within.\n\t * @private\n\t */\n\n\t/**\n\t * Iterate over the list of buffers from the subtree JSON and add the isActive field for easier parsing later.\n\t * This modifies the objects in place.\n\t * @param {Object[]} [bufferHeaders=[]] The JSON from subtreeJson.buffers.\n\t * @returns {BufferHeader[]} The same array of headers with additional fields.\n\t * @private\n\t */\n\tpreprocessBuffers( bufferHeaders = [] ) {\n\n\t\tfor ( let i = 0; i < bufferHeaders.length; i ++ ) {\n\n\t\t\tconst bufferHeader = bufferHeaders[ i ];\n\t\t\tbufferHeader.isActive = false;\n\t\t\tbufferHeader.isExternal = !! bufferHeader.uri;\n\n\t\t}\n\n\t\treturn bufferHeaders;\n\n\t}\n\n\t/**\n\t * A buffer view header is the JSON header from the subtree JSON chunk plus\n\t * the isActive flag and a reference to the header for the underlying buffer.\n\t *\n\t * @typedef {object} BufferViewHeader\n\t * @property {BufferHeader} bufferHeader A reference to the header for the underlying buffer\n\t * @property {boolean} isActive Whether this bufferView is currently used.\n\t * @property {number} buffer The index of the underlying buffer.\n\t * @property {number} byteOffset The start byte of the bufferView within the buffer.\n\t * @property {number} byteLength The length of the bufferView. No padding is included in this length.\n\t * @private\n\t */\n\n\t/**\n\t * Iterate the list of buffer views from the subtree JSON and add the\n\t * isActive flag. Also save a reference to the bufferHeader.\n\t *\n\t * @param {Object[]} [bufferViewHeaders=[]] The JSON from subtree.bufferViews.\n\t * @param {BufferHeader[]} bufferHeaders The preprocessed buffer headers.\n\t * @returns {BufferViewHeader[]} The same array of bufferView headers with additional fields.\n\t * @private\n\t */\n\tpreprocessBufferViews( bufferViewHeaders = [], bufferHeaders ) {\n\n\t\tfor ( let i = 0; i < bufferViewHeaders.length; i ++ ) {\n\n\t\t\tconst bufferViewHeader = bufferViewHeaders[ i ];\n\t\t\tbufferViewHeader.bufferHeader = bufferHeaders[ bufferViewHeader.buffer ];\n\t\t\tbufferViewHeader.isActive = false;\n\t\t\t// Keep the external flag for potential use in requestActiveBuffers\n\t\t\tbufferViewHeader.isExternal = bufferViewHeader.bufferHeader.isExternal;\n\n\t\t}\n\n\t\treturn bufferViewHeaders;\n\n\t}\n\n\t/**\n\t * Parse the three availability bitstreams and store them in the subtree.\n\t *\n\t * @param {Subtree} subtree The subtree to modify.\n\t * @param {Object} subtreeJson The subtree JSON.\n\t * @param {Object} bufferViewsU8 A dictionary of buffer view index to a Uint8Array of its contents.\n\t * @private\n\t */\n\tparseAvailability( subtree, subtreeJson, bufferViewsU8 ) {\n\n\t\tconst branchingFactor = getBoundsDivider( this.rootTile );\n\t\tconst subtreeLevels = this.rootTile.implicitTiling.subtreeLevels;\n\t\tconst tileAvailabilityBits =\n\t\t\t( Math.pow( branchingFactor, subtreeLevels ) - 1 ) / ( branchingFactor - 1 );\n\t\tconst childSubtreeBits = Math.pow( branchingFactor, subtreeLevels );\n\t\tsubtree._tileAvailability = this.parseAvailabilityBitstream(\n\t\t\tsubtreeJson.tileAvailability,\n\t\t\tbufferViewsU8,\n\t\t\ttileAvailabilityBits\n\t\t);\n\t\tsubtree._contentAvailabilityBitstreams = [];\n\t\tfor ( let i = 0; i < subtreeJson.contentAvailabilityHeaders.length; i ++ ) {\n\n\t\t\tconst bitstream = this.parseAvailabilityBitstream(\n\t\t\t\tsubtreeJson.contentAvailabilityHeaders[ i ],\n\t\t\t\tbufferViewsU8,\n\t\t\t\t// content availability has the same length as tile availability.\n\t\t\t\ttileAvailabilityBits\n\t\t\t);\n\t\t\tsubtree._contentAvailabilityBitstreams.push( bitstream );\n\n\t\t}\n\n\t\tsubtree._childSubtreeAvailability = this.parseAvailabilityBitstream(\n\t\t\tsubtreeJson.childSubtreeAvailability,\n\t\t\tbufferViewsU8,\n\t\t\tchildSubtreeBits\n\t\t);\n\n\t}\n\n\t/**\n\t * Given the JSON describing an availability bitstream, turn it into an\n\t * in-memory representation using an object. This handles bitstreams from a bufferView.\n\t *\n\t * @param {Object} availabilityJson A JSON object representing the availability.\n\t * @param {Object} bufferViewsU8 A dictionary of buffer view index to its Uint8Array contents.\n\t * @param {number} lengthBits The length of the availability bitstream in bits.\n\t * @returns {object}\n\t * @private\n\t */\n\tparseAvailabilityBitstream(\n\t\tavailabilityJson,\n\t\tbufferViewsU8,\n\t\tlengthBits,\n\t) {\n\n\t\tif ( ! isNaN( availabilityJson.constant ) ) {\n\n\t\t\treturn {\n\t\t\t\tconstant: Boolean( availabilityJson.constant ),\n\t\t\t\tlengthBits: lengthBits,\n\t\t\t};\n\n\t\t}\n\n\t\tlet bufferView;\n\t\t// Check for bitstream first, which is part of the current schema.\n\t\t// bufferView is the name of the bitstream from an older schema.\n\t\tif ( ! isNaN( availabilityJson.bitstream ) ) {\n\n\t\t\tbufferView = bufferViewsU8[ availabilityJson.bitstream ];\n\n\t\t} else if ( ! isNaN( availabilityJson.bufferView ) ) {\n\n\t\t\tbufferView = bufferViewsU8[ availabilityJson.bufferView ];\n\n\t\t}\n\n\t\treturn {\n\t\t\tbitstream: bufferView,\n\t\t\tlengthBits: lengthBits\n\t\t};\n\n\t}\n\n\t/**\n\t * Expand a single subtree tile. This transcodes the subtree into\n\t * a tree of {@link SubtreeTile}. The root of this tree is stored in\n\t * the placeholder tile's children array. This method also creates\n\t * tiles for the child subtrees to be lazily expanded as needed.\n\t *\n\t * @param {Object | SubtreeTile} subtreeRoot The first node of the subtree.\n\t * @param {Subtree} subtree The parsed subtree.\n\t * @private\n\t */\n\texpandSubtree( subtreeRoot, subtree ) {\n\n\t\t// TODO If multiple contents were supported then this tile could contain both renderable and un renderable content.\n\t\tconst contentTile = SubtreeTile.copy( subtreeRoot );\n\t\t// If the subtree root tile has content, then create a placeholder child with cloned parameters\n\t\t// Todo Multiple contents not handled, keep the first content found\n\t\tfor ( let i = 0; subtree && i < subtree._contentAvailabilityBitstreams.length; i ++ ) {\n\n\t\t\tif ( subtree && this.getBit( subtree._contentAvailabilityBitstreams[ i ], 0 ) ) {\n\n\t\t\t\t// Create a child holding the content uri, this child is similar to its parent and doesn't have any children.\n\t\t\t\tcontentTile.content = { uri: this.parseImplicitURI( subtreeRoot, this.rootTile.content.uri ) };\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tsubtreeRoot.children.push( contentTile );\n\t\t// Creating each leaf inside the current subtree.\n\t\tconst bottomRow = this.transcodeSubtreeTiles(\n\t\t\tcontentTile,\n\t\t\tsubtree\n\t\t);\n\t\t// For each child subtree, create a tile containing the uri of the next subtree to fetch.\n\t\tconst childSubtrees = this.listChildSubtrees( subtree, bottomRow );\n\t\tfor ( let i = 0; i < childSubtrees.length; i ++ ) {\n\n\t\t\tconst subtreeLocator = childSubtrees[ i ];\n\t\t\tconst leafTile = subtreeLocator.tile;\n\t\t\tconst subtreeTile = this.deriveChildTile(\n\t\t\t\tnull,\n\t\t\t\tleafTile,\n\t\t\t\tnull,\n\t\t\t\tsubtreeLocator.childMortonIndex\n\t\t\t);\n\t\t\t// Assign subtree uri as content.\n\t\t\tsubtreeTile.content = { uri: this.parseImplicitURI( subtreeTile, this.rootTile.implicitTiling.subtrees.uri ) };\n\t\t\tleafTile.children.push( subtreeTile );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Transcode the implicitly defined tiles within this subtree and generate\n\t * explicit {@link SubtreeTile} objects. This function only transcodes tiles,\n\t * child subtrees are handled separately.\n\t *\n\t * @param {Object | SubtreeTile} subtreeRoot The root of the current subtree.\n\t * @param {Subtree} subtree The subtree to get availability information.\n\t * @returns {Array} The bottom row of transcoded tiles. This is helpful for processing child subtrees.\n\t * @private\n\t */\n\ttranscodeSubtreeTiles( subtreeRoot, subtree ) {\n\n\t\t// Sliding window over the levels of the tree.\n\t\t// Each row is branchingFactor * length of previous row.\n\t\t// Tiles within a row are ordered by Morton index.\n\t\tlet parentRow = [ subtreeRoot ];\n\t\tlet currentRow = [];\n\t\tfor ( let level = 1; level < this.rootTile.implicitTiling.subtreeLevels; level ++ ) {\n\n\t\t\tconst branchingFactor = getBoundsDivider( this.rootTile );\n\t\t\tconst levelOffset = ( Math.pow( branchingFactor, level ) - 1 ) / ( branchingFactor - 1 );\n\t\t\tconst numberOfChildren = branchingFactor * parentRow.length;\n\t\t\tfor ( let childMortonIndex = 0; childMortonIndex < numberOfChildren; childMortonIndex ++ ) {\n\n\t\t\t\tconst childBitIndex = levelOffset + childMortonIndex;\n\t\t\t\tconst parentMortonIndex = childMortonIndex >> Math.log2( branchingFactor );\n\t\t\t\tconst parentTile = parentRow[ parentMortonIndex ];\n\t\t\t\t// Check if tile is available.\n\t\t\t\tif ( ! this.getBit( subtree._tileAvailability, childBitIndex ) ) {\n\n\t\t\t\t\tcurrentRow.push( undefined );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// Create a tile and add it as a child.\n\t\t\t\tconst childTile = this.deriveChildTile(\n\t\t\t\t\tsubtree,\n\t\t\t\t\tparentTile,\n\t\t\t\t\tchildBitIndex,\n\t\t\t\t\tchildMortonIndex\n\t\t\t\t);\n\t\t\t\tparentTile.children.push( childTile );\n\t\t\t\tcurrentRow.push( childTile );\n\n\t\t\t}\n\n\t\t\tparentRow = currentRow;\n\t\t\tcurrentRow = [];\n\n\t\t}\n\n\t\treturn parentRow;\n\n\t}\n\n\t/**\n\t * Given a parent tile and information about which child to create, derive\n\t * the properties of the child tile implicitly.\n\t * <p>\n\t * This creates a real tile for rendering.\n\t * </p>\n\t *\n\t * @param {Subtree} subtree The subtree the child tile belongs to.\n\t * @param {Object | SubtreeTile} parentTile The parent of the new child tile.\n\t * @param {number} childBitIndex The index of the child tile within the tile's availability information.\n\t * @param {number} childMortonIndex The morton index of the child tile relative to its parent.\n\t * @returns {SubtreeTile} The new child tile.\n\t * @private\n\t */\n\tderiveChildTile(\n\t\tsubtree,\n\t\tparentTile,\n\t\tchildBitIndex,\n\t\tchildMortonIndex\n\t) {\n\n\t\tconst subtreeTile = new SubtreeTile( parentTile, childMortonIndex );\n\t\tsubtreeTile.boundingVolume = this.getTileBoundingVolume( subtreeTile );\n\t\tsubtreeTile.geometricError = this.getGeometricError( subtreeTile );\n\t\t// Todo Multiple contents not handled, keep the first found content.\n\t\tfor ( let i = 0; subtree && i < subtree._contentAvailabilityBitstreams.length; i ++ ) {\n\n\t\t\tif ( subtree && this.getBit( subtree._contentAvailabilityBitstreams[ i ], childBitIndex ) ) {\n\n\t\t\t\tsubtreeTile.content = { uri: this.parseImplicitURI( subtreeTile, this.rootTile.content.uri ) };\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn subtreeTile;\n\n\t}\n\n\t/**\n\t * Get a bit from the bitstream as a Boolean. If the bitstream\n\t * is a constant, the constant value is returned instead.\n\t *\n\t * @param {ParsedBitstream} object\n\t * @param {number} index The integer index of the bit.\n\t * @returns {boolean} The value of the bit.\n\t * @private\n\t */\n\tgetBit( object, index ) {\n\n\t\tif ( index < 0 || index >= object.lengthBits ) {\n\n\t\t\tthrow new Error( 'Bit index out of bounds.' );\n\n\t\t}\n\n\t\tif ( object.constant !== undefined ) {\n\n\t\t\treturn object.constant;\n\n\t\t}\n\n\t\t// byteIndex is floor(index / 8)\n\t\tconst byteIndex = index >> 3;\n\t\tconst bitIndex = index % 8;\n\t\treturn ( ( new Uint8Array( object.bitstream )[ byteIndex ] >> bitIndex ) & 1 ) === 1;\n\n\t}\n\n\t/**\n\t * //TODO Adapt for Sphere\n\t * To maintain numerical stability during this subdivision process,\n\t * the actual bounding volumes should not be computed progressively by subdividing a non-root tile volume.\n\t * Instead, the exact bounding volumes are computed directly for a given level.\n\t * @param {Object | SubtreeTile} tile\n\t * @return {Object} object containing the bounding volume.\n\t */\n\tgetTileBoundingVolume( tile ) {\n\n\t\tconst boundingVolume = {};\n\t\tif ( this.rootTile.boundingVolume.region ) {\n\n\t\t\tconst region = [ ...this.rootTile.boundingVolume.region ];\n\t\t\tconst minX = region[ 0 ];\n\t\t\tconst maxX = region[ 2 ];\n\t\t\tconst minY = region[ 1 ];\n\t\t\tconst maxY = region[ 3 ];\n\t\t\tconst sizeX = ( maxX - minX ) / Math.pow( 2, tile.__level );\n\t\t\tconst sizeY = ( maxY - minY ) / Math.pow( 2, tile.__level );\n\t\t\tregion[ 0 ] = minX + sizeX * tile.__x;\t//west\n\t\t\tregion[ 2 ] = minX + sizeX * ( tile.__x + 1 );\t//east\n\t\t\tregion[ 1 ] = minY + sizeY * tile.__y;\t//south\n\t\t\tregion[ 3 ] = minY + sizeY * ( tile.__y + 1 );\t//north\n\t\t\tfor ( let k = 0; k < 4; k ++ ) {\n\n\t\t\t\tconst coord = region[ k ];\n\t\t\t\tif ( coord < - Math.PI ) {\n\n\t\t\t\t\tregion[ k ] += 2 * Math.PI;\n\n\t\t\t\t} else if ( coord > Math.PI ) {\n\n\t\t\t\t\tregion[ k ] -= 2 * Math.PI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//Also divide the height in the case of octree.\n\t\t\tif ( isOctreeSubdivision( tile ) ) {\n\n\t\t\t\tconst minZ = region[ 4 ];\n\t\t\t\tconst maxZ = region[ 5 ];\n\t\t\t\tconst sizeZ = ( maxZ - minZ ) / Math.pow( 2, tile.__level );\n\t\t\t\tregion[ 4 ] = minZ + sizeZ * tile.__z;\t//minimum height\n\t\t\t\tregion[ 5 ] = minZ + sizeZ * ( tile.__z + 1 );\t//maximum height\n\n\t\t\t}\n\n\t\t\tboundingVolume.region = region;\n\n\t\t}\n\n\t\tif ( this.rootTile.boundingVolume.box ) {\n\n\t\t\t// 0-2: center of the box\n\t\t\t// 3-5: x axis direction and half length\n\t\t\t// 6-8: y axis direction and half length\n\t\t\t// 9-11: z axis direction and half length\n\t\t\tconst box = [ ...this.rootTile.boundingVolume.box ];\n\t\t\tconst cellSteps = 2 ** tile.__level - 1;\n\t\t\tconst scale = Math.pow( 2, - tile.__level );\n\t\t\tconst axisNumber = isOctreeSubdivision( tile ) ? 3 : 2;\n\t\t\tfor ( let i = 0; i < axisNumber; i ++ ) {\n\n\t\t\t\t// scale the bounds axes\n\t\t\t\tbox[ 3 + i * 3 + 0 ] *= scale;\n\t\t\t\tbox[ 3 + i * 3 + 1 ] *= scale;\n\t\t\t\tbox[ 3 + i * 3 + 2 ] *= scale;\n\t\t\t\t// axis vector\n\t\t\t\tconst x = box[ 3 + i * 3 + 0 ];\n\t\t\t\tconst y = box[ 3 + i * 3 + 1 ];\n\t\t\t\tconst z = box[ 3 + i * 3 + 2 ];\n\t\t\t\t// adjust the center by the x, y and z axes\n\t\t\t\tconst axisOffset = i === 0 ? tile.__x : ( i === 1 ? tile.__y : tile.__z );\n\t\t\t\tbox[ 0 ] += 2 * x * ( - 0.5 * cellSteps + axisOffset );\n\t\t\t\tbox[ 1 ] += 2 * y * ( - 0.5 * cellSteps + axisOffset );\n\t\t\t\tbox[ 2 ] += 2 * z * ( - 0.5 * cellSteps + axisOffset );\n\n\t\t\t}\n\n\t\t\tboundingVolume.box = box;\n\n\t\t}\n\n\t\treturn boundingVolume;\n\n\t}\n\n\t/**\n\t * Each child’s geometricError is half of its parent’s geometricError.\n\t * @param {Object | SubtreeTile} tile\n\t * @return {number}\n\t */\n\tgetGeometricError( tile ) {\n\n\t\treturn this.rootTile.geometricError / Math.pow( 2, tile.__level );\n\n\t}\n\n\t/**\n\t * Determine what child subtrees exist and return a list of information.\n\t *\n\t * @param {Object} subtree The subtree for looking up availability.\n\t * @param {Array} bottomRow The bottom row of tiles in a transcoded subtree.\n\t * @returns {[]} A list of identifiers for the child subtrees.\n\t * @private\n\t */\n\tlistChildSubtrees( subtree, bottomRow ) {\n\n\t\tconst results = [];\n\t\tconst branchingFactor = getBoundsDivider( this.rootTile );\n\t\tfor ( let i = 0; i < bottomRow.length; i ++ ) {\n\n\t\t\tconst leafTile = bottomRow[ i ];\n\t\t\tif ( leafTile === undefined ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0; j < branchingFactor; j ++ ) {\n\n\t\t\t\tconst index = i * branchingFactor + j;\n\t\t\t\tif ( this.getBit( subtree._childSubtreeAvailability, index ) ) {\n\n\t\t\t\t\tresults.push( {\n\t\t\t\t\t\ttile: leafTile,\n\t\t\t\t\t\tchildMortonIndex: index\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\t/**\n\t * Replaces placeholder tokens in a URI template with the corresponding tile properties.\n\t *\n\t * The URI template should contain the tokens:\n\t * - `{level}` for the tile's subdivision level.\n\t * - `{x}` for the tile's x-coordinate.\n\t * - `{y}` for the tile's y-coordinate.\n\t * - `{z}` for the tile's z-coordinate.\n\t *\n\t * @param {Object} tile - The tile object containing properties __level, __x, __y, and __z.\n\t * @param {string} uri - The URI template string with placeholders.\n\t * @returns {string} The URI with placeholders replaced by the tile's properties.\n\t */\n\tparseImplicitURI( tile, uri ) {\n\n\t\turi = uri.replace( '{level}', tile.__level );\n\t\turi = uri.replace( '{x}', tile.__x );\n\t\turi = uri.replace( '{y}', tile.__y );\n\t\turi = uri.replace( '{z}', tile.__z );\n\t\treturn uri;\n\n\t}\n\n\t/**\n\t * Generates the full external buffer URI for a tile by combining an implicit URI with a buffer URI.\n\t *\n\t * First, it parses the implicit URI using the tile properties and the provided template. Then, it creates a new URL\n\t * relative to the tile's base path, removes the last path segment, and appends the buffer URI.\n\t *\n\t * @param {Object} tile - The tile object that contains properties:\n\t *   - __level: the subdivision level,\n\t *   - __x, __y, __z: the tile coordinates,\n\t * @param {string} uri - The URI template string with placeholders for the tile (e.g., `{level}`, `{x}`, `{y}`, `{z}`).\n\t * @param {string} bufUri - The buffer file name to append (e.g., \"0_1.bin\").\n\t * @returns {string} The full external buffer URI.\n\t */\n\tparseImplicitURIBuffer( tile, uri, bufUri ) {\n\n\t\t// Generate the base tile URI by replacing placeholders\n\t\tconst subUri = this.parseImplicitURI( tile, uri );\n\n\t\t// Create a URL object relative to the tile's base path\n\t\tconst url = new URL( subUri, this.workingPath + '/' );\n\n\t\t// Remove the last path segment\n\t\turl.pathname = url.pathname.substring( 0, url.pathname.lastIndexOf( '/' ) );\n\n\t\t// Construct the final URL with the buffer URI appended\n\t\treturn new URL( url.pathname + '/' + bufUri, this.workingPath + '/' ).toString();\n\n\n\t}\n\n}\n","import { SUBTREELoader } from './SUBTREELoader.js';\n\nexport class ImplicitTilingPlugin {\n\n\tconstructor() {\n\n\t\tthis.name = 'IMPLICIT_TILING_PLUGIN';\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t}\n\n\tpreprocessNode( tile, tilesetDir, parentTile ) {\n\n\t\tif ( tile.implicitTiling ) {\n\n\t\t\ttile.__hasUnrenderableContent = true;\n\t\t\ttile.__hasRenderableContent = false;\n\n\t\t\t// Declare some properties\n\t\t\ttile.__subtreeIdx = 0;\t// Idx of the tile in its subtree\n\t\t\ttile.__implicitRoot = tile;\t// Keep this tile as an Implicit Root Tile\n\n\t\t\t// Coords of the tile\n\t\t\ttile.__x = 0;\n\t\t\ttile.__y = 0;\n\t\t\ttile.__z = 0;\n\t\t\ttile.__level = 0;\n\n\t\t} else if ( /.subtree$/i.test( tile.content?.uri ) ) {\n\n\t\t\t// Handling content uri pointing to a subtree file\n\t\t\ttile.__hasUnrenderableContent = true;\n\t\t\ttile.__hasRenderableContent = false;\n\n\t\t}\n\n\t}\n\n\tparseTile( buffer, tile, extension ) {\n\n\t\tif ( /^subtree$/i.test( extension ) ) {\n\n\t\t\tconst loader = new SUBTREELoader( tile );\n\t\t\tloader.workingPath = tile.__basePath;\n\t\t\tloader.fetchOptions = this.tiles.fetchOptions;\n\t\t\treturn loader.parse( buffer );\n\n\t\t}\n\n\t}\n\n\tpreprocessURL( url, tile ) {\n\n\t\tif ( tile && tile.implicitTiling ) {\n\n\t\t\tconst implicitUri = tile.implicitTiling.subtrees.uri\n\t\t\t\t.replace( '{level}', tile.__level )\n\t\t\t\t.replace( '{x}', tile.__x )\n\t\t\t\t.replace( '{y}', tile.__y )\n\t\t\t\t.replace( '{z}', tile.__z );\n\n\t\t\treturn new URL( implicitUri, tile.__basePath + '/' ).toString();\n\n\t\t}\n\n\t\treturn url;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tif ( /.subtree$/i.test( tile.content?.uri ) ) {\n\n\t\t\t// TODO: ideally the plugin doesn't need to know about children being processed\n\t\t\ttile.children.forEach( child => {\n\n\t\t\t\t// TODO: there should be a reliable way for removing children like this.\n\t\t\t\tthis.tiles.processNodeQueue.remove( child );\n\n\t\t\t} );\n\t\t\ttile.children.length = 0;\n\t\t\ttile.__childrenProcessed = 0;\n\n\t\t}\n\n\t}\n\n}\n","export class EnforceNonZeroErrorPlugin {\n\n\tconstructor() {\n\n\t\tthis.name = 'ENFORCE_NONZERO_ERROR';\n\t\tthis.priority = - Infinity;\n\t\tthis.originalError = new Map();\n\n\t}\n\n\tpreprocessNode( tile ) {\n\n\t\t// if a tile has zero error then traverse the parents and find some geometric error value in\n\t\t// the parent hierarchy to use for calculating a pseudo geometric error for this tile.\n\t\tif ( tile.geometricError === 0 ) {\n\n\t\t\tlet parent = tile.parent;\n\t\t\tlet depth = 1;\n\t\t\twhile ( parent !== null ) {\n\n\t\t\t\tif ( parent.geometricError !== 0 ) {\n\n\t\t\t\t\ttile.geometricError = parent.geometricError * ( 2 ** - depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tparent = parent.parent;\n\t\t\t\tdepth ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n"],"names":["isOctreeSubdivision","tile","getBoundsDivider","getSubtreeCoordinates","parentTile","x","y","z","SubtreeTile","childMortonIndex","copyTile","SUBTREELoader","LoaderBase","buffer","dataView","offset","magic","LoaderUtils.readMagicBytes","version","jsonLength","byteLength","subtreeJson","LoaderUtils.arrayToString","subtreeByte","subtree","bufferHeaders","bufferViewHeaders","buffersU8","bufferViewsU8","header","tileAvailabilityHeader","contentAvailabilityHeaders","i","childSubtreeAvailabilityHeader","internalBuffer","promises","bufferHeader","url","fetchPromise","response","arrayBuffer","bufferResults","result","bufferViewHeader","start","end","branchingFactor","subtreeLevels","tileAvailabilityBits","childSubtreeBits","bitstream","availabilityJson","lengthBits","bufferView","subtreeRoot","contentTile","bottomRow","childSubtrees","subtreeLocator","leafTile","subtreeTile","parentRow","currentRow","level","levelOffset","numberOfChildren","childBitIndex","parentMortonIndex","childTile","object","index","byteIndex","bitIndex","boundingVolume","region","minX","maxX","minY","maxY","sizeX","sizeY","k","coord","minZ","sizeZ","box","cellSteps","scale","axisNumber","axisOffset","results","j","uri","bufUri","subUri","ImplicitTilingPlugin","tiles","tilesetDir","_a","extension","loader","implicitUri","child","EnforceNonZeroErrorPlugin","parent","depth"],"mappings":"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"}