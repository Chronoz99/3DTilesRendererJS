{"version":3,"file":"constants-BuP7M5oB.js","sources":["../src/core/renderer/utilities/LRUCache.js","../src/core/renderer/utilities/PriorityQueue.js","../src/core/renderer/constants.js"],"sourcesContent":["const GIGABYTE_BYTES = 2 ** 30;\n\nclass LRUCache {\n\n\tget unloadPriorityCallback() {\n\n\t\treturn this._unloadPriorityCallback;\n\n\t}\n\n\tset unloadPriorityCallback( cb ) {\n\n\t\tif ( cb.length === 1 ) {\n\n\t\t\tconsole.warn( 'LRUCache: \"unloadPriorityCallback\" function has been changed to take two arguments.' );\n\t\t\tthis._unloadPriorityCallback = ( a, b ) => {\n\n\t\t\t\tconst valA = cb( a );\n\t\t\t\tconst valB = cb( b );\n\n\t\t\t\tif ( valA < valB ) return - 1;\n\t\t\t\tif ( valA > valB ) return 1;\n\t\t\t\treturn 0;\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tthis._unloadPriorityCallback = cb;\n\n\t\t}\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.minSize = 6000;\n\t\tthis.maxSize = 8000;\n\t\tthis.minBytesSize = 0.3 * GIGABYTE_BYTES;\n\t\tthis.maxBytesSize = 0.4 * GIGABYTE_BYTES;\n\t\tthis.unloadPercent = 0.05;\n\t\tthis.autoMarkUnused = true;\n\n\t\t// \"itemSet\" doubles as both the list of the full set of items currently\n\t\t// stored in the cache (keys) as well as a map to the time the item was last\n\t\t// used so it can be sorted appropriately.\n\t\tthis.itemSet = new Map();\n\t\tthis.itemList = [];\n\t\tthis.usedSet = new Set();\n\t\tthis.callbacks = new Map();\n\t\tthis.unloadingHandle = - 1;\n\t\tthis.cachedBytes = 0;\n\t\tthis.bytesMap = new Map();\n\t\tthis.loadedSet = new Set();\n\n\t\tthis._unloadPriorityCallback = null;\n\n\t\tconst itemSet = this.itemSet;\n\t\tthis.defaultPriorityCallback = item => itemSet.get( item );\n\n\t}\n\n\t// Returns whether or not the cache has reached the maximum size\n\tisFull() {\n\n\t\treturn this.itemSet.size >= this.maxSize || this.cachedBytes >= this.maxBytesSize;\n\n\t}\n\n\tgetMemoryUsage( item ) {\n\n\t\treturn this.bytesMap.get( item ) || 0;\n\n\t}\n\n\tsetMemoryUsage( item, bytes ) {\n\n\t\tconst { bytesMap, itemSet } = this;\n\t\tif ( ! itemSet.has( item ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\tbytesMap.set( item, bytes );\n\t\tthis.cachedBytes += bytes;\n\n\t}\n\n\tadd( item, removeCb ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( this.isFull() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemList = this.itemList;\n\t\tconst callbacks = this.callbacks;\n\t\titemList.push( item );\n\t\tusedSet.add( item );\n\t\titemSet.set( item, Date.now() );\n\t\tcallbacks.set( item, removeCb );\n\n\t\treturn true;\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.itemSet.has( item );\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemSet = this.itemSet;\n\t\tconst itemList = this.itemList;\n\t\tconst bytesMap = this.bytesMap;\n\t\tconst callbacks = this.callbacks;\n\t\tconst loadedSet = this.loadedSet;\n\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\t\tbytesMap.delete( item );\n\n\t\t\tcallbacks.get( item )( item );\n\n\t\t\tconst index = itemList.indexOf( item );\n\t\t\titemList.splice( index, 1 );\n\t\t\tusedSet.delete( item );\n\t\t\titemSet.delete( item );\n\t\t\tcallbacks.delete( item );\n\t\t\tloadedSet.delete( item );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Marks whether tiles in the cache have been completely loaded or not. Tiles that have not been completely\n\t// loaded are subject to being disposed early if the cache is full above its max size limits, even if they\n\t// are marked as used.\n\tsetLoaded( item, value ) {\n\n\t\tconst { itemSet, loadedSet } = this;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tif ( value === true ) {\n\n\t\t\t\tloadedSet.add( item );\n\n\t\t\t} else {\n\n\t\t\t\tloadedSet.delete( item );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmarkUsed( item ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tconst usedSet = this.usedSet;\n\t\tif ( itemSet.has( item ) && ! usedSet.has( item ) ) {\n\n\t\t\titemSet.set( item, Date.now() );\n\t\t\tusedSet.add( item );\n\n\t\t}\n\n\t}\n\n\tmarkUnused( item ) {\n\n\t\tthis.usedSet.delete( item );\n\n\t}\n\n\tmarkAllUnused() {\n\n\t\tthis.usedSet.clear();\n\n\t}\n\n\tisUsed( item ) {\n\n\t\treturn this.usedSet.has( item );\n\n\t}\n\n\t// TODO: this should be renamed because it's not necessarily unloading all unused content\n\t// Maybe call it \"cleanup\" or \"unloadToMinSize\"\n\tunloadUnusedContent() {\n\n\t\tconst {\n\t\t\tunloadPercent,\n\t\t\tminSize,\n\t\t\tmaxSize,\n\t\t\titemList,\n\t\t\titemSet,\n\t\t\tusedSet,\n\t\t\tloadedSet,\n\t\t\tcallbacks,\n\t\t\tbytesMap,\n\t\t\tminBytesSize,\n\t\t\tmaxBytesSize,\n\t\t} = this;\n\n\t\tconst unused = itemList.length - usedSet.size;\n\t\tconst unloaded = itemList.length - loadedSet.size;\n\t\tconst excessNodes = Math.max( Math.min( itemList.length - minSize, unused ), 0 );\n\t\tconst excessBytes = this.cachedBytes - minBytesSize;\n\t\tconst unloadPriorityCallback = this.unloadPriorityCallback || this.defaultPriorityCallback;\n\t\tlet needsRerun = false;\n\n\t\tconst hasNodesToUnload = excessNodes > 0 && unused > 0 || unloaded && itemList.length > maxSize;\n\t\tconst hasBytesToUnload = unused && this.cachedBytes > minBytesSize || unloaded && this.cachedBytes > maxBytesSize;\n\t\tif ( hasBytesToUnload || hasNodesToUnload ) {\n\n\t\t\t// used items should be at the end of the array, \"unloaded\" items in the middle of the array\n\t\t\titemList.sort( ( a, b ) => {\n\n\t\t\t\tconst usedA = usedSet.has( a );\n\t\t\t\tconst usedB = usedSet.has( b );\n\t\t\t\tif ( usedA === usedB ) {\n\n\t\t\t\t\tconst loadedA = loadedSet.has( a );\n\t\t\t\t\tconst loadedB = loadedSet.has( b );\n\t\t\t\t\tif ( loadedA === loadedB ) {\n\n\t\t\t\t\t\t// Use the sort function otherwise\n\t\t\t\t\t\t// higher priority should be further to the left\n\t\t\t\t\t\treturn - unloadPriorityCallback( a, b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn loadedA ? 1 : - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If one is used and the other is not move the used one towards the end of the array\n\t\t\t\t\treturn usedA ? 1 : - 1;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// address corner cases where the minSize might be zero or smaller than maxSize - minSize,\n\t\t\t// which would result in a very small or no items being unloaded.\n\t\t\tconst maxUnload = Math.max( minSize * unloadPercent, excessNodes * unloadPercent );\n\t\t\tconst nodesToUnload = Math.ceil( Math.min( maxUnload, unused, excessNodes ) );\n\t\t\tconst maxBytesUnload = Math.max( unloadPercent * excessBytes, unloadPercent * minBytesSize );\n\t\t\tconst bytesToUnload = Math.min( maxBytesUnload, excessBytes );\n\n\t\t\tlet removedNodes = 0;\n\t\t\tlet removedBytes = 0;\n\n\t\t\t// evict up to the max node or bytes size, keeping one more item over the max bytes limit\n\t\t\t// so the \"full\" function behaves correctly.\n\t\t\twhile (\n\t\t\t\tthis.cachedBytes - removedBytes > maxBytesSize ||\n\t\t\t\titemList.length - removedNodes > maxSize\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) && loadedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < maxBytesSize &&\n\t\t\t\t\titemList.length - removedNodes <= maxSize\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// evict up to the min node or bytes size, keeping one more item over the min bytes limit\n\t\t\t// so we're meeting it\n\t\t\twhile (\n\t\t\t\tremovedBytes < bytesToUnload ||\n\t\t\t\tremovedNodes < nodesToUnload\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < minBytesSize &&\n\t\t\t\t\tremovedNodes >= nodesToUnload\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// remove the nodes\n\t\t\titemList.splice( 0, removedNodes ).forEach( item => {\n\n\t\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\n\t\t\t\tcallbacks.get( item )( item );\n\t\t\t\tbytesMap.delete( item );\n\t\t\t\titemSet.delete( item );\n\t\t\t\tcallbacks.delete( item );\n\t\t\t\tloadedSet.delete( item );\n\t\t\t\tusedSet.delete( item );\n\n\t\t\t} );\n\n\t\t\t// if we didn't remove enough nodes or we still have excess bytes and there are nodes to removed\n\t\t\t// then we want to fire another round of unloading\n\t\t\tneedsRerun = removedNodes < excessNodes || removedBytes < excessBytes && removedNodes < unused;\n\t\t\tneedsRerun = needsRerun && removedNodes > 0;\n\n\t\t}\n\n\t\tif ( needsRerun ) {\n\n\t\t\tthis.unloadingHandle = requestAnimationFrame( () => this.scheduleUnload() );\n\n\t\t}\n\n\t}\n\n\tscheduleUnload() {\n\n\t\tcancelAnimationFrame( this.unloadingHandle );\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.scheduled = true;\n\t\t\tqueueMicrotask( () => {\n\n\t\t\t\tthis.scheduled = false;\n\t\t\t\tthis.unloadUnusedContent();\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LRUCache };\n","export class PriorityQueueItemRemovedError extends Error {\n\n\tconstructor() {\n\n\t\tsuper( 'PriorityQueue: Item removed' );\n\t\tthis.name = 'PriorityQueueItemRemovedError';\n\n\t}\n\n}\n\nexport class PriorityQueue {\n\n\t// returns whether tasks are queued or actively running\n\tget running() {\n\n\t\treturn this.items.length !== 0 || this.currJobs !== 0;\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.maxJobs = 6;\n\n\t\tthis.items = [];\n\t\tthis.callbacks = new Map();\n\t\tthis.currJobs = 0;\n\t\tthis.scheduled = false;\n\t\tthis.autoUpdate = true;\n\n\t\tthis.priorityCallback = null;\n\n\t\t// Customizable scheduling callback. Default using requestAnimationFrame()\n\t\tthis.schedulingCallback = func => {\n\n\t\t\trequestAnimationFrame( func );\n\n\t\t};\n\n\t\tthis._runjobs = () => {\n\n\t\t\tthis.scheduled = false;\n\t\t\tthis.tryRunJobs();\n\n\t\t};\n\n\t}\n\n\tsort() {\n\n\t\tconst priorityCallback = this.priorityCallback;\n\t\tconst items = this.items;\n\t\tif ( priorityCallback !== null ) {\n\n\t\t\titems.sort( priorityCallback );\n\n\t\t}\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.callbacks.has( item );\n\n\t}\n\n\tadd( item, callback ) {\n\n\t\tconst data = {\n\t\t\tcallback,\n\t\t\treject: null,\n\t\t\tresolve: null,\n\t\t\tpromise: null,\n\t\t};\n\n\t\tdata.promise = new Promise( ( resolve, reject ) => {\n\n\t\t\tconst items = this.items;\n\t\t\tconst callbacks = this.callbacks;\n\n\t\t\tdata.resolve = resolve;\n\t\t\tdata.reject = reject;\n\n\t\t\titems.unshift( item );\n\t\t\tcallbacks.set( item, data );\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn data.promise;\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\n\t\tconst index = items.indexOf( item );\n\t\tif ( index !== - 1 ) {\n\n\t\t\t// reject the promise to ensure there are no dangling promises - add a\n\t\t\t// catch here to handle the case where the promise was never used anywhere\n\t\t\t// else.\n\t\t\tconst info = callbacks.get( item );\n\t\t\tinfo.promise.catch( err => {\n\n\t\t\t\tif ( ! ( err instanceof PriorityQueueItemRemovedError ) ) {\n\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\tinfo.reject( new PriorityQueueItemRemovedError() );\n\n\t\t\titems.splice( index, 1 );\n\t\t\tcallbacks.delete( item );\n\n\t\t}\n\n\t}\n\n\tremoveByFilter( filter ) {\n\n\t\tconst { items } = this;\n\t\tfor ( let i = 0; i < items.length; i ++ ) {\n\n\t\t\tconst item = items[ i ];\n\t\t\tif ( filter( item ) ) {\n\n\t\t\t\tthis.remove( item );\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttryRunJobs() {\n\n\t\tthis.sort();\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\t\tconst maxJobs = this.maxJobs;\n\t\tlet iterated = 0;\n\n\t\tconst completedCallback = () => {\n\n\t\t\tthis.currJobs --;\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t};\n\n\t\twhile ( maxJobs > this.currJobs && items.length > 0 && iterated < maxJobs ) {\n\n\t\t\tthis.currJobs ++;\n\t\t\titerated ++;\n\t\t\tconst item = items.pop();\n\t\t\tconst { callback, resolve, reject } = callbacks.get( item );\n\t\t\tcallbacks.delete( item );\n\n\t\t\tlet result;\n\t\t\ttry {\n\n\t\t\t\tresult = callback( item );\n\n\t\t\t} catch ( err ) {\n\n\t\t\t\treject( err );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\tresult\n\t\t\t\t\t.then( resolve )\n\t\t\t\t\t.catch( reject )\n\t\t\t\t\t.finally( completedCallback );\n\n\t\t\t} else {\n\n\t\t\t\tresolve( result );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tscheduleJobRun() {\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.schedulingCallback( this._runjobs );\n\n\t\t\tthis.scheduled = true;\n\n\t\t}\n\n\t}\n\n}\n","// FAILED is negative so lru cache priority sorting will unload it first\nexport const FAILED = - 1;\nexport const UNLOADED = 0;\nexport const QUEUED = 1;\nexport const LOADING = 2;\nexport const PARSING = 3;\nexport const LOADED = 4;\n\n// https://en.wikipedia.org/wiki/World_Geodetic_System\n// https://en.wikipedia.org/wiki/Flattening\nexport const WGS84_RADIUS = 6378137;\nexport const WGS84_FLATTENING = 1 / 298.257223563;\nexport const WGS84_HEIGHT = - ( WGS84_FLATTENING * WGS84_RADIUS - WGS84_RADIUS );\n"],"names":["LRUCache","cb","b","valA","valB","itemSet","item","bytes","bytesMap","removeCb","usedSet","itemList","callbacks","loadedSet","index","value","unloadPercent","minSize","maxSize","minBytesSize","maxBytesSize","unused","unloaded","excessNodes","excessBytes","unloadPriorityCallback","needsRerun","hasNodesToUnload","a","usedA","usedB","loadedA","loadedB","maxUnload","nodesToUnload","maxBytesUnload","bytesToUnload","removedNodes","removedBytes","PriorityQueueItemRemovedError","PriorityQueue","func","priorityCallback","items","callback","data","resolve","reject","info","err","filter","i","maxJobs","iterated","completedCallback","result","FAILED","UNLOADED","QUEUED","LOADING","PARSING","LOADED","WGS84_RADIUS","WGS84_FLATTENING","WGS84_HEIGHT"],"mappings":"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"}