{"version":3,"file":"index.r3f.js","sources":["../src/r3f/utilities/useObjectDep.js","../src/r3f/utilities/useOptions.js","../src/r3f/utilities/useApplyRefs.js","../src/r3f/components/TilesRenderer.jsx","../src/r3f/components/CanvasDOMOverlay.jsx","../src/r3f/components/TilesAttributionOverlay.jsx","../src/r3f/components/CameraControls.jsx","../src/r3f/components/CompassGizmo.jsx","../src/r3f/components/CameraTransition.jsx","../src/r3f/utilities/useMultipleRefs.js","../src/r3f/utilities/SceneObserver.js","../src/r3f/utilities/QueryManager.js","../src/r3f/components/SettledObjects.jsx"],"sourcesContent":["import { useRef } from 'react';\n\n// checks if the first level of object key-values are equal\nfunction areObjectsEqual( a, b ) {\n\n\t// early check for equivalence\n\tif ( a === b ) {\n\n\t\treturn true;\n\n\t}\n\n\t// if either of the objects is null or undefined, then perform a simple check\n\tif ( ! a || ! b ) {\n\n\t\treturn a === b;\n\n\t}\n\n\t// check all keys and values in the first object\n\tfor ( const key in a ) {\n\n\t\tif ( a[ key ] !== b[ key ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t// check all keys and values in the second object\n\tfor ( const key in b ) {\n\n\t\tif ( a[ key ] !== b[ key ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\n// Helper for using an object as a dependency in a useEffect or useMemo array\nexport function useObjectDep( object ) {\n\n\t// only modify the returned object reference if it has changed\n\tconst ref = useRef();\n\tif ( ! areObjectsEqual( ref.current, object ) ) {\n\n\t\tref.current = object;\n\n\t}\n\n\treturn ref.current;\n\n}\n","import { useLayoutEffect } from 'react';\nimport { useObjectDep } from './useObjectDep.js';\n\n// return true if the given key is for registering an event\nfunction isEventName( key ) {\n\n\treturn /^on/g.test( key );\n\n}\n\n// returns the event name to register for the given key\nfunction getEventName( key ) {\n\n\treturn key\n\t\t.replace( /^on/, '' )\n\t\t.replace( /[a-z][A-Z]/g, match => `${ match[ 0 ] }-${ match[ 1 ] }` )\n\t\t.toLowerCase();\n\n}\n\n// returns a dash-separated key as a list of tokens\nfunction getPath( key ) {\n\n\treturn key.split( '-' );\n\n}\n\n// gets the value from the object at the given path\nfunction getValueAtPath( object, path ) {\n\n\tlet curr = object;\n\tconst tokens = [ ...path ];\n\twhile ( tokens.length !== 0 ) {\n\n\t\tconst key = tokens.shift();\n\t\tcurr = curr[ key ];\n\n\t}\n\n\treturn curr;\n\n}\n\n// sets the value of the object at the given path\nfunction setValueAtPath( object, path, value ) {\n\n\tconst tokens = [ ...path ];\n\tconst finalKey = tokens.pop();\n\tgetValueAtPath( object, tokens )[ finalKey ] = value;\n\n}\n\n// Recursively assigns a set of options to an object, interpreting dashes as periods\nexport function useDeepOptions( target, options, shallow = false ) {\n\n\t// assign options recursively\n\tuseLayoutEffect( () => {\n\n\t\tif ( target === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst previousState = {};\n\t\tconst events = {};\n\t\tfor ( const key in options ) {\n\n\t\t\tif ( isEventName( key ) && target.addEventListener && ! ( key in target ) ) {\n\n\t\t\t\tconst eventName = getEventName( key );\n\t\t\t\tevents[ eventName ] = options[ key ];\n\t\t\t\ttarget.addEventListener( eventName, options[ key ] );\n\n\t\t\t} else {\n\n\t\t\t\tconst path = shallow ? [ key ] : getPath( key );\n\t\t\t\tpreviousState[ key ] = getValueAtPath( target, path );\n\t\t\t\tsetValueAtPath( target, path, options[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn () => {\n\n\t\t\tfor ( const key in events ) {\n\n\t\t\t\ttarget.removeEventListener( key, events[ key ] );\n\n\t\t\t}\n\n\t\t\tfor ( const key in previousState ) {\n\n\t\t\t\tconst path = shallow ? [ key ] : getPath( key );\n\t\t\t\tsetValueAtPath( target, path, previousState[ key ] );\n\n\t\t\t}\n\n\t\t};\n\n\t}, [ target, useObjectDep( options ) ] ); // eslint-disable-line\n\n}\n\n// Assigns a set of options to an object shallowly, interpreting dashes as periods\nexport function useShallowOptions( instance, options ) {\n\n\tuseDeepOptions( instance, options, true );\n\n}\n","import { useEffect } from 'react';\n\n// assign a give target to the set of refs\nexport function useApplyRefs( target, ...refs ) {\n\n\tuseEffect( () => {\n\n\t\trefs.forEach( ref => {\n\n\t\t\tif ( ref ) {\n\n\t\t\t\tif ( ref instanceof Function ) {\n\n\t\t\t\t\tref( target );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tref.current = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}, [ target, ...refs ] ); // eslint-disable-line\n\n}\n","import { createContext, useMemo, useContext, useEffect, useRef, forwardRef, useCallback, useState, useLayoutEffect, useReducer } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { Object3D } from 'three';\nimport { TilesRenderer as TilesRendererImpl, WGS84_ELLIPSOID } from '3d-tiles-renderer/three';\nimport { useDeepOptions } from '../utilities/useOptions.js';\nimport { useObjectDep } from '../utilities/useObjectDep.js';\nimport { useApplyRefs } from '../utilities/useApplyRefs.js';\n\n// context for accessing the tileset\nexport const TilesRendererContext = createContext( null );\nexport const TilesPluginContext = createContext( null );\n\n// context for accessing just ellipsoid and frame data\nexport const EllipsoidContext = createContext( null );\n\n// group that matches the transform of the tileset root group\nfunction TileSetRoot( { children } ) {\n\n\tconst tiles = useContext( TilesRendererContext );\n\tconst ref = useRef();\n\tuseEffect( () => {\n\n\t\tif ( tiles ) {\n\n\t\t\tref.current.matrixWorld = tiles.group.matrixWorld;\n\n\t\t}\n\n\t}, [ tiles ] );\n\n\treturn <group ref={ ref } matrixWorldAutoUpdate={ false } matrixAutoUpdate={ false }>{ children }</group>;\n\n}\n\nexport function EastNorthUpFrame( props ) {\n\n\tconst {\n\t\tlat = 0,\n\t\tlon = 0,\n\t\theight = 0,\n\t\taz = 0,\n\t\tel = 0,\n\t\troll = 0,\n\t\tellipsoid = WGS84_ELLIPSOID.clone(),\n\t\tchildren,\n\t} = props;\n\tconst tiles = useContext( TilesRendererContext );\n\tconst invalidate = useThree( state => state.invalidate );\n\tconst [ group, setGroup ] = useState( null );\n\tconst updateCallback = useCallback( () => {\n\n\t\tif ( group === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// hide the group if the tiles aren't loaded yet\n\t\tconst localEllipsoid = tiles && tiles.ellipsoid || ellipsoid || null;\n\t\tgroup.matrix.identity();\n\t\tgroup.visible = Boolean( tiles && tiles.root || ellipsoid );\n\n\t\tif ( localEllipsoid === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlocalEllipsoid.getOrientedEastNorthUpFrame( lat, lon, height, az, el, roll, group.matrix );\n\t\tgroup.matrix.decompose( group.position, group.quaternion, group.scale );\n\t\tgroup.updateMatrixWorld();\n\t\tinvalidate();\n\n\t}, [ invalidate, tiles, lat, lon, height, az, el, roll, ellipsoid, group, useObjectDep( ellipsoid.radius ) ] ); // eslint-disable-line react-hooks/exhaustive-deps\n\n\t// adjust the matrix world update logic if a tileset is present so that we can position the frame\n\t// correctly regardless of the parent.\n\tuseEffect( () => {\n\n\t\tif ( tiles !== null && group !== null ) {\n\n\t\t\tgroup.updateMatrixWorld = function ( force ) {\n\n\t\t\t\tif ( this.matrixAutoUpdate ) {\n\n\t\t\t\t\tthis.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( tiles.group.matrixWorld, this.matrix );\n\t\t\t\t\tforce = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst children = this.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst child = children[ i ];\n\t\t\t\t\tchild.updateMatrixWorld( force );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\treturn () => {\n\n\t\t\t\tgroup.updateMatrixWorld = Object3D.prototype.updateMatrixWorld;\n\n\t\t\t};\n\n\t\t}\n\n\t}, [ tiles, group ] );\n\n\tuseEffect( () => {\n\n\t\tupdateCallback();\n\n\t}, [ updateCallback ] );\n\n\t// update the position when a tileset is loaded since it may modify the ellipsoid\n\tuseEffect( () => {\n\n\t\tif ( tiles === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\ttiles.addEventListener( 'load-tileset', updateCallback );\n\t\treturn () => {\n\n\t\t\ttiles.removeEventListener( 'load-tileset', updateCallback );\n\n\t\t};\n\n\t}, [ tiles, updateCallback ] );\n\n\treturn <group ref={ setGroup }>{ children }</group>;\n\n}\n\n// component for registering a plugin\nexport const TilesPlugin = forwardRef( function TilesPlugin( props, ref ) {\n\n\tconst { plugin, args, children, ...options } = props;\n\tconst tiles = useContext( TilesRendererContext );\n\tconst [ instance, setInstance ] = useState( null );\n\tconst [ , forceUpdate ] = useReducer( x => x + 1, 0 );\n\n\tuseLayoutEffect( () => {\n\n\t\tif ( tiles === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet instance;\n\t\tif ( Array.isArray( args ) ) {\n\n\t\t\tinstance = new plugin( ...args );\n\n\t\t} else {\n\n\t\t\tinstance = new plugin( args );\n\n\t\t}\n\n\t\tsetInstance( instance );\n\n\t\treturn () => {\n\n\t\t\tsetInstance( null );\n\n\t\t};\n\n\t}, [ plugin, tiles, useObjectDep( args ) ] ); // eslint-disable-line\n\n\t// assigns any provided options to the plugin\n\tuseDeepOptions( instance, options );\n\n\t// register the plugin\n\tuseLayoutEffect( () => {\n\n\t\tif ( instance === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// force the component to rerender after registering the plugin because we don't\n\t\t// include the children until the plugin is added.\n\t\ttiles.registerPlugin( instance );\n\t\tforceUpdate();\n\n\t\treturn () => {\n\n\t\t\ttiles.unregisterPlugin( instance );\n\n\t\t};\n\n\t\t// \"tiles\" is excluded from the dependencies since this would otherwise run once with the\n\t\t// new tiles renderer, resulting in an error when the instance is added to a second renderer.\n\n\t}, [ instance ] ); // eslint-disable-line\n\n\t// assign ref\n\tuseApplyRefs( instance, ref );\n\n\t// only render out the plugin once the instance and context are ready and registered\n\tif ( ! instance || ! tiles.plugins.includes( instance ) ) {\n\n\t\treturn;\n\n\t}\n\n\treturn <TilesPluginContext.Provider value={ instance }>{ children }</TilesPluginContext.Provider>;\n\n} );\n\n// component for adding a TilesRenderer to the scene\nexport const TilesRenderer = forwardRef( function TilesRenderer( props, ref ) {\n\n\tconst { url, cachedRootJson = null, group = {}, enabled = true, children, ...options } = props;\n\tconst [ camera, gl, invalidate ] = useThree( state => [ state.camera, state.gl, state.invalidate ] );\n\tconst [ tiles, setTiles ] = useState( null );\n\n\t// create the tileset\n\tuseEffect( () => {\n\n\t\tconst needsRender = () => invalidate();\n\n\t\tconst tiles = new TilesRendererImpl( url, cachedRootJson );\n\t\ttiles.addEventListener( 'needs-render', needsRender );\n\t\ttiles.addEventListener( 'needs-update', needsRender );\n\t\tsetTiles( tiles );\n\n\t\treturn () => {\n\n\t\t\ttiles.removeEventListener( 'needs-render', needsRender );\n\t\t\ttiles.removeEventListener( 'needs-update', needsRender );\n\t\t\ttiles.dispose();\n\t\t\tsetTiles( null );\n\n\t\t};\n\n\t}, [ url, cachedRootJson, invalidate ] );\n\n\t// update the resolution for the camera\n\tuseFrame( () => {\n\n\t\tif ( tiles === null || ! enabled ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tcamera.updateMatrixWorld();\n\t\ttiles.setResolutionFromRenderer( camera, gl );\n\t\ttiles.update();\n\n\t} );\n\n\t// add the camera\n\tuseLayoutEffect( () => {\n\n\t\tif ( tiles === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\ttiles.setCamera( camera );\n\t\treturn () => {\n\n\t\t\ttiles.deleteCamera( camera );\n\n\t\t};\n\n\t}, [ tiles, camera ] );\n\n\t// assign ref\n\tuseApplyRefs( tiles, ref );\n\n\t// assign options recursively\n\tuseDeepOptions( tiles, options );\n\tconst ellipsoidContextValue = useMemo( () => {\n\n\t\tif ( ! tiles ) return null;\n\n\t\treturn {\n\t\t\tellipsoid: tiles.ellipsoid,\n\t\t\tframe: tiles.group,\n\t\t};\n\n\t}, [ tiles?.ellipsoid, tiles?.group ] );\n\n\t// only render out the tiles once the instance and context are ready\n\tif ( ! tiles ) {\n\n\t\treturn null;\n\n\t}\n\n\treturn <>\n\t\t<primitive object={ tiles.group } { ...group } />\n\t\t<TilesRendererContext.Provider value={ tiles }>\n\t\t\t<EllipsoidContext.Provider value={ ellipsoidContextValue }>\n\t\t\t\t<TileSetRoot>\n\t\t\t\t\t{ children }\n\t\t\t\t</TileSetRoot>\n\t\t\t</EllipsoidContext.Provider>\n\t\t</TilesRendererContext.Provider>\n\t</>;\n\n} );\n","import { useMemo, useEffect, StrictMode, forwardRef, useState } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport { useThree } from '@react-three/fiber';\n\n// Utility class for overlaying dom elements on top of the canvas\nexport const CanvasDOMOverlay = forwardRef( function CanvasDOMOverlay( { children, ...rest }, ref ) {\n\n\t// create the dom element and react root\n\tconst [ gl ] = useThree( state => [ state.gl ] );\n\tconst [ root, setRoot ] = useState( null );\n\tconst container = useMemo( () => document.createElement( 'div' ), [] );\n\n\t// position the container\n\tuseEffect( () => {\n\n\t\tcontainer.style.pointerEvents = 'none';\n\t\tcontainer.style.position = 'absolute';\n\t\tcontainer.style.width = '100%';\n\t\tcontainer.style.height = '100%';\n\t\tcontainer.style.left = 0;\n\t\tcontainer.style.top = 0;\n\t\tgl.domElement.parentNode.appendChild( container );\n\n\t\treturn () => {\n\n\t\t\tcontainer.remove();\n\n\t\t};\n\n\t}, [ container, gl.domElement.parentNode ] );\n\n\t// create the react render root\n\tuseEffect( () => {\n\n\t\tconst root = createRoot( container );\n\t\tsetRoot( root );\n\t\treturn () => {\n\n\t\t\troot.unmount();\n\n\t\t};\n\n\t}, [ container ] );\n\n\t// render the children into the container\n\tif ( root !== null ) {\n\n\t\troot.render(\n\t\t\t<StrictMode>\n\t\t\t\t<div { ...rest } ref={ ref }>\n\t\t\t\t\t{ children }\n\t\t\t\t</div>\n\t\t\t</StrictMode>\n\t\t);\n\n\t}\n\n} );\n","import { useContext, useState, useEffect, useMemo } from 'react';\nimport { TilesRendererContext } from './TilesRenderer.jsx';\nimport { CanvasDOMOverlay } from './CanvasDOMOverlay.jsx';\n\nfunction randomID() {\n\n\treturn crypto.getRandomValues( new Uint32Array( 1 ) )[ 0 ].toString( 16 );\n\n}\n\n// Overlay for displaying tile data set attributions\nexport function TilesAttributionOverlay( { children, style, generateAttributions, ...rest } ) {\n\n\tconst tiles = useContext( TilesRendererContext );\n\tconst [ attributions, setAttributions ] = useState( [] );\n\n\t// Add events for checking when attributions may be updated\n\tuseEffect( () => {\n\n\t\tif ( ! tiles ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet queued = false;\n\t\tconst callback = () => {\n\n\t\t\tif ( ! queued ) {\n\n\t\t\t\tqueued = true;\n\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\tsetAttributions( tiles.getAttributions() );\n\t\t\t\t\tqueued = false;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t};\n\n\t\ttiles.addEventListener( 'tile-visibility-change', callback );\n\t\ttiles.addEventListener( 'load-tileset', callback );\n\n\t\treturn () => {\n\n\t\t\ttiles.removeEventListener( 'tile-visibility-change', callback );\n\t\t\ttiles.removeEventListener( 'load-tileset', callback );\n\n\t\t};\n\n\t}, [ tiles ] );\n\n\t// Generate CSS for modifying child elements implicit to the html attributions\n\tconst classId = useMemo( () => 'class_' + randomID(), [] );\n\tconst styles = useMemo( () => `\n\t\t#${ classId } a {\n\t\t\tcolor: white;\n\t\t}\n\n\t\t#${ classId } img {\n\t\t\tmax-width: 125px;\n\t\t\tdisplay: block;\n\t\t\tmargin: 5px 0;\n\t\t}\n\t`, [ classId ] );\n\n\tlet output;\n\tif ( generateAttributions ) {\n\n\t\toutput = generateAttributions( attributions, classId );\n\n\t} else {\n\n\t\t// generate elements for each type of attribution\n\t\tconst elements = [];\n\t\tattributions.forEach( ( att, i ) => {\n\n\t\t\tlet element = null;\n\t\t\tif ( att.type === 'string' ) {\n\n\t\t\t\telement = <div key={ i }>{ att.value }</div>;\n\n\t\t\t} else if ( att.type === 'html' ) {\n\n\t\t\t\telement = <div key={ i } dangerouslySetInnerHTML={ { __html: att.value } } style={ { pointerEvents: 'all' } }/>;\n\n\t\t\t} else if ( att.type === 'image' ) {\n\n\t\t\t\telement = <div key={ i }><img src={ att.value } /></div>;\n\n\t\t\t}\n\n\t\t\tif ( element ) {\n\n\t\t\t\telements.push( element );\n\n\t\t\t}\n\n\t\t} );\n\n\t\toutput = (\n\t\t\t<>\n\t\t\t\t<style>{ styles }</style>\n\t\t\t\t{ elements }\n\t\t\t</>\n\t\t);\n\n\t}\n\n\treturn (\n\t\t<CanvasDOMOverlay\n\t\t\tid={ classId }\n\t\t\tstyle={ {\n\t\t\t\tposition: 'absolute',\n\t\t\t\tbottom: 0,\n\t\t\t\tleft: 0,\n\t\t\t\tpadding: '10px',\n\t\t\t\tcolor: 'rgba( 255, 255, 255, 0.75 )',\n\t\t\t\tfontSize: '10px',\n\t\t\t\t...style,\n\t\t\t} }\n\t\t\t{ ...rest }\n\t\t>\n\t\t\t{ children }\n\t\t\t{ output }\n\t\t</CanvasDOMOverlay>\n\t);\n\n}\n","import { forwardRef, useMemo, useEffect, useContext } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { EnvironmentControls as EnvironmentControlsImpl, GlobeControls as GlobeControlsImpl } from '3d-tiles-renderer/three';\nimport { useShallowOptions } from '../utilities/useOptions.js';\nimport { EllipsoidContext } from './TilesRenderer.jsx';\nimport { useApplyRefs } from '../utilities/useApplyRefs.js';\n\n// Add a base component implementation for both EnvironmentControls and GlobeControls\nconst ControlsBaseComponent = forwardRef( function ControlsBaseComponent( props, ref ) {\n\n\tconst { controlsConstructor, domElement, scene, camera, ellipsoid, ellipsoidFrame, ...rest } = props;\n\n\tconst [ defaultCamera ] = useThree( state => [ state.camera ] );\n\tconst [ gl ] = useThree( state => [ state.gl ] );\n\tconst [ defaultScene ] = useThree( state => [ state.scene ] );\n\tconst [ invalidate ] = useThree( state => [ state.invalidate ] );\n\tconst [ get ] = useThree( state => [ state.get ] );\n\tconst [ set ] = useThree( state => [ state.set ] );\n\n\tconst ellipsoidContext = useContext( EllipsoidContext );\n\tconst appliedCamera = camera || defaultCamera || null;\n\tconst appliedScene = scene || defaultScene || null;\n\tconst appliedDomElement = domElement || gl.domElement || null;\n\tconst appliedEllipsoid = ellipsoid || ellipsoidContext?.ellipsoid || null;\n\tconst appliedEllipsoidFrame = ellipsoidFrame || ellipsoidContext?.frame || null;\n\n\t// create a controls instance\n\tconst controls = useMemo( () => {\n\n\t\treturn new controlsConstructor();\n\n\t}, [ controlsConstructor ] );\n\n\t// assign / call the reference\n\tuseApplyRefs( controls, ref );\n\n\t// fire invalidate callbacks\n\tuseEffect( () => {\n\n\t\tconst callback = () => invalidate();\n\t\tcontrols.addEventListener( 'change', callback );\n\t\tcontrols.addEventListener( 'start', callback );\n\t\tcontrols.addEventListener( 'end', callback );\n\t\treturn () => {\n\n\t\t\tcontrols.removeEventListener( 'change', callback );\n\t\t\tcontrols.removeEventListener( 'start', callback );\n\t\t\tcontrols.removeEventListener( 'end', callback );\n\n\t\t};\n\n\t}, [ controls, invalidate ] );\n\n\t// assign the camera\n\tuseEffect( () => {\n\n\t\tcontrols.setCamera( appliedCamera );\n\n\t}, [ controls, appliedCamera ] );\n\n\t// assign the scene\n\tuseEffect( () => {\n\n\t\tcontrols.setScene( appliedScene );\n\n\t}, [ controls, appliedScene ] );\n\n\t// assign the tiles renderer\n\tuseEffect( () => {\n\n\t\tif ( controls.isGlobeControls ) {\n\n\t\t\tcontrols.setEllipsoid( appliedEllipsoid, appliedEllipsoidFrame );\n\n\t\t}\n\n\t}, [ controls, appliedEllipsoid, appliedEllipsoidFrame ] );\n\n\t// attach to the dom element\n\tuseEffect( () => {\n\n\t\tcontrols.attach( appliedDomElement );\n\t\treturn () => {\n\n\t\t\tcontrols.detach();\n\n\t\t};\n\n\t}, [ controls, appliedDomElement ] );\n\n\t// set the controls for global use\n\tuseEffect( () => {\n\n\t\tconst old = get().controls;\n\t\tset( { controls } );\n\t\treturn () => set( { controls: old } );\n\n\t}, [ controls, get, set ] );\n\n\t// update the controls with a priority of - 1 so it happens before tiles renderer update\n\tuseFrame( () => {\n\n\t\tcontrols.update();\n\n\t}, - 1 );\n\n\tuseShallowOptions( controls, rest );\n\n} );\n\nexport const EnvironmentControls = forwardRef( function EnvironmentControls( props, ref ) {\n\n\treturn <ControlsBaseComponent { ...props } ref={ ref } controlsConstructor={ EnvironmentControlsImpl } />;\n\n} );\n\nexport const GlobeControls = forwardRef( function GlobeControls( props, ref ) {\n\n\treturn <ControlsBaseComponent { ...props } ref={ ref } controlsConstructor={ GlobeControlsImpl } />;\n\n} );\n","import { createPortal, useFrame, useThree } from '@react-three/fiber';\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { BackSide, Matrix4, OrthographicCamera, Ray, Scene, Vector3 } from 'three';\nimport { EllipsoidContext } from './TilesRenderer.jsx';\n\n// Based in part on @pmndrs/drei's Gizmo component\n\nconst _vec = /*@__PURE__*/ new Vector3();\nconst _axis = /*@__PURE__*/ new Vector3();\nconst _pos = /*@__PURE__*/ new Vector3();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _enuMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _cart = {};\n\n// Returns the \"focus\" point that the camera is facing based on the closest point to the ellipsoid.\n// Used for determining the compass orientation.\nfunction getCameraFocusPoint( camera, ellipsoid, tilesGroup, target ) {\n\n\t// get ray in globe coordinate frame\n\t_ray.origin.copy( camera.position );\n\t_ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t_ray.applyMatrix4( tilesGroup.matrixWorldInverse );\n\n\t// get the closest point to the ray on the globe in the global coordinate frame\n\tellipsoid.closestPointToRayEstimate( _ray, _pos );\n\t_pos.applyMatrix4( tilesGroup.matrixWorld );\n\n\t// get ortho camera info\n\t_axis.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t// ensure we move the camera exactly along the forward vector to avoid shifting\n\t// the camera in other directions due to floating point error\n\tconst dist = _pos.sub( camera.position ).dot( _axis );\n\ttarget.copy( camera.position ).addScaledVector( _axis, dist );\n\treturn target;\n\n}\n\n// Renders the portal with an orthographic camera\nfunction RenderPortal( props ) {\n\n\tconst { defaultScene, defaultCamera, overrideRenderLoop = true, renderPriority = 1 } = props;\n\tconst camera = useMemo( () => new OrthographicCamera(), [] );\n\tconst [ set, size, gl, scene ] = useThree( state => [ state.set, state.size, state.gl, state.scene ] );\n\tuseEffect( () => {\n\n\t\tset( { camera } );\n\n\t}, [ set, camera ] );\n\n\tuseEffect( () => {\n\n\t\tcamera.left = - size.width / 2;\n\t\tcamera.right = size.width / 2;\n\t\tcamera.top = size.height / 2;\n\t\tcamera.bottom = - size.height / 2;\n\t\tcamera.near = 0;\n\t\tcamera.far = 2000;\n\t\tcamera.position.z = camera.far / 2;\n\t\tcamera.updateProjectionMatrix();\n\n\t}, [ camera, size ] );\n\n\tuseFrame( () => {\n\n\t\tif ( overrideRenderLoop ) {\n\n\t\t\tgl.render( defaultScene, defaultCamera );\n\n\t\t}\n\n\t\tconst currentAutoClear = gl.autoClear;\n\t\tgl.autoClear = false;\n\n\t\tgl.clearDepth();\n\t\tgl.render( scene, camera );\n\n\t\tgl.autoClear = currentAutoClear;\n\n\t}, renderPriority );\n\n}\n\n// generates an extruded box geometry\nfunction TriangleGeometry() {\n\n\tconst ref = useRef();\n\tuseEffect( () => {\n\n\t\tconst geometry = ref.current;\n\t\tconst position = geometry.attributes.position;\n\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t_vec.fromBufferAttribute( position, i );\n\t\t\tif ( _vec.y > 0 ) {\n\n\t\t\t\t_vec.x = 0;\n\t\t\t\tposition.setXYZ( i, ..._vec );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn <boxGeometry ref={ ref } />;\n\n}\n\n// renders a typical compass graphic with red north triangle, white south, and a tinted circular background\nfunction CompassGraphic( { northColor = 0xEF5350, southColor = 0xFFFFFF } ) {\n\n\tconst [ lightTarget, setLightTarget ] = useState();\n\tconst groupRef = useRef();\n\tuseEffect( () => {\n\n\t\tsetLightTarget( groupRef.current );\n\n\t}, [] );\n\n\treturn (\n\t\t<group scale={ 0.5 } ref={ groupRef }>\n\n\t\t\t{/* Lights */}\n\t\t\t<ambientLight intensity={ 1 } />\n\t\t\t<directionalLight position={ [ 0, 2, 3 ] } intensity={ 3 } target={ lightTarget } />\n\t\t\t<directionalLight position={ [ 0, - 2, - 3 ] } intensity={ 3 } target={ lightTarget } />\n\n\t\t\t{/* Background */}\n\t\t\t<mesh>\n\t\t\t\t<sphereGeometry />\n\t\t\t\t<meshBasicMaterial color={ 0 } opacity={ 0.3 } transparent={ true } side={ BackSide } />\n\t\t\t</mesh>\n\n\t\t\t{/* Compass shape */}\n\t\t\t<group scale={ [ 0.5, 1, 0.15 ] }>\n\t\t\t\t<mesh position-y={ 0.5 }>\n\t\t\t\t\t<TriangleGeometry />\n\t\t\t\t\t<meshStandardMaterial color={ northColor } />\n\t\t\t\t</mesh>\n\t\t\t\t<mesh position-y={ - 0.5 } rotation-x={ Math.PI }>\n\t\t\t\t\t<TriangleGeometry />\n\t\t\t\t\t<meshStandardMaterial color={ southColor } />\n\t\t\t\t</mesh>\n\t\t\t</group>\n\t\t</group>\n\t);\n\n}\n\nexport function CompassGizmo( { children, overrideRenderLoop, mode = '3d', margin = 10, scale = 35, visible = true, ...rest } ) {\n\n\tconst [ defaultCamera, defaultScene, size ] = useThree( state => [ state.camera, state.scene, state.size ] );\n\tconst ellipsoidContext = useContext( EllipsoidContext );\n\tconst groupRef = useRef( null );\n\tconst scene = useMemo( () => {\n\n\t\treturn new Scene();\n\n\t}, [] );\n\n\tlet marginX, marginY;\n\tif ( Array.isArray( margin ) ) {\n\n\t\tmarginX = margin[ 0 ];\n\t\tmarginY = margin[ 1 ];\n\n\t} else {\n\n\t\tmarginX = margin;\n\t\tmarginY = margin;\n\n\t}\n\n\tuseFrame( () => {\n\n\t\tconst ellipsoid = ellipsoidContext?.ellipsoid;\n\t\tconst frame = ellipsoidContext?.frame;\n\n\t\tif ( ( ! ellipsoid || ! frame ) || groupRef.current === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst group = groupRef.current;\n\n\t\t// get the ENU frame in world space\n\t\tgetCameraFocusPoint( defaultCamera, ellipsoid, frame, _pos ).applyMatrix4( frame.matrixWorldInverse );\n\t\tellipsoid.getPositionToCartographic( _pos, _cart );\n\n\t\tellipsoid\n\t\t\t.getEastNorthUpFrame( _cart.lat, _cart.lon, 0, _enuMatrix )\n\t\t\t.premultiply( frame.matrixWorld );\n\n\t\t// get the camera orientation in the local ENU frame\n\t\t_enuMatrix.invert();\n\t\t_matrix.copy( defaultCamera.matrixWorld ).premultiply( _enuMatrix );\n\n\t\tif ( mode.toLowerCase() === '3d' ) {\n\n\t\t\tgroup.quaternion.setFromRotationMatrix( _matrix ).invert();\n\n\t\t} else {\n\n\t\t\t// get the projected facing direction of the camera\n\t\t\t_vec.set( 0, 1, 0 ).transformDirection( _matrix ).normalize();\n\t\t\t_vec.z = 0;\n\t\t\t_vec.normalize();\n\n\t\t\tif ( _vec.length() === 0 ) {\n\n\t\t\t\t// if we're looking exactly top-down\n\t\t\t\tgroup.quaternion.identity();\n\n\t\t\t} else {\n\n\t\t\t\t// compute the 2d looking direction\n\t\t\t\tconst angle = _axis.set( 0, 1, 0 ).angleTo( _vec );\n\t\t\t\t_axis.cross( _vec ).normalize();\n\t\t\t\tgroup.quaternion.setFromAxisAngle( _axis, - angle );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// default to the compass graphic\n\tif ( ! children ) {\n\n\t\tchildren = <CompassGraphic />;\n\n\t}\n\n\t// remove the portal rendering if not present\n\tif ( ! visible ) {\n\n\t\treturn null;\n\n\t}\n\n\treturn (\n\t\tcreatePortal(\n\t\t\t<>\n\t\t\t\t<group\n\t\t\t\t\tref={ groupRef }\n\t\t\t\t\tscale={ scale }\n\t\t\t\t\tposition={ [\n\t\t\t\t\t\tsize.width / 2 - marginX - scale / 2,\n\t\t\t\t\t\t- size.height / 2 + marginY + scale / 2,\n\t\t\t\t\t\t0,\n\t\t\t\t\t] }\n\n\t\t\t\t\t{ ...rest }\n\t\t\t\t>{ children }</group>\n\t\t\t\t<RenderPortal\n\t\t\t\t\tdefaultCamera={ defaultCamera }\n\t\t\t\t\tdefaultScene={ defaultScene }\n\t\t\t\t\toverrideRenderLoop={ overrideRenderLoop }\n\t\t\t\t\trenderPriority={ 10 }\n\t\t\t\t/>\n\t\t\t</>,\n\t\t\tscene,\n\t\t\t{ events: { priority: 10 } },\n\t\t)\n\t);\n\n}\n","import { forwardRef, useEffect, useMemo } from 'react';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport { CameraTransitionManager } from '3d-tiles-renderer/three';\nimport { useDeepOptions } from '../utilities/useOptions.js';\nimport { useApplyRefs } from '../utilities/useApplyRefs.js';\n\nexport const CameraTransition = forwardRef( function CameraTransition( props, ref ) {\n\n\tconst {\n\t\tmode = 'perspective',\n\t\tonBeforeToggle,\n\t\tperspectiveCamera,\n\t\torthographicCamera,\n\t\t...options\n\t} = props;\n\n\tconst [ set, get, invalidate, controls, camera, size ] = useThree( state => [ state.set, state.get, state.invalidate, state.controls, state.camera, state.size ] );\n\n\t// create the manager\n\tconst manager = useMemo( () => {\n\n\t\tconst manager = new CameraTransitionManager();\n\t\tmanager.autoSync = false;\n\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\tmanager.orthographicCamera.copy( camera );\n\t\t\tmanager.mode = 'orthographic';\n\n\t\t} else {\n\n\t\t\tmanager.perspectiveCamera.copy( camera );\n\n\t\t}\n\n\t\tmanager.syncCameras();\n\t\tmanager.mode = mode;\n\n\t\treturn manager;\n\n\t\t// only respect the camera initially so the default camera settings are automatically used\n\n\t}, [] ); // eslint-disable-line react-hooks/exhaustive-deps\n\n\tuseEffect( () => {\n\n\t\tconst { perspectiveCamera, orthographicCamera } = manager;\n\t\tconst aspect = size.width / size.height;\n\t\tperspectiveCamera.aspect = aspect;\n\t\tperspectiveCamera.updateProjectionMatrix();\n\n\t\torthographicCamera.left = - orthographicCamera.top * aspect;\n\t\torthographicCamera.right = - orthographicCamera.left;\n\t\tperspectiveCamera.updateProjectionMatrix();\n\n\t}, [ manager, size ] );\n\n\t// assign ref\n\tuseApplyRefs( manager, ref );\n\n\t// set the camera\n\tuseEffect( () => {\n\n\t\tconst cameraCallback = ( { camera } ) => {\n\n\t\t\tset( () => ( { camera } ) );\n\n\t\t};\n\n\t\tset( () => ( { camera: manager.camera } ) );\n\t\tmanager.addEventListener( 'camera-change', cameraCallback );\n\t\treturn () => {\n\n\t\t\tmanager.removeEventListener( 'camera-change', cameraCallback );\n\n\t\t};\n\n\t}, [ manager, set ] );\n\n\t// assign cameras\n\tuseEffect( () => {\n\n\t\tconst oldPerspectiveCamera = manager.perspectiveCamera;\n\t\tconst oldOrthographicCamera = manager.orthographicCamera;\n\t\tmanager.perspectiveCamera = perspectiveCamera || oldPerspectiveCamera;\n\t\tmanager.orthographicCamera = orthographicCamera || oldOrthographicCamera;\n\n\t\tset( () => ( { camera: manager.camera } ) );\n\n\t\treturn () => {\n\n\t\t\tmanager.perspectiveCamera = oldPerspectiveCamera;\n\t\t\tmanager.orthographicCamera = oldOrthographicCamera;\n\n\t\t};\n\n\t}, [ perspectiveCamera, orthographicCamera, manager, set ] );\n\n\t// toggle\n\tuseEffect( () => {\n\n\t\tif ( mode !== manager.mode ) {\n\n\t\t\t// calculate the camera being toggled to. Because \"toggle\" has not yet been\n\t\t\t// called this will select the camera that is being transitioned to.\n\t\t\tconst targetCamera = mode === 'orthographic' ? manager.orthographicCamera : manager.perspectiveCamera;\n\t\t\tif ( onBeforeToggle ) {\n\n\t\t\t\tonBeforeToggle( manager, targetCamera );\n\n\t\t\t} else if ( controls && controls.isEnvironmentControls ) {\n\n\t\t\t\tcontrols.getPivotPoint( manager.fixedPoint );\n\t\t\t\tmanager.syncCameras();\n\n\t\t\t\tcontrols.adjustCamera( manager.perspectiveCamera );\n\t\t\t\tcontrols.adjustCamera( manager.orthographicCamera );\n\n\t\t\t} else {\n\n\t\t\t\tmanager.fixedPoint\n\t\t\t\t\t.set( 0, 0, - 1 )\n\t\t\t\t\t.transformDirection( manager.camera.matrixWorld )\n\t\t\t\t\t.multiplyScalar( 50 )\n\t\t\t\t\t.add( manager.camera.position );\n\t\t\t\tmanager.syncCameras();\n\n\t\t\t}\n\n\t\t\tmanager.toggle();\n\t\t\tinvalidate();\n\n\t\t}\n\n\t}, [ mode, manager, invalidate, controls, onBeforeToggle ] );\n\n\t// rerender the frame when the transition animates\n\tuseEffect( () => {\n\n\t\tconst callback = () => invalidate();\n\t\tmanager.addEventListener( 'transition-start', callback );\n\t\tmanager.addEventListener( 'change', callback );\n\t\tmanager.addEventListener( 'transition-end', callback );\n\n\t\treturn () => {\n\n\t\t\tmanager.removeEventListener( 'transition-start', callback );\n\t\t\tmanager.removeEventListener( 'change', callback );\n\t\t\tmanager.removeEventListener( 'transition-end', callback );\n\n\t\t};\n\n\t}, [ manager, invalidate ] );\n\n\tuseDeepOptions( manager, options );\n\n\t// update animation\n\tuseFrame( () => {\n\n\t\tmanager.update();\n\t\tif ( controls ) {\n\n\t\t\tcontrols.enabled = ! manager.animating;\n\n\t\t}\n\n\t\t// ensure the orthographic camera size is resized correctly if the user is not\n\t\t// providing their own camera.\n\t\tconst { camera, size } = get();\n\t\tif ( ! orthographicCamera && camera === manager.orthographicCamera ) {\n\n\t\t\tconst aspect = size.width / size.height;\n\t\t\tconst camera = manager.orthographicCamera;\n\t\t\tif ( aspect !== camera.right ) {\n\n\t\t\t\tcamera.bottom = - 1;\n\t\t\t\tcamera.top = 1;\n\t\t\t\tcamera.left = - aspect;\n\t\t\t\tcamera.right = aspect;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( manager.animating ) {\n\n\t\t\tinvalidate();\n\n\t\t}\n\n\t}, - 1 );\n\n} );\n","import { useCallback } from 'react';\n\nexport function useMultipleRefs( ...refs ) {\n\n\treturn useCallback( target => {\n\n\t\trefs.forEach( ref => {\n\n\t\t\tif ( ref ) {\n\n\t\t\t\tif ( typeof ref === 'function' ) {\n\n\t\t\t\t\tref( target );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tref.current = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}, refs ); // eslint-disable-line\n\n}\n","import { EventDispatcher } from 'three';\n\nfunction traverse( root, callback ) {\n\n\tif ( callback( root ) ) {\n\n\t\treturn;\n\n\t}\n\n\troot.children.forEach( c => {\n\n\t\ttraverse( c, callback );\n\n\t} );\n\n}\n\nexport class SceneObserver extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.objects = new Set();\n\t\tthis.observed = new Set();\n\t\tthis._addedCallback = ( { child } ) => {\n\n\t\t\ttraverse( child, c => {\n\n\t\t\t\tif ( this.observed.has( c ) ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.objects.add( c );\n\t\t\t\t\tc.addEventListener( 'childadded', this._addedCallback );\n\t\t\t\t\tc.addEventListener( 'childremoved', this._removedCallback );\n\t\t\t\t\tthis.dispatchEvent( { type: 'childadded', child } );\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t};\n\n\t\tthis._removedCallback = ( { child } ) => {\n\n\t\t\ttraverse( child, c => {\n\n\t\t\t\tif ( this.observed.has( c ) ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.objects.delete( c );\n\t\t\t\t\tc.removeEventListener( 'childadded', this._addedCallback );\n\t\t\t\t\tc.removeEventListener( 'childremoved', this._removedCallback );\n\t\t\t\t\tthis.dispatchEvent( { type: 'childremoved', child } );\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t};\n\n\t}\n\n\tobserve( root ) {\n\n\t\tconst { observed } = this;\n\t\tthis._addedCallback( { child: root } );\n\t\tobserved.add( root );\n\n\t}\n\n\tunobserve( root ) {\n\n\t\tconst { observed } = this;\n\t\tobserved.delete( root );\n\t\tthis._removedCallback( { child: root } );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.observed.forEach( root => {\n\n\t\t\tthis.unobserve( root );\n\n\t\t} );\n\n\t}\n\n}\n","import {\n\tRaycaster,\n\tMatrix4,\n\tEventDispatcher,\n\tVector3,\n\tRay,\n\tLine3,\n\tVector2,\n} from 'three';\nimport { SceneObserver } from './SceneObserver.js';\nimport { Ellipsoid } from '3d-tiles-renderer/three';\n\nconst _raycaster = /* @__PURE__ */ new Raycaster();\nconst _line0 = /* @__PURE__ */ new Line3();\nconst _line1 = /* @__PURE__ */ new Line3();\nconst _params = /* @__PURE__ */ new Vector2();\nconst _direction = /* @__PURE__ */ new Vector3();\nconst _matrix = /* @__PURE__ */ new Matrix4();\nexport class QueryManager extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t// settings\n\t\tthis.autoRun = true;\n\n\t\t// queries\n\t\tthis.queryMap = new Map();\n\t\tthis.index = 0;\n\n\t\t// jobs\n\t\tthis.queued = [];\n\t\tthis.scheduled = false;\n\t\tthis.duration = 1;\n\n\t\t// scene\n\t\tthis.objects = [];\n\t\tthis.observer = new SceneObserver();\n\t\tthis.ellipsoid = new Ellipsoid();\n\t\tthis.frame = new Matrix4();\n\n\t\t// cameras for sorting\n\t\tthis.cameras = new Set();\n\n\t\t// register to mark items as dirty\n\t\tconst queueAll = ( () => {\n\n\t\t\tlet queued = false;\n\t\t\treturn () => {\n\n\t\t\t\tif ( ! queued ) {\n\n\t\t\t\t\tqueued = true;\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\tthis.queryMap.forEach( item => this._enqueue( item ) );\n\t\t\t\t\t\tqueued = false;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tthis.observer.addEventListener( 'childadded', queueAll );\n\t\tthis.observer.addEventListener( 'childremoved', queueAll );\n\n\t}\n\n\t// job runner\n\t_enqueue( info ) {\n\n\t\tif ( ! info.queued ) {\n\n\t\t\tthis.queued.push( info );\n\t\t\tinfo.queued = true;\n\t\t\tthis._scheduleRun();\n\n\t\t}\n\n\t}\n\n\t_runJobs() {\n\n\t\tconst { queued, cameras, duration } = this;\n\t\tconst start = performance.now();\n\n\t\t// Iterate over all cameras\n\t\tcameras.forEach( ( camera, c ) => {\n\n\t\t\t_matrix.copy( camera.matrixWorldInverse ).premultiply( camera.projectionMatrix );\n\t\t\t_direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t_line0.start.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t_line0.end.addVectors( _direction, _line0.start );\n\n\t\t\tfor ( let i = 0, l = queued.length; i < l; i ++ ) {\n\n\t\t\t\tconst info = queued[ i ];\n\t\t\t\tconst { ray } = info;\n\n\t\t\t\t// save the values for sorting\n\t\t\t\tlet distance;\n\t\t\t\tlet inFrustum;\n\t\t\t\tif ( info.point === null ) {\n\n\t\t\t\t\t// prioritize displaying points that are from rays pointing in the same direction as\n\t\t\t\t\t// the camera. Find the distance between camera ray and projection ray:\n\t\t\t\t\t_line1.start.copy( ray.origin );\n\t\t\t\t\tray.at( 1, _line1.end );\n\t\t\t\t\tclosestPointLineToLine( _line0, _line1, _params );\n\n\t\t\t\t\tinfo.distance = _params.x * ( 1.0 - Math.abs( _direction.dot( ray.direction ) ) );\n\t\t\t\t\tinfo.inFrustum = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if the point is within the frustum then prioritize it\n\t\t\t\t\tconst p = _line1.start;\n\t\t\t\t\tp.copy( info.point ).applyMatrix4( _matrix );\n\t\t\t\t\tif ( p.x > - 1 && p.x < 1 && p.y > - 1 && p.y < 1 && p.z > - 1 && p.z < 1 ) {\n\n\t\t\t\t\t\t// calculate the distance to the last hit point\n\t\t\t\t\t\tinfo.distance = p.subVectors( info.point, _line0.start ).dot( _direction );\n\t\t\t\t\t\tinfo.inFrustum = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinfo.distance = 0;\n\t\t\t\t\t\tinfo.inFrustum = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c === 0 ) {\n\n\t\t\t\t\tinfo.distance = distance;\n\t\t\t\t\tinfo.inFrustum = inFrustum;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo.inFrustum = info.inFrustum || inFrustum;\n\t\t\t\t\tinfo.distance = Math.min( info.distance, distance );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// sort the items if necessary\n\t\tif ( cameras.length !== 0 ) {\n\n\t\t\tqueued.sort( ( a, b ) => {\n\n\t\t\t\tif ( ( a.point === null ) !== ( b.point === null ) ) {\n\n\t\t\t\t\treturn a.point === null ? 1 : - 1;\n\n\t\t\t\t} else if ( a.inFrustum !== b.inFrustum ) {\n\n\t\t\t\t\treturn a.inFrustum ? 1 : - 1;\n\n\t\t\t\t} else if ( ( a.distance < 0 ) !== ( b.distance < 0 ) ) {\n\n\t\t\t\t\treturn a.distance < 0 ? - 1 : 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn b.distance - a.distance;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// update all the positions\n\t\twhile ( queued.length !== 0 && performance.now() - start < duration ) {\n\n\t\t\tconst item = queued.pop();\n\t\t\titem.queued = false;\n\t\t\tthis._updateQuery( item );\n\n\t\t}\n\n\t\tif ( queued.length !== 0 ) {\n\n\t\t\tthis._scheduleRun();\n\n\t\t}\n\n\t}\n\n\t_scheduleRun() {\n\n\t\tif ( this.autoRun && ! this.scheduled ) {\n\n\t\t\tthis.scheduled = true;\n\t\t\trequestAnimationFrame( () => {\n\n\t\t\t\tthis.scheduled = false;\n\t\t\t\tthis._runJobs();\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t_updateQuery( item ) {\n\n\t\t_raycaster.ray.copy( item.ray );\n\t\t_raycaster.far = 'lat' in item ? 1e4 + Math.max( ...this.ellipsoid.radius ) : Infinity;\n\n\t\t// save the last hit point for sorting\n\t\tconst hit = _raycaster.intersectObjects( this.objects )[ 0 ] || null;\n\t\tif ( hit !== null ) {\n\n\t\t\tif ( item.point === null ) {\n\n\t\t\t\titem.point = hit.point.clone();\n\n\t\t\t} else {\n\n\t\t\t\titem.point.copy( hit.point );\n\n\t\t\t}\n\n\t\t}\n\n\t\titem.callback( hit );\n\n\t}\n\n\t// add and remove cameras used for sorting\n\taddCamera( camera ) {\n\n\t\tconst { queryMap, cameras } = this;\n\t\tcameras.add( camera );\n\t\tqueryMap.forEach( o => this._enqueue( o ) );\n\n\t}\n\n\tdeleteCamera( camera ) {\n\n\t\tconst { cameras } = this;\n\t\tcameras.delete( camera );\n\n\t}\n\n\t// run the given item index if possible\n\trunIfNeeded( index ) {\n\n\t\tconst { queryMap, queued } = this;\n\t\tconst item = queryMap.get( index );\n\t\tif ( item.queued ) {\n\n\t\t\tthis._updateQuery( item );\n\t\t\titem.queued = false;\n\t\t\tqueued.splice( queued.indexOf( item ), 1 );\n\n\t\t}\n\n\t}\n\n\t// set the scene used for query\n\tsetScene( ...objects ) {\n\n\t\tconst { observer } = this;\n\t\tobserver.dispose();\n\t\tobjects.forEach( o => observer.observe( o ) );\n\t\tthis.objects = objects;\n\t\tthis._scheduleRun();\n\n\t}\n\n\t// update the ellipsoid and frame based on a tiles renderer, updating the item rays only if necessary\n\tsetEllipsoidFromTilesRenderer( tilesRenderer ) {\n\n\t\tconst { queryMap, ellipsoid, frame } = this;\n\t\tif (\n\t\t\t! ellipsoid.radius.equals( tilesRenderer.ellipsoid.radius ) ||\n\t\t\t! frame.equals( tilesRenderer.group.matrixWorld )\n\t\t) {\n\n\t\t\tellipsoid.copy( tilesRenderer.ellipsoid );\n\t\t\tframe.copy( tilesRenderer.group.matrixWorld );\n\n\t\t\t// update the query rays for any item specified via lat / lon\n\t\t\tqueryMap.forEach( o => {\n\n\t\t\t\tif ( 'lat' in o ) {\n\n\t\t\t\t\tconst { lat, lon, ray } = o;\n\t\t\t\t\tellipsoid.getCartographicToPosition( lat, lon, 1e4, ray.origin ).applyMatrix4( frame );\n\t\t\t\t\tellipsoid.getCartographicToNormal( lat, lon, ray.direction ).transformDirection( frame ).multiplyScalar( - 1 );\n\n\t\t\t\t}\n\n\t\t\t\tthis._enqueue( o );\n\n\t\t\t} );\n\n\n\t\t}\n\n\t}\n\n\t// register query callbacks\n\tregisterRayQuery( ray, callback ) {\n\n\t\tconst index = this.index ++;\n\t\tconst item = {\n\t\t\tray: ray.clone(),\n\t\t\tcallback,\n\t\t\tqueued: false,\n\t\t\tdistance: - 1,\n\t\t\tpoint: null,\n\t\t};\n\n\t\tthis.queryMap.set( index, item );\n\t\tthis._enqueue( item );\n\t\treturn index;\n\n\t}\n\n\tregisterLatLonQuery( lat, lon, callback ) {\n\n\t\tconst { ellipsoid, frame } = this;\n\t\tconst index = this.index ++;\n\n\t\tconst ray = new Ray();\n\t\tellipsoid.getCartographicToPosition( lat, lon, 1e4, ray.origin ).applyMatrix4( frame );\n\t\tellipsoid.getCartographicToNormal( lat, lon, ray.direction ).transformDirection( frame ).multiplyScalar( - 1 );\n\n\t\tconst item = {\n\t\t\tray: ray.clone(),\n\t\t\tlat, lon,\n\t\t\tcallback,\n\t\t\tqueued: false,\n\t\t\tdistance: - 1,\n\t\t\tpoint: null,\n\t\t};\n\n\t\tthis.queryMap.set( index, item );\n\t\tthis._enqueue( item );\n\t\treturn index;\n\n\t}\n\n\tunregisterQuery( index ) {\n\n\t\tconst { queued, queryMap } = this;\n\t\tconst item = queryMap.get( index );\n\t\tqueryMap.delete( index );\n\n\t\tif ( item && item.queued ) {\n\n\t\t\titem.queued = false;\n\t\t\tqueued.splice( queued.indexOf( item ), 1 );\n\n\t\t}\n\n\t}\n\n\t// dispose of everything\n\tdispose() {\n\n\t\tthis.queryMap.clear();\n\t\tthis.queued.length = 0;\n\t\tthis.objects.length = 0;\n\t\tthis.observer.dispose();\n\n\t}\n\n}\n\n// copied from three-mesh-bvh\nconst closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n","import { cloneElement, createContext, forwardRef, useCallback, useContext, useEffect, useMemo, useRef } from 'react';\nimport { OBJECT_FRAME } from '3d-tiles-renderer/three';\nimport { Matrix4, Ray, Vector3 } from 'three';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport { useMultipleRefs } from '../utilities/useMultipleRefs.js';\nimport { TilesRendererContext } from './TilesRenderer.jsx';\nimport { QueryManager } from '../utilities/QueryManager.js';\nimport { useDeepOptions } from '../utilities/useOptions.js';\nimport { useApplyRefs } from '../utilities/useApplyRefs.js';\n\nconst QueryManagerContext = createContext( null );\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _ray = /* @__PURE__ */ new Ray();\n\nexport const AnimatedSettledObject = forwardRef( function AnimatedSettledObject( props, ref ) {\n\n\tconst {\n\t\tinterpolationFactor = 0.025,\n\t\tonQueryUpdate = null,\n\t\t...rest\n\t} = props;\n\n\tconst tiles = useContext( TilesRendererContext );\n\tconst queries = useContext( QueryManagerContext );\n\tconst invalidate = useThree( ( { invalidate } ) => invalidate );\n\tconst target = useMemo( () => new Vector3(), [] );\n\tconst isInitialized = useMemo( () => ( { value: false } ), [] );\n\tconst isTargetSet = useMemo( () => ( { value: false } ), [] );\n\tconst objectRef = useRef( null );\n\n\tconst queryCallback = useCallback( hit => {\n\n\t\tif ( tiles === null || hit === null || objectRef.current === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { lat, lon, rayorigin, raydirection } = rest;\n\t\tif ( lat !== null && lon !== null ) {\n\n\t\t\ttarget.copy( hit.point );\n\t\t\tisTargetSet.value = true;\n\n\t\t\tqueries.ellipsoid.getObjectFrame( lat, lon, 0, 0, 0, 0, _matrix, OBJECT_FRAME ).premultiply( tiles.group.matrixWorld );\n\t\t\tobjectRef.current.quaternion.setFromRotationMatrix( _matrix );\n\t\t\tinvalidate();\n\n\t\t} else if ( rayorigin !== null && raydirection !== null ) {\n\n\t\t\ttarget.copy( hit.point );\n\t\t\tisTargetSet.value = true;\n\n\t\t\tobjectRef.current.quaternion.identity();\n\t\t\tinvalidate();\n\n\t\t}\n\n\t\tif ( onQueryUpdate ) {\n\n\t\t\tonQueryUpdate( hit );\n\n\t\t}\n\n\t}, [ invalidate, isTargetSet, queries.ellipsoid, rest, target, tiles, onQueryUpdate ] );\n\n\t// interpolate the point position\n\tuseFrame( ( state, delta ) => {\n\n\t\tif ( objectRef.current ) {\n\n\t\t\tobjectRef.current.visible = isInitialized.value;\n\n\t\t}\n\n\t\tif ( objectRef.current && isTargetSet.value ) {\n\n\t\t\t// jump the point to the target if it's being set for the first time\n\t\t\tif ( isInitialized.value === false ) {\n\n\t\t\t\tisInitialized.value = true;\n\t\t\t\tobjectRef.current.position.copy( target );\n\n\t\t\t} else {\n\n\t\t\t\t// framerate independent lerp by Freya Holmer\n\t\t\t\tconst factor = 1 - 2 ** ( - delta / interpolationFactor );\n\t\t\t\tif ( objectRef.current.position.distanceToSquared( target ) > 1e-6 ) {\n\n\t\t\t\t\tobjectRef.current.position.lerp(\n\t\t\t\t\t\ttarget, interpolationFactor === 0 ? 1 : factor\n\t\t\t\t\t);\n\n\t\t\t\t\tinvalidate();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobjectRef.current.position.copy( target );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn (\n\t\t<SettledObject\n\t\t\tref={ useMultipleRefs( objectRef, ref ) }\n\t\t\tonQueryUpdate={ queryCallback }\n\t\t\t{ ...rest }\n\t\t/>\n\t);\n\n} );\n\n// Object that updates its \"settled\" state\nexport const SettledObject = forwardRef( function SettledObject( props, ref ) {\n\n\tconst {\n\t\tcomponent = <group />,\n\t\tlat = null,\n\t\tlon = null,\n\t\trayorigin = null,\n\t\traydirection = null,\n\t\tonQueryUpdate = null,\n\n\t\t...rest\n\t} = props;\n\n\tconst objectRef = useRef( null );\n\tconst tiles = useContext( TilesRendererContext );\n\tconst queries = useContext( QueryManagerContext );\n\tconst invalidate = useThree( ( { invalidate } ) => invalidate );\n\tconst target = useMemo( () => new Vector3(), [] );\n\n\tuseEffect( () => {\n\n\t\tconst callback = hit => {\n\n\t\t\tif ( onQueryUpdate ) {\n\n\t\t\t\tonQueryUpdate( hit );\n\n\t\t\t} else if ( tiles && hit !== null && objectRef.current !== null ) {\n\n\t\t\t\tif ( lat !== null && lon !== null ) {\n\n\t\t\t\t\tobjectRef.current.position.copy( hit.point );\n\t\t\t\t\tqueries.ellipsoid.getObjectFrame( lat, lon, 0, 0, 0, 0, _matrix, OBJECT_FRAME ).premultiply( tiles.group.matrixWorld );\n\t\t\t\t\tobjectRef.current.quaternion.setFromRotationMatrix( _matrix );\n\t\t\t\t\tinvalidate();\n\n\t\t\t\t} else if ( rayorigin !== null && raydirection !== null ) {\n\n\t\t\t\t\tobjectRef.current.position.copy( hit.point );\n\t\t\t\t\tobjectRef.current.quaternion.identity();\n\t\t\t\t\tinvalidate();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( lat !== null && lon !== null ) {\n\n\t\t\tconst index = queries.registerLatLonQuery( lat, lon, callback );\n\t\t\treturn () => queries.unregisterQuery( index );\n\n\t\t} else if ( rayorigin !== null && raydirection !== null ) {\n\n\t\t\t_ray.origin.copy( rayorigin );\n\t\t\t_ray.direction.copy( raydirection );\n\t\t\tconst index = queries.registerRayQuery( _ray, callback );\n\t\t\treturn () => queries.unregisterQuery( index );\n\n\t\t}\n\n\t}, [ lat, lon, rayorigin, raydirection, queries, tiles, invalidate, target, onQueryUpdate ] );\n\n\treturn cloneElement( component, { ...rest, ref: useMultipleRefs( objectRef, ref ), raycast: () => false } );\n\n} );\n\nexport const SettledObjects = forwardRef( function SettledObjects( props, ref ) {\n\n\tconst threeScene = useThree( ( { scene } ) => scene );\n\tconst {\n\t\tscene = threeScene,\n\t\tchildren,\n\t\t...rest\n\t} = props;\n\n\tconst tiles = useContext( TilesRendererContext );\n\tconst queries = useMemo( () => new QueryManager(), [] );\n\tconst camera = useThree( ( { camera } ) => camera );\n\n\tuseDeepOptions( queries, rest );\n\n\tuseEffect( () => {\n\n\t\treturn () => queries.dispose();\n\n\t}, [ queries ] );\n\n\tuseEffect( () => {\n\n\t\tqueries.setScene( ...( Array.isArray( scene ) ? scene : [ scene ] ) );\n\n\t}, [ queries, scene ] );\n\n\tuseEffect( () => {\n\n\t\tqueries.addCamera( camera );\n\n\t}, [ queries, camera ] );\n\n\tuseFrame( () => {\n\n\t\tif ( tiles ) {\n\n\t\t\tqueries.setEllipsoidFromTilesRenderer( tiles );\n\n\t\t}\n\n\t} );\n\n\t// assign ref\n\tuseApplyRefs( queries, ref );\n\n\treturn (\n\t\t<QueryManagerContext.Provider value={ queries }>\n\t\t\t<group matrixAutoUpdate={ false } matrixWorldAutoUpdate={ false }>\n\t\t\t\t{ children }\n\t\t\t</group>\n\t\t</QueryManagerContext.Provider>\n\t);\n\n} );\n"],"names":["areObjectsEqual","a","b","key","useObjectDep","object","ref","useRef","isEventName","getEventName","match","getPath","getValueAtPath","path","curr","tokens","setValueAtPath","value","finalKey","useDeepOptions","target","options","shallow","useLayoutEffect","previousState","events","eventName","useShallowOptions","instance","useApplyRefs","refs","useEffect","TilesRendererContext","createContext","TilesPluginContext","EllipsoidContext","TileSetRoot","children","tiles","useContext","EastNorthUpFrame","props","lat","lon","height","az","el","roll","ellipsoid","WGS84_ELLIPSOID","invalidate","useThree","state","group","setGroup","useState","updateCallback","useCallback","localEllipsoid","force","i","l","Object3D","jsx","TilesPlugin","forwardRef","plugin","args","setInstance","forceUpdate","useReducer","x","TilesRenderer","url","cachedRootJson","enabled","camera","gl","setTiles","needsRender","TilesRendererImpl","useFrame","ellipsoidContextValue","useMemo","jsxs","Fragment","CanvasDOMOverlay","rest","root","setRoot","container","createRoot","StrictMode","randomID","TilesAttributionOverlay","style","generateAttributions","attributions","setAttributions","queued","callback","classId","styles","output","elements","att","element","ControlsBaseComponent","controlsConstructor","domElement","scene","ellipsoidFrame","defaultCamera","defaultScene","get","set","ellipsoidContext","appliedCamera","appliedScene","appliedDomElement","appliedEllipsoid","appliedEllipsoidFrame","controls","old","EnvironmentControls","EnvironmentControlsImpl","GlobeControls","GlobeControlsImpl","_vec","Vector3","_axis","_pos","_matrix","Matrix4","_enuMatrix","_ray","Ray","_cart","getCameraFocusPoint","tilesGroup","dist","RenderPortal","overrideRenderLoop","renderPriority","OrthographicCamera","size","currentAutoClear","TriangleGeometry","position","CompassGraphic","northColor","southColor","lightTarget","setLightTarget","groupRef","BackSide","CompassGizmo","mode","margin","scale","visible","Scene","marginX","marginY","frame","angle","createPortal","CameraTransition","onBeforeToggle","perspectiveCamera","orthographicCamera","manager","CameraTransitionManager","aspect","cameraCallback","oldPerspectiveCamera","oldOrthographicCamera","targetCamera","useMultipleRefs","traverse","c","SceneObserver","EventDispatcher","child","observed","_raycaster","Raycaster","_line0","Line3","_line1","_params","Vector2","_direction","QueryManager","Ellipsoid","queueAll","item","info","cameras","duration","start","ray","distance","inFrustum","closestPointLineToLine","p","hit","queryMap","o","index","objects","observer","tilesRenderer","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","d0232","d3210","d3232","d0210","denom","d","d2","QueryManagerContext","AnimatedSettledObject","interpolationFactor","onQueryUpdate","queries","isInitialized","isTargetSet","objectRef","queryCallback","rayorigin","raydirection","OBJECT_FRAME","delta","factor","SettledObject","component","cloneElement","SettledObjects","threeScene"],"mappings":"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"}