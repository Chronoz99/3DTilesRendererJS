{"version":3,"file":"CameraTransitionManager-SvgW6Pmv.js","sources":["../src/three/renderer/loaders/B3DMLoader.js","../src/three/renderer/loaders/rgb565torgb.js","../src/three/renderer/loaders/decodeOctNormal.js","../src/three/renderer/loaders/PNTSLoader.js","../src/three/renderer/loaders/I3DMLoader.js","../src/three/renderer/loaders/CMPTLoader.js","../src/three/renderer/tiles/TilesGroup.js","../src/three/renderer/tiles/raycastTraverse.js","../src/three/renderer/math/TileBoundingVolume.js","../src/three/renderer/math/ExtendedFrustum.js","../src/three/renderer/tiles/TilesRenderer.js","../src/three/renderer/controls/PivotPointMesh.js","../src/three/renderer/controls/PointerTracker.js","../src/three/renderer/controls/utils.js","../src/three/renderer/controls/EnvironmentControls.js","../src/three/renderer/controls/GlobeControls.js","../src/three/renderer/controls/CameraTransitionManager.js"],"sourcesContent":["import { B3DMLoaderBase } from '3d-tiles-renderer/core';\nimport { DefaultLoadingManager, Matrix4 } from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nexport class B3DMLoader extends B3DMLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.adjustmentTransform = new Matrix4();\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst b3dm = super.parse( buffer );\n\t\tconst gltfBuffer = b3dm.glbBytes.slice().buffer;\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tconst manager = this.manager;\n\t\t\tconst fetchOptions = this.fetchOptions;\n\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || new GLTFLoader( manager );\n\n\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t}\n\n\t\t\tif ( 'credentials' in fetchOptions ) {\n\n\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\n\t\t\t}\n\n\t\t\tif ( fetchOptions.headers ) {\n\n\t\t\t\tloader.setRequestHeader( fetchOptions.headers );\n\n\t\t\t}\n\n\t\t\t// GLTFLoader assumes the working path ends in a slash\n\t\t\tlet workingPath = this.workingPath;\n\t\t\tif ( ! /[\\\\/]$/.test( workingPath ) && workingPath.length ) {\n\n\t\t\t\tworkingPath += '/';\n\n\t\t\t}\n\n\t\t\tconst adjustmentTransform = this.adjustmentTransform;\n\n\t\t\tloader.parse( gltfBuffer, workingPath, model => {\n\n\t\t\t\tconst { batchTable, featureTable } = b3dm;\n\t\t\t\tconst { scene } = model;\n\n\t\t\t\tconst rtcCenter = featureTable.getData( 'RTC_CENTER', 1, 'FLOAT', 'VEC3' );\n\t\t\t\tif ( rtcCenter ) {\n\n\t\t\t\t\tscene.position.x += rtcCenter[ 0 ];\n\t\t\t\t\tscene.position.y += rtcCenter[ 1 ];\n\t\t\t\t\tscene.position.z += rtcCenter[ 2 ];\n\n\t\t\t\t}\n\n\t\t\t\tmodel.scene.updateMatrix();\n\t\t\t\tmodel.scene.matrix.multiply( adjustmentTransform );\n\t\t\t\tmodel.scene.matrix.decompose( model.scene.position, model.scene.quaternion, model.scene.scale );\n\n\t\t\t\tmodel.batchTable = batchTable;\n\t\t\t\tmodel.featureTable = featureTable;\n\n\t\t\t\tscene.batchTable = batchTable;\n\t\t\t\tscene.featureTable = featureTable;\n\n\t\t\t\tresolve( model );\n\n\t\t\t}, reject );\n\n\t\t} );\n\n\t}\n\n}\n","// The implementation of rgb565 to rgb888 is from\n// https://rgbcolorpicker.com/565\n\nexport function rgb565torgb( rgb565 ) {\n\n\t// Shift the red value to the right by 11 bits.\n\tconst red5 = rgb565 >> 11;\n\t// Shift the green value to the right by 5 bits and extract the lower 6 bits.\n\tconst green6 = ( rgb565 >> 5 ) & 0b111111;\n\t// Extract the lower 5 bits.\n\tconst blue5 = rgb565 & 0b11111;\n\n\t// Convert 5-bit red to 8-bit red.\n\tconst red8 = Math.round( ( red5 / 31 ) * 255 );\n\t// Convert 6-bit green to 8-bit green.\n\tconst green8 = Math.round( ( green6 / 63 ) * 255 );\n\t// Convert 5-bit blue to 8-bit blue.\n\tconst blue8 = Math.round( ( blue5 / 31 ) * 255 );\n\n\treturn [ red8, green8, blue8 ];\n\n}\n","import { Vector2, MathUtils, Vector3 } from 'three';\n\nconst f = /* @__PURE__ */ new Vector2();\n\n/**\n * Decode an octahedron-encoded normal (as a pair of 8-bit unsigned numbers) into a Vector3.\n *\n * Resources:\n * - https://stackoverflow.com/a/74745666/2704779\n * - https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/\n * @param {number} x The unsigned 8-bit X coordinate on the projected octahedron.\n * @param {number} y The unsigned 8-bit Y coordinate on the projected octahedron.\n * @param {Vector3} [target] The target vector.\n */\nexport function decodeOctNormal( x, y, target = new Vector3() ) {\n\n\tf.set( x, y ).divideScalar( 256 ).multiplyScalar( 2 ).subScalar( 1 );\n\n\ttarget.set( f.x, f.y, 1 - Math.abs( f.x ) - Math.abs( f.y ) );\n\n\tconst t = MathUtils.clamp( - target.z, 0, 1 );\n\n\tif ( target.x >= 0 ) {\n\n\t\ttarget.setX( target.x - t );\n\n\t} else {\n\n\t\ttarget.setX( target.x + t );\n\n\t}\n\n\tif ( target.y >= 0 ) {\n\n\t\ttarget.setY( target.y - t );\n\n\t} else {\n\n\t\ttarget.setY( target.y + t );\n\n\t}\n\n\ttarget.normalize();\n\n\treturn target;\n\n}\n","import { PNTSLoaderBase } from '3d-tiles-renderer/core';\nimport {\n\tPoints,\n\tPointsMaterial,\n\tBufferGeometry,\n\tBufferAttribute,\n\tDefaultLoadingManager,\n\tVector3,\n\tColor,\n} from 'three';\nimport { rgb565torgb } from './rgb565torgb.js';\nimport { decodeOctNormal } from './decodeOctNormal.js';\n\nconst DRACO_ATTRIBUTE_MAP = {\n\tRGB: 'color',\n\tPOSITION: 'position',\n};\n\nexport class PNTSLoader extends PNTSLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\n\t}\n\n\tparse( buffer ) {\n\n\t\treturn super.parse( buffer ).then( async ( result ) => {\n\n\t\t\tconst { featureTable, batchTable } = result;\n\n\t\t\tconst material = new PointsMaterial();\n\t\t\tconst extensions = featureTable.header.extensions;\n\t\t\tconst translationOffset = new Vector3();\n\t\t\tlet geometry;\n\n\t\t\t// handle loading the draco data\n\t\t\tif ( extensions && extensions[ '3DTILES_draco_point_compression' ] ) {\n\n\t\t\t\tconst { byteOffset, byteLength, properties } = extensions[ '3DTILES_draco_point_compression' ];\n\t\t\t\tconst dracoLoader = this.manager.getHandler( 'draco.drc' );\n\t\t\t\tif ( dracoLoader == null ) {\n\n\t\t\t\t\tthrow new Error( 'PNTSLoader: dracoLoader not available.' );\n\n\t\t\t\t}\n\n\t\t\t\t// map PNTS keys to draco types\n\t\t\t\tconst attributeIDs = {};\n\t\t\t\tfor ( const key in properties ) {\n\n\t\t\t\t\tif ( key in DRACO_ATTRIBUTE_MAP && key in properties ) {\n\n\t\t\t\t\t\tconst mappedKey = DRACO_ATTRIBUTE_MAP[ key ];\n\t\t\t\t\t\tattributeIDs[ mappedKey ] = properties[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// decode the geometry\n\t\t\t\tconst taskConfig = {\n\t\t\t\t\tattributeIDs,\n\t\t\t\t\tattributeTypes: {\n\t\t\t\t\t\tposition: 'Float32Array',\n\t\t\t\t\t\tcolor: 'Uint8Array',\n\t\t\t\t\t},\n\t\t\t\t\tuseUniqueIDs: true,\n\t\t\t\t};\n\n\t\t\t\tconst buffer = featureTable.getBuffer( byteOffset, byteLength );\n\t\t\t\tgeometry = await dracoLoader.decodeGeometry( buffer, taskConfig );\n\t\t\t\tif ( geometry.attributes.color ) {\n\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle non compressed case\n\t\t\t\tconst POINTS_LENGTH = featureTable.getData( 'POINTS_LENGTH' );\n\t\t\t\tconst POSITION = featureTable.getData( 'POSITION', POINTS_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\tconst NORMAL = featureTable.getData( 'NORMAL', POINTS_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\tconst NORMAL_OCT16P = featureTable.getData( 'NORMAL', POINTS_LENGTH, 'UNSIGNED_BYTE', 'VEC2' );\n\t\t\t\tconst RGB = featureTable.getData( 'RGB', POINTS_LENGTH, 'UNSIGNED_BYTE', 'VEC3' );\n\t\t\t\tconst RGBA = featureTable.getData( 'RGBA', POINTS_LENGTH, 'UNSIGNED_BYTE', 'VEC4' );\n\t\t\t\tconst RGB565 = featureTable.getData( 'RGB565', POINTS_LENGTH, 'UNSIGNED_SHORT', 'SCALAR' );\n\t\t\t\tconst CONSTANT_RGBA = featureTable.getData( 'CONSTANT_RGBA', POINTS_LENGTH, 'UNSIGNED_BYTE', 'VEC4' );\n\t\t\t\tconst POSITION_QUANTIZED = featureTable.getData( 'POSITION_QUANTIZED', POINTS_LENGTH, 'UNSIGNED_SHORT', 'VEC3' );\n\t\t\t\tconst QUANTIZED_VOLUME_SCALE = featureTable.getData( 'QUANTIZED_VOLUME_SCALE', POINTS_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\tconst QUANTIZED_VOLUME_OFFSET = featureTable.getData( 'QUANTIZED_VOLUME_OFFSET', POINTS_LENGTH, 'FLOAT', 'VEC3' );\n\n\t\t\t\tgeometry = new BufferGeometry();\n\n\t\t\t\tif ( POSITION_QUANTIZED ) {\n\n\t\t\t\t\tconst decodedPositions = new Float32Array( POINTS_LENGTH * 3 );\n\t\t\t\t\tfor ( let i = 0; i < POINTS_LENGTH; i ++ ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = 3 * i + j;\n\t\t\t\t\t\t\tdecodedPositions[ index ] = ( POSITION_QUANTIZED[ index ] / 65535.0 ) * QUANTIZED_VOLUME_SCALE[ j ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttranslationOffset.x = QUANTIZED_VOLUME_OFFSET[ 0 ];\n\t\t\t\t\ttranslationOffset.y = QUANTIZED_VOLUME_OFFSET[ 1 ];\n\t\t\t\t\ttranslationOffset.z = QUANTIZED_VOLUME_OFFSET[ 2 ];\n\t\t\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( decodedPositions, 3, false ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( POSITION, 3, false ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( NORMAL !== null ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( NORMAL, 3, false ) );\n\n\t\t\t\t} else if ( NORMAL_OCT16P !== null ) {\n\n\t\t\t\t\tconst decodedNormals = new Float32Array( POINTS_LENGTH * 3 );\n\n\t\t\t\t\tconst n = new Vector3();\n\n\t\t\t\t\tfor ( let i = 0; i < POINTS_LENGTH; i ++ ) {\n\n\t\t\t\t\t\tconst x = NORMAL_OCT16P[ i * 2 ];\n\t\t\t\t\t\tconst y = NORMAL_OCT16P[ i * 2 + 1 ];\n\n\t\t\t\t\t\tconst normal = decodeOctNormal( x, y, n );\n\n\t\t\t\t\t\tdecodedNormals[ i * 3 ] = normal.x;\n\t\t\t\t\t\tdecodedNormals[ i * 3 + 1 ] = normal.y;\n\t\t\t\t\t\tdecodedNormals[ i * 3 + 2 ] = normal.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( decodedNormals, 3, false ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( RGBA !== null ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( RGBA, 4, true ) );\n\t\t\t\t\tmaterial.vertexColors = true;\n\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\tmaterial.depthWrite = false;\n\n\t\t\t\t} else if ( RGB !== null ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( RGB, 3, true ) );\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t} else if ( RGB565 !== null ) {\n\n\t\t\t\t\tconst color = new Uint8Array( POINTS_LENGTH * 3 );\n\t\t\t\t\tfor ( let i = 0; i < POINTS_LENGTH; i ++ ) {\n\n\t\t\t\t\t\tconst rgbColor = rgb565torgb( RGB565[ i ] );\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = 3 * i + j;\n\t\t\t\t\t\t\tcolor[ index ] = rgbColor[ j ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( color, 3, true ) );\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t} else if ( CONSTANT_RGBA !== null ) {\n\n\t\t\t\t\tconst color = new Color( CONSTANT_RGBA[ 0 ], CONSTANT_RGBA[ 1 ], CONSTANT_RGBA[ 2 ] );\n\t\t\t\t\tmaterial.color = color;\n\t\t\t\t\tconst opacity = CONSTANT_RGBA[ 3 ] / 255;\n\t\t\t\t\tif ( opacity < 1 ) {\n\n\t\t\t\t\t\tmaterial.opacity = opacity;\n\t\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\t\tmaterial.depthWrite = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst object = new Points( geometry, material );\n\t\t\tobject.position.copy( translationOffset );\n\t\t\tresult.scene = object;\n\t\t\tresult.scene.featureTable = featureTable;\n\t\t\tresult.scene.batchTable = batchTable;\n\n\t\t\tconst rtcCenter = featureTable.getData( 'RTC_CENTER', 1, 'FLOAT', 'VEC3' );\n\t\t\tif ( rtcCenter ) {\n\n\t\t\t\tresult.scene.position.x += rtcCenter[ 0 ];\n\t\t\t\tresult.scene.position.y += rtcCenter[ 1 ];\n\t\t\t\tresult.scene.position.z += rtcCenter[ 2 ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t} );\n\n\t}\n\n}\n","import { I3DMLoaderBase } from '3d-tiles-renderer/core';\nimport { DefaultLoadingManager, Matrix4, InstancedMesh, Vector3, Quaternion } from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\n\nconst tempFwd = /* @__PURE__ */ new Vector3();\nconst tempUp = /* @__PURE__ */ new Vector3();\nconst tempRight = /* @__PURE__ */ new Vector3();\nconst tempPos = /* @__PURE__ */ new Vector3();\nconst tempQuat = /* @__PURE__ */ new Quaternion();\nconst tempSca = /* @__PURE__ */ new Vector3();\nconst tempMat = /* @__PURE__ */ new Matrix4();\nconst tempMat2 = /* @__PURE__ */ new Matrix4();\n\nconst tempGlobePos = /* @__PURE__ */ new Vector3();\nconst tempEnuFrame = /* @__PURE__ */ new Matrix4();\nconst tempLocalQuat = /* @__PURE__ */ new Quaternion();\nconst tempLatLon = {};\n\nexport class I3DMLoader extends I3DMLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.adjustmentTransform = new Matrix4();\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\n\t}\n\n\tresolveExternalURL( url ) {\n\n\t\treturn this.manager.resolveURL( super.resolveExternalURL( url ) );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\treturn super\n\t\t\t.parse( buffer )\n\t\t\t.then( i3dm => {\n\n\t\t\t\tconst { featureTable, batchTable } = i3dm;\n\t\t\t\tconst gltfBuffer = i3dm.glbBytes.slice().buffer;\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tconst fetchOptions = this.fetchOptions;\n\t\t\t\t\tconst manager = this.manager;\n\t\t\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || new GLTFLoader( manager );\n\n\t\t\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'credentials' in fetchOptions ) {\n\n\t\t\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( fetchOptions.headers ) {\n\n\t\t\t\t\t\tloader.setRequestHeader( fetchOptions.headers );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// GLTFLoader assumes the working path ends in a slash\n\t\t\t\t\tlet workingPath = i3dm.gltfWorkingPath ?? this.workingPath;\n\t\t\t\t\tif ( ! /[\\\\/]$/.test( workingPath ) ) {\n\n\t\t\t\t\t\tworkingPath += '/';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst adjustmentTransform = this.adjustmentTransform;\n\n\t\t\t\t\tloader.parse( gltfBuffer, workingPath, model => {\n\n\t\t\t\t\t\tconst INSTANCES_LENGTH = featureTable.getData( 'INSTANCES_LENGTH' );\n\t\t\t\t\t\tlet POSITION = featureTable.getData( 'POSITION', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst POSITION_QUANTIZED = featureTable.getData( 'POSITION_QUANTIZED', INSTANCES_LENGTH, 'UNSIGNED_SHORT', 'VEC3' );\n\t\t\t\t\t\tconst QUANTIZED_VOLUME_OFFSET = featureTable.getData( 'QUANTIZED_VOLUME_OFFSET', 1, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst QUANTIZED_VOLUME_SCALE = featureTable.getData( 'QUANTIZED_VOLUME_SCALE', 1, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst NORMAL_UP = featureTable.getData( 'NORMAL_UP', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst NORMAL_RIGHT = featureTable.getData( 'NORMAL_RIGHT', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst SCALE_NON_UNIFORM = featureTable.getData( 'SCALE_NON_UNIFORM', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst SCALE = featureTable.getData( 'SCALE', INSTANCES_LENGTH, 'FLOAT', 'SCALAR' );\n\t\t\t\t\t\tconst RTC_CENTER = featureTable.getData( 'RTC_CENTER', 1, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst EAST_NORTH_UP = featureTable.getData( 'EAST_NORTH_UP' );\n\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t'NORMAL_UP_OCT32P',\n\t\t\t\t\t\t\t'NORMAL_RIGHT_OCT32P',\n\t\t\t\t\t\t].forEach( feature => {\n\n\t\t\t\t\t\t\tif ( feature in featureTable.header ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( `I3DMLoader: Unsupported FeatureTable feature \"${ feature }\" detected.` );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// use quantized position if position is missing\n\t\t\t\t\t\tif ( ! POSITION && POSITION_QUANTIZED ) {\n\n\t\t\t\t\t\t\tPOSITION = new Float32Array( INSTANCES_LENGTH * 3 );\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < INSTANCES_LENGTH; i ++ ) {\n\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 0 ] = QUANTIZED_VOLUME_OFFSET[ 0 ] + ( POSITION_QUANTIZED[ i * 3 + 0 ] / 65535.0 ) * QUANTIZED_VOLUME_SCALE[ 0 ];\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 1 ] = QUANTIZED_VOLUME_OFFSET[ 1 ] + ( POSITION_QUANTIZED[ i * 3 + 1 ] / 65535.0 ) * QUANTIZED_VOLUME_SCALE[ 1 ];\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 2 ] = QUANTIZED_VOLUME_OFFSET[ 2 ] + ( POSITION_QUANTIZED[ i * 3 + 2 ] / 65535.0 ) * QUANTIZED_VOLUME_SCALE[ 2 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// get the average vector center so we can avoid floating point error due to lower\n\t\t\t\t\t\t// precision transformation calculations on the GPU\n\t\t\t\t\t\tconst averageVector = new Vector3();\n\t\t\t\t\t\tfor ( let i = 0; i < INSTANCES_LENGTH; i ++ ) {\n\n\t\t\t\t\t\t\taverageVector.x += POSITION[ i * 3 + 0 ] / INSTANCES_LENGTH;\n\t\t\t\t\t\t\taverageVector.y += POSITION[ i * 3 + 1 ] / INSTANCES_LENGTH;\n\t\t\t\t\t\t\taverageVector.z += POSITION[ i * 3 + 2 ] / INSTANCES_LENGTH;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find all the children and create associated instance meshes\n\t\t\t\t\t\tconst instances = [];\n\t\t\t\t\t\tconst meshes = [];\n\t\t\t\t\t\tmodel.scene.updateMatrixWorld();\n\n\t\t\t\t\t\tmodel.scene.traverse( child => {\n\n\t\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\t\tmeshes.push( child );\n\n\t\t\t\t\t\t\t\tconst { geometry, material } = child;\n\t\t\t\t\t\t\t\tconst instancedMesh = new InstancedMesh( geometry, material, INSTANCES_LENGTH );\n\t\t\t\t\t\t\t\tinstancedMesh.position.copy( averageVector );\n\n\t\t\t\t\t\t\t\tif ( RTC_CENTER ) {\n\n\t\t\t\t\t\t\t\t\tinstancedMesh.position.x += RTC_CENTER[ 0 ];\n\t\t\t\t\t\t\t\t\tinstancedMesh.position.y += RTC_CENTER[ 1 ];\n\t\t\t\t\t\t\t\t\tinstancedMesh.position.z += RTC_CENTER[ 2 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tinstances.push( instancedMesh );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// generate positions for all instances\n\t\t\t\t\t\tfor ( let i = 0; i < INSTANCES_LENGTH; i ++ ) {\n\n\t\t\t\t\t\t\t// position\n\t\t\t\t\t\t\ttempPos.set(\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 0 ] - averageVector.x,\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 1 ] - averageVector.y,\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 2 ] - averageVector.z,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// rotation\n\t\t\t\t\t\t\ttempQuat.identity();\n\n\t\t\t\t\t\t\t// account for EAST_NORTH_UP per-instance below\n\n\t\t\t\t\t\t\tif ( NORMAL_UP ) {\n\n\t\t\t\t\t\t\t\ttempUp.set(\n\t\t\t\t\t\t\t\t\tNORMAL_UP[ i * 3 + 0 ],\n\t\t\t\t\t\t\t\t\tNORMAL_UP[ i * 3 + 1 ],\n\t\t\t\t\t\t\t\t\tNORMAL_UP[ i * 3 + 2 ],\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempRight.set(\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT[ i * 3 + 0 ],\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT[ i * 3 + 1 ],\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT[ i * 3 + 2 ],\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempFwd.crossVectors( tempRight, tempUp )\n\t\t\t\t\t\t\t\t\t.normalize();\n\n\t\t\t\t\t\t\t\ttempMat.makeBasis(\n\t\t\t\t\t\t\t\t\ttempRight,\n\t\t\t\t\t\t\t\t\ttempUp,\n\t\t\t\t\t\t\t\t\ttempFwd,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempQuat.setFromRotationMatrix( tempMat );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// scale\n\t\t\t\t\t\t\ttempSca.set( 1, 1, 1 );\n\n\t\t\t\t\t\t\tif ( SCALE_NON_UNIFORM ) {\n\n\t\t\t\t\t\t\t\ttempSca.set(\n\t\t\t\t\t\t\t\t\tSCALE_NON_UNIFORM[ i * 3 + 0 ],\n\t\t\t\t\t\t\t\t\tSCALE_NON_UNIFORM[ i * 3 + 1 ],\n\t\t\t\t\t\t\t\t\tSCALE_NON_UNIFORM[ i * 3 + 2 ],\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( SCALE ) {\n\n\t\t\t\t\t\t\t\ttempSca.multiplyScalar( SCALE[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// multiple in the original meshes world transform\n\t\t\t\t\t\t\tfor ( let j = 0, l = instances.length; j < l; j ++ ) {\n\n\t\t\t\t\t\t\t\tconst instance = instances[ j ];\n\t\t\t\t\t\t\t\ttempLocalQuat.copy( tempQuat );\n\n\t\t\t\t\t\t\t\t// Handle east-north-up frame generation\n\t\t\t\t\t\t\t\tif ( EAST_NORTH_UP ) {\n\n\t\t\t\t\t\t\t\t\tinstance.updateMatrixWorld();\n\n\t\t\t\t\t\t\t\t\t// transform the instance position to global frame and get the rotation from the associated ENU frame.\n\t\t\t\t\t\t\t\t\ttempGlobePos.copy( tempPos ).applyMatrix4( instance.matrixWorld );\n\t\t\t\t\t\t\t\t\tthis.ellipsoid.getPositionToCartographic( tempGlobePos, tempLatLon );\n\t\t\t\t\t\t\t\t\tthis.ellipsoid.getEastNorthUpFrame( tempLatLon.lat, tempLatLon.lon, tempEnuFrame );\n\t\t\t\t\t\t\t\t\ttempLocalQuat.setFromRotationMatrix( tempEnuFrame );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttempMat.compose( tempPos, tempLocalQuat, tempSca ).multiply( adjustmentTransform );\n\n\t\t\t\t\t\t\t\tconst mesh = meshes[ j ];\n\t\t\t\t\t\t\t\ttempMat2.multiplyMatrices( tempMat, mesh.matrixWorld );\n\t\t\t\t\t\t\t\tinstance.setMatrixAt( i, tempMat2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// replace all geometry with the instances\n\t\t\t\t\t\tmodel.scene.clear();\n\t\t\t\t\t\tmodel.scene.add( ...instances );\n\n\t\t\t\t\t\tmodel.batchTable = batchTable;\n\t\t\t\t\t\tmodel.featureTable = featureTable;\n\n\t\t\t\t\t\tmodel.scene.batchTable = batchTable;\n\t\t\t\t\t\tmodel.scene.featureTable = featureTable;\n\n\t\t\t\t\t\tresolve( model );\n\n\t\t\t\t\t}, reject );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t}\n\n}\n","import { Group, DefaultLoadingManager, Matrix4 } from 'three';\nimport { CMPTLoaderBase } from '3d-tiles-renderer/core';\nimport { B3DMLoader } from './B3DMLoader.js';\nimport { PNTSLoader } from './PNTSLoader.js';\nimport { I3DMLoader } from './I3DMLoader.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\n\nexport class CMPTLoader extends CMPTLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.adjustmentTransform = new Matrix4();\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst result = super.parse( buffer );\n\t\tconst { manager, ellipsoid, adjustmentTransform } = this;\n\t\tconst promises = [];\n\n\t\tfor ( const i in result.tiles ) {\n\n\t\t\tconst { type, buffer } = result.tiles[ i ];\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'b3dm': {\n\n\t\t\t\t\tconst slicedBuffer = buffer.slice();\n\t\t\t\t\tconst loader = new B3DMLoader( manager );\n\t\t\t\t\tloader.workingPath = this.workingPath;\n\t\t\t\t\tloader.fetchOptions = this.fetchOptions;\n\t\t\t\t\tloader.adjustmentTransform.copy( adjustmentTransform );\n\n\t\t\t\t\tconst promise = loader.parse( slicedBuffer.buffer );\n\t\t\t\t\tpromises.push( promise );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcase 'pnts': {\n\n\t\t\t\t\tconst slicedBuffer = buffer.slice();\n\t\t\t\t\tconst loader = new PNTSLoader( manager );\n\t\t\t\t\tloader.workingPath = this.workingPath;\n\t\t\t\t\tloader.fetchOptions = this.fetchOptions;\n\n\t\t\t\t\tconst promise = loader.parse( slicedBuffer.buffer );\n\t\t\t\t\tpromises.push( promise );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcase 'i3dm': {\n\n\t\t\t\t\tconst slicedBuffer = buffer.slice();\n\t\t\t\t\tconst loader = new I3DMLoader( manager );\n\t\t\t\t\tloader.workingPath = this.workingPath;\n\t\t\t\t\tloader.fetchOptions = this.fetchOptions;\n\n\t\t\t\t\tloader.ellipsoid.copy( ellipsoid );\n\t\t\t\t\tloader.adjustmentTransform.copy( adjustmentTransform );\n\n\t\t\t\t\tconst promise = loader.parse( slicedBuffer.buffer );\n\t\t\t\t\tpromises.push( promise );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( promises ).then( results => {\n\n\t\t\tconst group = new Group();\n\t\t\tresults.forEach( result => {\n\n\t\t\t\tgroup.add( result.scene );\n\n\t\t\t} );\n\n\t\t\treturn {\n\n\t\t\t\ttiles: results,\n\t\t\t\tscene: group,\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n}\n","import { Group, Matrix4 } from 'three';\n\n// Specialization of \"Group\" that only updates world matrices of children if\n// the transform has changed since the last update and ignores the \"force\"\n// parameter under the assumption that the children tiles will not move.\nconst tempMat = /* @__PURE__ */ new Matrix4();\nexport class TilesGroup extends Group {\n\n\tconstructor( tilesRenderer ) {\n\n\t\tsuper();\n\t\tthis.isTilesGroup = true;\n\t\tthis.name = 'TilesRenderer.TilesGroup';\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\t// returning \"false\" ends raycast traversal\n\t\tif ( this.tilesRenderer.optimizeRaycast ) {\n\n\t\t\tthis.tilesRenderer.raycast( raycaster, intersects );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) {\n\n\t\t\tthis.updateMatrix();\n\n\t\t}\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\ttempMat.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\ttempMat.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t// check if the matrix changed relative to what it was.\n\t\t\tconst elA = tempMat.elements;\n\t\t\tconst elB = this.matrixWorld.elements;\n\t\t\tlet isDifferent = false;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\tconst itemA = elA[ i ];\n\t\t\t\tconst itemB = elB[ i ];\n\t\t\t\tconst diff = Math.abs( itemA - itemB );\n\n\t\t\t\tif ( diff > Number.EPSILON ) {\n\n\t\t\t\t\tisDifferent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isDifferent ) {\n\n\t\t\t\tthis.matrixWorld.copy( tempMat );\n\t\t\t\tthis.matrixWorldInverse.copy( tempMat ).invert();\n\n\t\t\t\t// update children\n\t\t\t\t// the children will not have to change unless the parent group has updated\n\t\t\t\tconst children = this.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tchildren[ i ].updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tif ( this.parent && updateParents ) {\n\n\t\t\tthis.parent.updateWorldMatrix( updateParents, false );\n\n\t\t}\n\n\t\t// run the normal update function to ensure children and inverse matrices are in sync\n\t\tthis.updateMatrixWorld( true );\n\n\t}\n\n}\n","import { Ray, Vector3 } from 'three';\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst _localRay = /* @__PURE__ */ new Ray();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _hitArray = [];\n\nfunction distanceSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectTileScene( tile, raycaster, renderer, intersects ) {\n\n\tconst { scene } = tile.cached;\n\tconst didRaycast = renderer.invokeOnePlugin( plugin => plugin.raycastTile && plugin.raycastTile( tile, scene, raycaster, intersects ) );\n\tif ( ! didRaycast ) {\n\n\t\traycaster.intersectObject( scene, true, intersects );\n\n\t}\n\n}\n\nfunction intersectTileSceneFirstHist( tile, raycaster, renderer ) {\n\n\tintersectTileScene( tile, raycaster, renderer, _hitArray );\n\t_hitArray.sort( distanceSort );\n\n\tconst hit = _hitArray[ 0 ] || null;\n\t_hitArray.length = 0;\n\treturn hit;\n\n}\n\nfunction isTileInitialized( tile ) {\n\n\treturn '__used' in tile;\n\n}\n\n// Returns the closest hit when traversing the tree\nexport function raycastTraverseFirstHit( renderer, tile, raycaster, localRay = null ) {\n\n\tconst { group, activeTiles } = renderer;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// get a set of intersections so we intersect the nearest one first\n\tconst array = [];\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst child = children[ i ];\n\t\tif ( ! isTileInitialized( child ) || ! child.__used ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// track the tile and hit distance for sorting\n\t\tconst boundingVolume = child.cached.boundingVolume;\n\t\tif ( boundingVolume.intersectRay( localRay, _vec ) !== null ) {\n\n\t\t\t_vec.applyMatrix4( group.matrixWorld );\n\t\t\tarray.push( {\n\t\t\t\tdistance: _vec.distanceToSquared( raycaster.ray.origin ),\n\t\t\t\ttile: child,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sort them by ascending distance\n\tarray.sort( distanceSort );\n\n\t// If the root is active make sure we've checked it\n\tlet bestHit = null;\n\tlet bestHitDistSq = Infinity;\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tconst hit = intersectTileSceneFirstHist( tile, raycaster, renderer );\n\t\tif ( hit ) {\n\n\t\t\tbestHit = hit;\n\t\t\tbestHitDistSq = hit.distance * hit.distance;\n\n\t\t}\n\n\t}\n\n\t// traverse until we find the best hit and early out if a tile bounds\n\t// couldn't possible include a best hit\n\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\tconst data = array[ i ];\n\t\tconst boundingVolumeDistSq = data.distance;\n\t\tconst tile = data.tile;\n\t\tif ( boundingVolumeDistSq > bestHitDistSq ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tconst hit = raycastTraverseFirstHit( renderer, tile, raycaster, localRay );\n\t\tif ( hit ) {\n\n\t\t\tconst hitDistSq = hit.distance * hit.distance;\n\t\t\tif ( hitDistSq < bestHitDistSq ) {\n\n\t\t\t\tbestHit = hit;\n\t\t\t\tbestHitDistSq = hitDistSq;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bestHit;\n\n}\n\nexport function raycastTraverse( renderer, tile, raycaster, intersects, localRay = null ) {\n\n\t// if the tile has not been asynchronously initialized then there's no point in\n\t// traversing the tiles to check intersections.\n\tif ( ! isTileInitialized( tile ) ) {\n\n\t\treturn;\n\n\t}\n\n\tconst { group, activeTiles } = renderer;\n\tconst { boundingVolume } = tile.cached;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// exit early if the tile isn't used or the bounding volume is not intersected\n\tif ( ! tile.__used || ! boundingVolume.intersectsRay( localRay ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// only intersect the tile geometry if it's active\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tintersectTileScene( tile, raycaster, renderer, intersects );\n\n\t}\n\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\traycastTraverse( renderer, children[ i ], raycaster, intersects, localRay );\n\n\t}\n\n}\n","import { Vector3, Sphere } from 'three';\nimport { OBB } from './OBB.js';\nimport { EllipsoidRegion } from './EllipsoidRegion.js';\n\nconst _vecX = /* @__PURE__ */ new Vector3();\nconst _vecY = /* @__PURE__ */ new Vector3();\nconst _vecZ = /* @__PURE__ */ new Vector3();\nconst _sphereVec = /* @__PURE__ */ new Vector3();\nconst _obbVec = /* @__PURE__ */ new Vector3();\n\n// TODO: check region more precisely in all functions\nexport class TileBoundingVolume {\n\n\tconstructor() {\n\n\t\tthis.sphere = null;\n\t\tthis.obb = null;\n\t\tthis.region = null;\n\n\t\tthis.regionObb = null;\n\n\t}\n\n\tintersectsRay( ray ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\t// Early out if we don't hit this tile sphere\n\t\tif ( sphere && ! ray.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Early out if we don't this this tile box\n\t\tif ( obb && ! obb.intersectsRay( ray ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectRay( ray, target = null ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistSq = - Infinity;\n\t\tlet obbDistSq = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\tif ( ray.intersectSphere( sphere, _sphereVec ) ) {\n\n\t\t\t\tsphereDistSq = sphere.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _sphereVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tif ( obb.intersectRay( ray, _obbVec ) ) {\n\n\t\t\t\tobbDistSq = obb.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _obbVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if we didn't hit anything then exit\n\t\tconst furthestDist = Math.max( sphereDistSq, obbDistSq );\n\t\tif ( furthestDist === - Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// get the furthest hit point if needed\n\t\tray.at( Math.sqrt( furthestDist ), target );\n\t\treturn target;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistance = - Infinity;\n\t\tlet obbDistance = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\t// Sphere#distanceToPoint is negative inside the sphere, whereas Box3#distanceToPoint is\n\t\t\t// zero inside the box. Clipping the distance to a minimum of zero ensures that both\n\t\t\t// types of bounding volume behave the same way.\n\t\t\tsphereDistance = Math.max( sphere.distanceToPoint( point ), 0 );\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tobbDistance = obb.distanceToPoint( point );\n\n\t\t}\n\n\t\t// return the further distance of the two volumes\n\t\treturn sphereDistance > obbDistance ? sphereDistance : obbDistance;\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! frustum.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsFrustum( frustum ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// if we don't have a sphere or obb then just say we did intersect\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsSphere( otherSphere ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! sphere.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsOBB( otherObb ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! otherObb.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsOBB( otherObb ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tgetOBB( targetBox, targetMatrix ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tif ( obb ) {\n\n\t\t\ttargetBox.copy( obb.box );\n\t\t\ttargetMatrix.copy( obb.transform );\n\n\t\t} else {\n\n\t\t\tthis.getAABB( targetBox );\n\t\t\ttargetMatrix.identity();\n\n\t\t}\n\n\t}\n\n\tgetAABB( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\tthis.sphere.getBoundingBox( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\ttarget.copy( obb.box ).applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tgetSphere( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\ttarget.copy( this.sphere );\n\n\t\t} else if ( this.region ) {\n\n\t\t\tthis.region.getBoundingSphere( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\tobb.box.getBoundingSphere( target );\n\t\t\ttarget.applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tsetObbData( data, transform ) {\n\n\t\tconst obb = new OBB();\n\n\t\t// get the extents of the bounds in each axis\n\t\t_vecX.set( data[ 3 ], data[ 4 ], data[ 5 ] );\n\t\t_vecY.set( data[ 6 ], data[ 7 ], data[ 8 ] );\n\t\t_vecZ.set( data[ 9 ], data[ 10 ], data[ 11 ] );\n\n\t\tconst scaleX = _vecX.length();\n\t\tconst scaleY = _vecY.length();\n\t\tconst scaleZ = _vecZ.length();\n\n\t\t_vecX.normalize();\n\t\t_vecY.normalize();\n\t\t_vecZ.normalize();\n\n\t\t// handle the case where the box has a dimension of 0 in one axis\n\t\tif ( scaleX === 0 ) {\n\n\t\t\t_vecX.crossVectors( _vecY, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleY === 0 ) {\n\n\t\t\t_vecY.crossVectors( _vecX, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleZ === 0 ) {\n\n\t\t\t_vecZ.crossVectors( _vecX, _vecY );\n\n\t\t}\n\n\t\t// create the oriented frame that the box exists in\n\t\tobb.transform\n\t\t\t.set(\n\t\t\t\t_vecX.x, _vecY.x, _vecZ.x, data[ 0 ],\n\t\t\t\t_vecX.y, _vecY.y, _vecZ.y, data[ 1 ],\n\t\t\t\t_vecX.z, _vecY.z, _vecZ.z, data[ 2 ],\n\t\t\t\t0, 0, 0, 1\n\t\t\t)\n\t\t\t.premultiply( transform );\n\n\t\t// scale the box by the extents\n\t\tobb.box.min.set( - scaleX, - scaleY, - scaleZ );\n\t\tobb.box.max.set( scaleX, scaleY, scaleZ );\n\t\tobb.update();\n\t\tthis.obb = obb;\n\n\t}\n\n\tsetSphereData( x, y, z, radius, transform ) {\n\n\t\tconst sphere = new Sphere();\n\t\tsphere.center.set( x, y, z );\n\t\tsphere.radius = radius;\n\t\tsphere.applyMatrix4( transform );\n\t\tthis.sphere = sphere;\n\n\t}\n\n\tsetRegionData( ellipsoid, west, south, east, north, minHeight, maxHeight ) {\n\n\t\tconst region = new EllipsoidRegion(\n\t\t\t...ellipsoid.radius,\n\t\t\tsouth, north,\n\t\t\twest, east,\n\t\t\tminHeight, maxHeight,\n\t\t);\n\n\t\tconst obb = new OBB();\n\t\tregion.getBoundingBox( obb.box, obb.transform );\n\t\tobb.update();\n\n\t\tthis.region = region;\n\t\tthis.regionObb = obb;\n\n\t}\n\n}\n","import { Frustum, Matrix3, Vector3 } from 'three';\n\nconst _mat3 = /* @__PURE__ */ new Matrix3();\n\n// Solve a system of equations to find the point where the three planes intersect\nfunction findIntersectionPoint( plane1, plane2, plane3, target ) {\n\n\t// Create the matrix A using the normals of the planes as rows\n\tconst A = _mat3.set(\n\t\tplane1.normal.x, plane1.normal.y, plane1.normal.z,\n\t\tplane2.normal.x, plane2.normal.y, plane2.normal.z,\n\t\tplane3.normal.x, plane3.normal.y, plane3.normal.z\n\t);\n\n\t// Create the vector B using the constants of the planes\n\ttarget.set( - plane1.constant, - plane2.constant, - plane3.constant );\n\n\t// Solve for X by applying the inverse matrix to B\n\ttarget.applyMatrix3( A.invert() );\n\n\treturn target;\n\n}\n\nclass ExtendedFrustum extends Frustum {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.points = Array( 8 ).fill().map( () => new Vector3() );\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem ) {\n\n\t\tsuper.setFromProjectionMatrix( m, coordinateSystem );\n\t\tthis.calculateFrustumPoints();\n\t\treturn this;\n\n\t}\n\n\tcalculateFrustumPoints() {\n\n\t\tconst { planes, points } = this;\n\t\tconst planeIntersections = [\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 4 ] ], // Near top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 4 ] ], // Near top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 4 ] ], // Near bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 4 ] ], // Near bottom right\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 5 ] ], // Far top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 5 ] ], // Far top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 5 ] ], // Far bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 5 ] ], // Far bottom right\n\t\t];\n\n\t\tplaneIntersections.forEach( ( planes, index ) => {\n\n\t\t\tfindIntersectionPoint( planes[ 0 ], planes[ 1 ], planes[ 2 ], points[ index ] );\n\n\t\t} );\n\n\t}\n\n}\n\nexport { ExtendedFrustum };\n","import { TilesRendererBase, LoaderUtils } from '3d-tiles-renderer/core';\nimport { B3DMLoader } from '../loaders/B3DMLoader.js';\nimport { PNTSLoader } from '../loaders/PNTSLoader.js';\nimport { I3DMLoader } from '../loaders/I3DMLoader.js';\nimport { CMPTLoader } from '../loaders/CMPTLoader.js';\nimport { TilesGroup } from './TilesGroup.js';\nimport {\n\tMatrix4,\n\tVector3,\n\tVector2,\n\tEuler,\n\tLoadingManager,\n\tEventDispatcher,\n\tGroup,\n} from 'three';\nimport { raycastTraverse, raycastTraverseFirstHit } from './raycastTraverse.js';\nimport { TileBoundingVolume } from '../math/TileBoundingVolume.js';\nimport { ExtendedFrustum } from '../math/ExtendedFrustum.js';\nimport { estimateBytesUsed } from '../utils/MemoryUtils.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nconst _mat = /* @__PURE__ */ new Matrix4();\nconst _euler = /* @__PURE__ */ new Euler();\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst INITIAL_FRUSTUM_CULLED = Symbol( 'INITIAL_FRUSTUM_CULLED' );\nconst tempMat = /* @__PURE__ */ new Matrix4();\nconst tempVector = /* @__PURE__ */ new Vector3();\nconst tempVector2 = /* @__PURE__ */ new Vector2();\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n};\n\nconst X_AXIS = /* @__PURE__ */ new Vector3( 1, 0, 0 );\nconst Y_AXIS = /* @__PURE__ */ new Vector3( 0, 1, 0 );\n\nfunction updateFrustumCulled( object, toInitialValue ) {\n\n\tobject.traverse( c => {\n\n\t\tc.frustumCulled = c[ INITIAL_FRUSTUM_CULLED ] && toInitialValue;\n\n\t} );\n\n}\n\nexport class TilesRenderer extends TilesRendererBase {\n\n\tget autoDisableRendererCulling() {\n\n\t\treturn this._autoDisableRendererCulling;\n\n\t}\n\n\tset autoDisableRendererCulling( value ) {\n\n\t\tif ( this._autoDisableRendererCulling !== value ) {\n\n\t\t\tsuper._autoDisableRendererCulling = value;\n\t\t\tthis.forEachLoadedModel( ( scene ) => {\n\n\t\t\t\tupdateFrustumCulled( scene, ! value );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tget optimizeRaycast() {\n\n\t\treturn this._optimizeRaycast;\n\n\t}\n\n\tset optimizeRaycast( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"optimizeRaycast\" option has been deprecated.' );\n\t\tthis._optimizeRaycast = v;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.group = new TilesGroup( this );\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.cameras = [];\n\t\tthis.cameraMap = new Map();\n\t\tthis.cameraInfo = [];\n\t\tthis._optimizeRaycast = true;\n\t\tthis._upRotationMatrix = new Matrix4();\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\t// flag indicating whether frustum culling should be disabled\n\t\tthis._autoDisableRendererCulling = true;\n\n\t\tthis.manager = new LoadingManager();\n\n\t\t// saved for event dispatcher functions\n\t\tthis._listeners = {};\n\n\t}\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\tEventDispatcher.prototype.addEventListener.call( this, type, listener );\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\treturn EventDispatcher.prototype.hasEventListener.call( this, type, listener );\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\tEventDispatcher.prototype.removeEventListener.call( this, type, listener );\n\n\t}\n\n\tdispatchEvent( e ) {\n\n\t\tif ( 'tileset' in e ) {\n\n\t\t\tObject.defineProperty( e, 'tileSet', {\n\t\t\t\tget() {\n\n\t\t\t\t\tconsole.warn( 'TilesRenderer: \"event.tileSet\" has been deprecated. Use \"event.tileset\" instead.' );\n\t\t\t\t\treturn e.tileset;\n\n\t\t\t\t},\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t} );\n\n\t\t}\n\n\t\tEventDispatcher.prototype.dispatchEvent.call( this, e );\n\n\t}\n\n\t/* Public API */\n\tgetBoundingBox( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getAABB( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetOrientedBoundingBox( targetBox, targetMatrix ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getOBB( targetBox, targetMatrix );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getSphere( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tforEachLoadedModel( callback ) {\n\n\t\tthis.traverse( tile => {\n\n\t\t\tconst scene = tile.cached && tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tcallback( scene, tile );\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( raycaster.firstHitOnly ) {\n\n\t\t\tconst hit = raycastTraverseFirstHit( this, this.root, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\traycastTraverse( this, this.root, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\thasCamera( camera ) {\n\n\t\treturn this.cameraMap.has( camera );\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\tcameraMap.set( camera, new Vector2() );\n\t\t\tcameras.push( camera );\n\t\t\tthis.dispatchEvent( { type: 'add-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tsetResolution( camera, xOrVec, y ) {\n\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst width = xOrVec.isVector2 ? xOrVec.x : xOrVec;\n\t\tconst height = xOrVec.isVector2 ? xOrVec.y : y;\n\t\tconst cameraVec = cameraMap.get( camera );\n\n\t\tif ( cameraVec.width !== width || cameraVec.height !== height ) {\n\n\t\t\tcameraVec.set( width, height );\n\t\t\tthis.dispatchEvent( { type: 'camera-resolution-change' } );\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tsetResolutionFromRenderer( camera, renderer ) {\n\n\t\trenderer.getSize( tempVector2 );\n\n\t\treturn this.setResolution( camera, tempVector2.x, tempVector2.y );\n\n\t}\n\n\tdeleteCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( cameraMap.has( camera ) ) {\n\n\t\t\tconst index = cameras.indexOf( camera );\n\t\t\tcameras.splice( index, 1 );\n\t\t\tcameraMap.delete( camera );\n\t\t\tthis.dispatchEvent( { type: 'delete-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/* Overriden */\n\tloadRootTileset( ...args ) {\n\n\t\treturn super.loadRootTileset( ...args )\n\t\t\t.then( root => {\n\n\t\t\t\t// cache the gltf tileset rotation matrix\n\t\t\t\tconst { asset, extensions = {} } = root;\n\t\t\t\tconst upAxis = asset && asset.gltfUpAxis || 'y';\n\t\t\t\tswitch ( upAxis.toLowerCase() ) {\n\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( Y_AXIS, - Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( X_AXIS, Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// update the ellipsoid based on the extension\n\t\t\t\tif ( '3DTILES_ellipsoid' in extensions ) {\n\n\t\t\t\t\tconst ext = extensions[ '3DTILES_ellipsoid' ];\n\t\t\t\t\tconst { ellipsoid } = this;\n\t\t\t\t\tellipsoid.name = ext.body;\n\t\t\t\t\tif ( ext.radii ) {\n\n\t\t\t\t\t\tellipsoid.radius.set( ...ext.radii );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tellipsoid.radius.set( 1, 1, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t}\n\n\tupdate() {\n\n\t\t// check if the plugins that can block the tile updates require it\n\t\tlet needsUpdate = null;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.doTilesNeedUpdate ) {\n\n\t\t\t\tconst res = plugin.doTilesNeedUpdate();\n\t\t\t\tif ( needsUpdate === null ) {\n\n\t\t\t\t\tneedsUpdate = res;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tneedsUpdate = Boolean( needsUpdate || res );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( needsUpdate === false ) {\n\n\t\t\tthis.dispatchEvent( { type: 'update-before' } );\n\t\t\tthis.dispatchEvent( { type: 'update-after' } );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// follow through with the update\n\t\tthis.dispatchEvent( { type: 'update-before' } );\n\n\t\tconst group = this.group;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tconst cameraInfo = this.cameraInfo;\n\n\t\t// automatically scale the array of cameraInfo to match the cameras\n\t\twhile ( cameraInfo.length > cameras.length ) {\n\n\t\t\tcameraInfo.pop();\n\n\t\t}\n\n\t\twhile ( cameraInfo.length < cameras.length ) {\n\n\t\t\tcameraInfo.push( {\n\n\t\t\t\tfrustum: new ExtendedFrustum(),\n\t\t\t\tisOrthographic: false,\n\t\t\t\tsseDenominator: - 1, // used if isOrthographic:false\n\t\t\t\tposition: new Vector3(),\n\t\t\t\tinvScale: - 1,\n\t\t\t\tpixelSize: 0, // used if isOrthographic:true\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// extract scale of group container\n\t\ttempVector.setFromMatrixScale( group.matrixWorldInverse );\n\t\tif ( Math.abs( Math.max( tempVector.x - tempVector.y, tempVector.x - tempVector.z ) ) > 1e-6 ) {\n\n\t\t\tconsole.warn( 'ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.' );\n\n\t\t}\n\n\t\t// store the camera cameraInfo in the 3d tiles root frame\n\t\tfor ( let i = 0, l = cameraInfo.length; i < l; i ++ ) {\n\n\t\t\tconst camera = cameras[ i ];\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tconst frustum = info.frustum;\n\t\t\tconst position = info.position;\n\t\t\tconst resolution = cameraMap.get( camera );\n\n\t\t\tif ( resolution.width === 0 || resolution.height === 0 ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: resolution for camera error calculation is not set.' );\n\n\t\t\t}\n\n\t\t\t// Read the calculated projection matrix directly to support custom Camera implementations\n\t\t\tconst projection = camera.projectionMatrix.elements;\n\n\t\t\t// The last element of the projection matrix is 1 for orthographic, 0 for perspective\n\t\t\tinfo.isOrthographic = projection[ 15 ] === 1;\n\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\t// See OrthographicCamera.updateProjectionMatrix and Matrix4.makeOrthographic:\n\t\t\t\t// the view width and height are used to populate matrix elements 0 and 5.\n\t\t\t\tconst w = 2 / projection[ 0 ];\n\t\t\t\tconst h = 2 / projection[ 5 ];\n\t\t\t\tinfo.pixelSize = Math.max( h / resolution.height, w / resolution.width );\n\n\t\t\t} else {\n\n\t\t\t\t// See PerspectiveCamera.updateProjectionMatrix and Matrix4.makePerspective:\n\t\t\t\t// the vertical FOV is used to populate matrix element 5.\n\t\t\t\tinfo.sseDenominator = ( 2 / projection[ 5 ] ) / resolution.height;\n\n\t\t\t}\n\n\t\t\t// get frustum in group root frame\n\t\t\ttempMat.copy( group.matrixWorld );\n\t\t\ttempMat.premultiply( camera.matrixWorldInverse );\n\t\t\ttempMat.premultiply( camera.projectionMatrix );\n\n\t\t\tfrustum.setFromProjectionMatrix( tempMat );\n\n\t\t\t// get transform position in group root frame\n\t\t\tposition.set( 0, 0, 0 );\n\t\t\tposition.applyMatrix4( camera.matrixWorld );\n\t\t\tposition.applyMatrix4( group.matrixWorldInverse );\n\n\t\t}\n\n\t\tsuper.update();\n\n\t\tthis.dispatchEvent( { type: 'update-after' } );\n\n\t\t// check for cameras _after_ base update so we can enable pre-loading the root tileset\n\t\tif ( cameras.length === 0 && this.root ) {\n\n\t\t\tlet found = false;\n\t\t\tthis.invokeAllPlugins( plugin => found = found || Boolean( plugin !== this && plugin.calculateTileViewError ) );\n\t\t\tif ( found === false ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: no cameras defined. Cannot update 3d tiles.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tilesetDir, parentTile = null ) {\n\n\t\tsuper.preprocessNode( tile, tilesetDir, parentTile );\n\n\t\tconst transform = new Matrix4();\n\t\tif ( tile.transform ) {\n\n\t\t\tconst transformArr = tile.transform;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransform.elements[ i ] = transformArr[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parentTile ) {\n\n\t\t\ttransform.premultiply( parentTile.cached.transform );\n\n\t\t}\n\n\t\tconst transformInverse = new Matrix4().copy( transform ).invert();\n\t\tconst boundingVolume = new TileBoundingVolume();\n\t\tif ( 'sphere' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setSphereData( ...tile.boundingVolume.sphere, transform );\n\n\t\t}\n\n\t\tif ( 'box' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setObbData( tile.boundingVolume.box, transform );\n\n\t\t}\n\n\t\tif ( 'region' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setRegionData( this.ellipsoid, ...tile.boundingVolume.region );\n\n\t\t}\n\n\t\ttile.cached = {\n\n\t\t\ttransform,\n\t\t\ttransformInverse,\n\n\t\t\tactive: false,\n\n\t\t\tboundingVolume,\n\n\t\t\tmetadata: null,\n\t\t\tscene: null,\n\t\t\tgeometry: null,\n\t\t\tmaterials: null,\n\t\t\ttextures: null,\n\n\t\t};\n\n\t}\n\n\tasync parseTile( buffer, tile, extension, uri, abortSignal ) {\n\n\t\tconst cached = tile.cached;\n\t\tconst workingPath = LoaderUtils.getWorkingPath( uri );\n\t\tconst fetchOptions = this.fetchOptions;\n\n\t\tconst manager = this.manager;\n\t\tlet promise = null;\n\n\t\tconst cachedTransform = cached.transform;\n\t\tconst upRotationMatrix = this._upRotationMatrix;\n\t\tconst fileType = ( LoaderUtils.readMagicBytes( buffer ) || extension ).toLowerCase();\n\t\tswitch ( fileType ) {\n\n\t\t\tcase 'b3dm': {\n\n\t\t\t\tconst loader = new B3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'pnts': {\n\n\t\t\t\tconst loader = new PNTSLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'i3dm': {\n\n\t\t\t\tconst loader = new I3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'cmpt': {\n\n\t\t\t\tconst loader = new CMPTLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene\t);\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// 3DTILES_content_gltf\n\t\t\tcase 'gltf':\n\t\t\tcase 'glb': {\n\n\t\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || manager.getHandler( 'path.glb' ) || new GLTFLoader( manager );\n\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\t\t\t\tloader.setRequestHeader( fetchOptions.headers || {} );\n\t\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t\t}\n\n\t\t\t\t// assume any pre-registered loader has paths configured as the user desires, but if we're making\n\t\t\t\t// a new loader, use the working path during parse to support relative uris on other hosts\n\t\t\t\tlet resourcePath = loader.resourcePath || loader.path || workingPath;\n\t\t\t\tif ( ! /[\\\\/]$/.test( resourcePath ) && resourcePath.length ) {\n\n\t\t\t\t\tresourcePath += '/';\n\n\t\t\t\t}\n\n\t\t\t\tpromise = loader.parseAsync( buffer, resourcePath ).then( result => {\n\n\t\t\t\t\t// glTF files are not guaranteed to include a scene object\n\t\t\t\t\tresult.scene = result.scene || new Group();\n\n\t\t\t\t\t// apply the local up-axis correction rotation\n\t\t\t\t\t// GLTFLoader seems to never set a transformation on the root scene object so\n\t\t\t\t\t// any transformations applied to it can be assumed to be applied after load\n\t\t\t\t\t// (such as applying RTC_CENTER) meaning they should happen _after_ the z-up\n\t\t\t\t\t// rotation fix which is why \"multiply\" happens here.\n\t\t\t\t\tconst { scene } = result;\n\t\t\t\t\tscene.updateMatrix();\n\t\t\t\t\tscene.matrix\n\t\t\t\t\t\t.multiply( upRotationMatrix )\n\t\t\t\t\t\t.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t\t\t\treturn result;\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tdefault: {\n\n\t\t\t\tpromise = this.invokeOnePlugin( plugin => plugin.parseToMesh && plugin.parseToMesh( buffer, tile, extension, uri, abortSignal ) );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// wait for the tile to load\n\t\tconst result = await promise;\n\t\tif ( result === null ) {\n\n\t\t\tthrow new Error( `TilesRenderer: Content type \"${ fileType }\" not supported.` );\n\n\t\t}\n\n\t\t// get the scene data\n\t\tlet scene;\n\t\tlet metadata;\n\t\tif ( result.isObject3D ) {\n\n\t\t\tscene = result;\n\t\t\tmetadata = null;\n\n\t\t} else {\n\n\t\t\tscene = result.scene;\n\t\t\tmetadata = result;\n\n\t\t}\n\n\t\t// ensure the matrix is up to date in case the scene has a transform applied\n\t\tscene.updateMatrix();\n\t\tscene.matrix.premultiply( cachedTransform );\n\t\tscene.matrix.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t// wait for extra processing by plugins if needed\n\t\tawait this.invokeAllPlugins( plugin => {\n\n\t\t\treturn plugin.processTileModel && plugin.processTileModel( scene, tile );\n\n\t\t} );\n\n\t\t// frustum culling\n\t\tscene.traverse( c => {\n\n\t\t\tc[ INITIAL_FRUSTUM_CULLED ] = c.frustumCulled;\n\n\t\t} );\n\t\tupdateFrustumCulled( scene, ! this.autoDisableRendererCulling );\n\n\t\t// collect all original geometries, materials, etc to be disposed of later\n\t\tconst materials = [];\n\t\tconst geometry = [];\n\t\tconst textures = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.geometry ) {\n\n\t\t\t\tgeometry.push( c.geometry );\n\n\t\t\t}\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tmaterials.push( c.material );\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// exit early if a new request has already started\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\t// dispose of any image bitmaps that have been opened.\n\t\t\t// TODO: share this code with the \"disposeTile\" code below, possibly allow for the tiles\n\t\t\t// renderer base to trigger a disposal of unneeded data\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tcached.materials = materials;\n\t\tcached.geometry = geometry;\n\t\tcached.textures = textures;\n\t\tcached.scene = scene;\n\t\tcached.metadata = metadata;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tsuper.disposeTile( tile );\n\n\t\t// This could get called before the tile has finished downloading\n\t\tconst cached = tile.cached;\n\t\tif ( cached.scene ) {\n\n\t\t\tconst materials = cached.materials;\n\t\t\tconst geometry = cached.geometry;\n\t\t\tconst textures = cached.textures;\n\t\t\tconst parent = cached.scene.parent;\n\n\t\t\t// dispose of any textures required by the mesh features extension\n\t\t\t// TODO: these are being discarded here to remove the image bitmaps -\n\t\t\t// can this be handled in another way? Or more generically?\n\t\t\tcached.scene.traverse( child => {\n\n\t\t\t\tif ( child.userData.meshFeatures ) {\n\n\t\t\t\t\tchild.userData.meshFeatures.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tif ( child.userData.structuralMetadata ) {\n\n\t\t\t\t\tchild.userData.structuralMetadata.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tfor ( let i = 0, l = geometry.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterials[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tparent.remove( cached.scene );\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( {\n\t\t\t\ttype: 'dispose-model',\n\t\t\t\tscene: cached.scene,\n\t\t\t\ttile,\n\t\t\t} );\n\n\t\t\tcached.scene = null;\n\t\t\tcached.materials = null;\n\t\t\tcached.textures = null;\n\t\t\tcached.geometry = null;\n\t\t\tcached.metadata = null;\n\n\t\t}\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.cached.scene;\n\t\tconst group = this.group;\n\n\t\tif ( visible ) {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.add( scene );\n\t\t\t\tscene.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.remove( scene );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsuper.setTileVisible( tile, visible );\n\n\t\tthis.dispatchEvent( {\n\t\t\ttype: 'tile-visibility-change',\n\t\t\tscene,\n\t\t\ttile,\n\t\t\tvisible,\n\t\t} );\n\n\t}\n\n\tcalculateBytesUsed( tile, scene ) {\n\n\t\tconst bytesUsed = this._bytesUsed;\n\t\tif ( ! bytesUsed.has( tile ) && scene ) {\n\n\t\t\tbytesUsed.set( tile, estimateBytesUsed( scene ) );\n\n\t\t}\n\n\t\treturn bytesUsed.get( tile ) ?? null;\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\tconst cached = tile.cached;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraInfo = this.cameraInfo;\n\t\tconst boundingVolume = cached.boundingVolume;\n\n\t\tlet inView = false;\n\t\tlet inViewError = - Infinity;\n\t\tlet inViewDistance = Infinity;\n\t\tlet maxError = - Infinity;\n\t\tlet minDistance = Infinity;\n\n\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t// calculate the camera error\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tlet error;\n\t\t\tlet distance;\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\tconst pixelSize = info.pixelSize;\n\t\t\t\terror = tile.geometricError / pixelSize;\n\t\t\t\tdistance = Infinity;\n\n\t\t\t} else {\n\n\t\t\t\t// avoid dividing 0 by 0 which can result in NaN. If the distance to the tile is\n\t\t\t\t// 0 then the error should be infinity.\n\t\t\t\tconst sseDenominator = info.sseDenominator;\n\t\t\t\tdistance = boundingVolume.distanceToPoint( info.position );\n\t\t\t\terror = distance === 0 ? Infinity : tile.geometricError / ( distance * sseDenominator );\n\n\t\t\t}\n\n\t\t\t// Track which camera frustums this tile is in so we can use it\n\t\t\t// to ignore the error calculations for cameras that can't see it\n\t\t\tconst frustum = cameraInfo[ i ].frustum;\n\t\t\tif ( boundingVolume.intersectsFrustum( frustum ) ) {\n\n\t\t\t\tinView = true;\n\t\t\t\tinViewError = Math.max( inViewError, error );\n\t\t\t\tinViewDistance = Math.min( inViewDistance, distance );\n\n\t\t\t}\n\n\t\t\tmaxError = Math.max( maxError, error );\n\t\t\tminDistance = Math.min( minDistance, distance );\n\n\t\t}\n\n\t\t// check the plugin visibility\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin !== this && plugin.calculateTileViewError && plugin.calculateTileViewError( tile, viewErrorTarget ) ) {\n\n\t\t\t\t// Tile shall be traversed if inView for at least one plugin.\n\t\t\t\tinView = inView && viewErrorTarget.inView;\n\t\t\t\tmaxError = Math.max( maxError, viewErrorTarget.error );\n\n\t\t\t\tif ( viewErrorTarget.inView ) {\n\n\t\t\t\t\tinViewError = Math.max( inViewError, viewErrorTarget.error );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// If the tiles are out of view then use the global distance and error calculated\n\t\tif ( inView ) {\n\n\t\t\ttarget.inView = true;\n\t\t\ttarget.error = inViewError;\n\t\t\ttarget.distanceFromCamera = inViewDistance;\n\n\t\t} else {\n\n\t\t\ttarget.inView = viewErrorTarget.inView;\n\t\t\ttarget.error = maxError;\n\t\t\ttarget.distanceFromCamera = minDistance;\n\n\t\t}\n\n\t}\n\n\t// adjust the rotation of the group such that Y is altitude, X is North, and Z is East\n\tsetLatLonToYUp( lat, lon ) {\n\n\t\tconsole.warn( 'TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.' );\n\n\t\tconst { ellipsoid, group } = this;\n\n\t\t_euler.set( Math.PI / 2, Math.PI / 2, 0 );\n\t\t_mat.makeRotationFromEuler( _euler );\n\n\t\tellipsoid.getEastNorthUpFrame( lat, lon, 0, group.matrix )\n\t\t\t.multiply( _mat )\n\t\t\t.invert()\n\t\t\t.decompose(\n\t\t\t\tgroup.position,\n\t\t\t\tgroup.quaternion,\n\t\t\t\tgroup.scale,\n\t\t\t);\n\n\t\tgroup.updateMatrixWorld( true );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.group.removeFromParent();\n\n\t}\n\n}\n","import { Mesh, PlaneGeometry, ShaderMaterial, Vector2 } from 'three';\n\nexport class PivotPointMesh extends Mesh {\n\n\tconstructor() {\n\n\t\tsuper( new PlaneGeometry( 0, 0 ), new PivotMaterial() );\n\t\tthis.renderOrder = Infinity;\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\t\trenderer.getSize( uniforms.resolution.value );\n\n\t}\n\n\tupdateMatrixWorld() {\n\n\t\tthis.matrixWorld.makeTranslation( this.position );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PivotMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: true,\n\n\t\t\tuniforms: {\n\n\t\t\t\tresolution: { value: new Vector2() },\n\t\t\t\tsize: { value: 15 },\n\t\t\t\tthickness: { value: 2 },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tuniform float pixelRatio;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\t\t\t\t\tvec2 offset = uv * 2.0 - vec2( 1.0 );\n\t\t\t\t\toffset.y *= aspect;\n\n\t\t\t\t\tvec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tscreenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;\n\n\t\t\t\t\tgl_Position = screenPoint;\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat ht = 0.5 * thickness;\n\t\t\t\t\tfloat planeDim = size + thickness;\n\t\t\t\t\tfloat offset = ( planeDim - ht - 2.0 ) / planeDim;\n\t\t\t\t\tfloat texelThickness = ht / planeDim;\n\n\t\t\t\t\tvec2 vec = vUv * 2.0 - vec2( 1.0 );\n\t\t\t\t\tfloat dist = abs( length( vec ) - offset );\n\t\t\t\t\tfloat fw = fwidth( dist ) * 0.5;\n\t\t\t\t\tfloat a = smoothstep( texelThickness - fw, texelThickness + fw, dist );\n\n\t\t\t\t\tgl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n","import { Vector2 } from 'three';\n\nconst _vec = /* @__PURE__ */ new Vector2();\nconst _vec2 = /* @__PURE__ */ new Vector2();\nexport class PointerTracker {\n\n\tconstructor() {\n\n\t\tthis.domElement = null;\n\t\tthis.buttons = 0;\n\t\tthis.pointerType = null;\n\t\tthis.pointerOrder = [];\n\t\tthis.previousPositions = {};\n\t\tthis.pointerPositions = {};\n\t\tthis.startPositions = {};\n\t\tthis.pointerSetThisFrame = {};\n\t\tthis.hoverPosition = new Vector2();\n\t\tthis.hoverSet = false;\n\n\t}\n\n\treset() {\n\n\t\tthis.buttons = 0;\n\t\tthis.pointerType = null;\n\t\tthis.pointerOrder = [];\n\t\tthis.previousPositions = {};\n\t\tthis.pointerPositions = {};\n\t\tthis.startPositions = {};\n\t\tthis.pointerSetThisFrame = {};\n\t\tthis.hoverPosition = new Vector2();\n\t\tthis.hoverSet = false;\n\n\t}\n\n\t// The pointers can be set multiple times per frame so track whether the pointer has\n\t// been set this frame or not so we don't overwrite the previous position and lose information\n\t// about pointer movement\n\tupdateFrame() {\n\n\t\tconst { previousPositions, pointerPositions } = this;\n\t\tfor ( const id in pointerPositions ) {\n\n\t\t\tpreviousPositions[ id ].copy( pointerPositions[ id ] );\n\n\t\t}\n\n\t}\n\n\tsetHoverEvent( e ) {\n\n\t\tif ( e.pointerType === 'mouse' || e.type === 'wheel' ) {\n\n\t\t\tthis.getAdjustedPointer( e, this.hoverPosition );\n\t\t\tthis.hoverSet = true;\n\n\t\t}\n\n\t}\n\n\tgetLatestPoint( target ) {\n\n\t\tif ( this.pointerType !== null ) {\n\n\t\t\tthis.getCenterPoint( target );\n\t\t\treturn target;\n\n\t\t} else if ( this.hoverSet ) {\n\n\t\t\ttarget.copy( this.hoverPosition );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// get the pointer position in the coordinate system of the target element\n\tgetAdjustedPointer( e, target ) {\n\n\t\tconst domRef = this.domElement ? this.domElement : e.target;\n\t\tconst rect = domRef.getBoundingClientRect();\n\t\tconst x = e.clientX - rect.left;\n\t\tconst y = e.clientY - rect.top;\n\t\ttarget.set( x, y );\n\n\t}\n\n\taddPointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tconst position = new Vector2();\n\t\tthis.getAdjustedPointer( e, position );\n\t\tthis.pointerOrder.push( id );\n\t\tthis.pointerPositions[ id ] = position;\n\t\tthis.previousPositions[ id ] = position.clone();\n\t\tthis.startPositions[ id ] = position.clone();\n\n\t\tif ( this.getPointerCount() === 1 ) {\n\n\t\t\tthis.pointerType = e.pointerType;\n\t\t\tthis.buttons = e.buttons;\n\n\t\t}\n\n\t}\n\n\tupdatePointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tif ( ! ( id in this.pointerPositions ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tthis.getAdjustedPointer( e, this.pointerPositions[ id ] );\n\t\treturn true;\n\n\t}\n\n\tdeletePointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tconst pointerOrder = this.pointerOrder;\n\t\tpointerOrder.splice( pointerOrder.indexOf( id ), 1 );\n\t\tdelete this.pointerPositions[ id ];\n\t\tdelete this.previousPositions[ id ];\n\t\tdelete this.startPositions[ id ];\n\n\t\tif ( this.getPointerCount() === 0 ) {\n\n\t\t\tthis.buttons = 0;\n\t\t\tthis.pointerType = null;\n\n\t\t}\n\n\t}\n\n\tgetPointerCount() {\n\n\t\treturn this.pointerOrder.length;\n\n\t}\n\n\tgetCenterPoint( target, pointerPositions = this.pointerPositions ) {\n\n\t\tconst pointerOrder = this.pointerOrder;\n\t\tif ( this.getPointerCount() === 1 || this.getPointerType() === 'mouse' ) {\n\n\t\t\tconst id = pointerOrder[ 0 ];\n\t\t\ttarget.copy( pointerPositions[ id ] );\n\t\t\treturn target;\n\n\t\t} else if ( this.getPointerCount() === 2 ) {\n\n\t\t\tconst id0 = this.pointerOrder[ 0 ];\n\t\t\tconst id1 = this.pointerOrder[ 1 ];\n\n\t\t\tconst p0 = pointerPositions[ id0 ];\n\t\t\tconst p1 = pointerPositions[ id1 ];\n\n\t\t\ttarget.addVectors( p0, p1 ).multiplyScalar( 0.5 );\n\t\t\treturn target;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetPreviousCenterPoint( target ) {\n\n\t\treturn this.getCenterPoint( target, this.previousPositions );\n\n\t}\n\n\tgetStartCenterPoint( target ) {\n\n\t\treturn this.getCenterPoint( target, this.startPositions );\n\n\t}\n\n\tgetMoveDistance() {\n\n\t\tthis.getCenterPoint( _vec );\n\t\tthis.getPreviousCenterPoint( _vec2 );\n\n\t\treturn _vec.sub( _vec2 ).length();\n\n\t}\n\n\tgetTouchPointerDistance( pointerPositions = this.pointerPositions ) {\n\n\t\tif ( this.getPointerCount() <= 1 || this.getPointerType() === 'mouse' ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst { pointerOrder } = this;\n\t\tconst id0 = pointerOrder[ 0 ];\n\t\tconst id1 = pointerOrder[ 1 ];\n\n\t\tconst p0 = pointerPositions[ id0 ];\n\t\tconst p1 = pointerPositions[ id1 ];\n\n\t\treturn p0.distanceTo( p1 );\n\n\t}\n\n\tgetPreviousTouchPointerDistance() {\n\n\t\treturn this.getTouchPointerDistance( this.previousPositions );\n\n\t}\n\n\tgetStartTouchPointerDistance() {\n\n\t\treturn this.getTouchPointerDistance( this.startPositions );\n\n\t}\n\n\tgetPointerType() {\n\n\t\treturn this.pointerType;\n\n\t}\n\n\tisPointerTouch() {\n\n\t\treturn this.getPointerType() === 'touch';\n\n\t}\n\n\tgetPointerButtons() {\n\n\t\treturn this.buttons;\n\n\t}\n\n\tisLeftClicked() {\n\n\t\treturn Boolean( this.buttons & 1 );\n\n\t}\n\n\tisRightClicked() {\n\n\t\treturn Boolean( this.buttons & 2 );\n\n\t}\n\n}\n","import { Matrix4, Ray, Vector3 } from 'three';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// helper function for constructing a matrix for rotating around a point\nexport function makeRotateAroundPoint( point, quat, target ) {\n\n\ttarget.makeTranslation( - point.x, - point.y, - point.z );\n\n\t_matrix.makeRotationFromQuaternion( quat );\n\ttarget.premultiply( _matrix );\n\n\t_matrix.makeTranslation( point.x, point.y, point.z );\n\ttarget.premultiply( _matrix );\n\n\treturn target;\n\n}\n\n// get the three.js pointer coords from an event\nexport function mouseToCoords( clientX, clientY, element, target ) {\n\n\ttarget.x = ( ( clientX - element.offsetLeft ) / element.clientWidth ) * 2 - 1;\n\ttarget.y = - ( ( clientY - element.offsetTop ) / element.clientHeight ) * 2 + 1;\n\n\tif ( target.isVector3 ) {\n\n\t\ttarget.z = 0;\n\n\t}\n\n}\n\n// find the closest ray on the horizon when the ray passes above the sphere\nexport function closestRaySpherePointFromRotation( ray, radius, target ) {\n\n\tconst hypotenuse = ray.origin.length();\n\n\t// angle inside the sphere\n\tconst theta = Math.acos( radius / hypotenuse );\n\n\t// the direction to the camera\n\ttarget\n\t\t.copy( ray.origin )\n\t\t.multiplyScalar( - 1 )\n\t\t.normalize();\n\n\t// get the normal of the plane the ray and origin lie in\n\tconst rotationVec = _vec\n\t\t.crossVectors( target, ray.direction )\n\t\t.normalize();\n\n\t// rotate the camera direction by angle and scale it to the surface\n\ttarget\n\t\t.multiplyScalar( - 1 )\n\t\t.applyAxisAngle( rotationVec, - theta )\n\t\t.normalize()\n\t\t.multiplyScalar( radius );\n\n}\n\n\n// custom version of set raycaster from camera that relies on the underlying matrices\n// so the ray origin is position at the camera near clip.\nexport function setRaycasterFromCamera( raycaster, coords, camera ) {\n\n\tconst ray = raycaster instanceof Ray ? raycaster : raycaster.ray;\n\tconst { origin, direction } = ray;\n\n\t// get the origin and direction of the frustum ray\n\torigin\n\t\t.set( coords.x, coords.y, - 1 )\n\t\t.unproject( camera );\n\n\tdirection\n\t\t.set( coords.x, coords.y, 1 )\n\t\t.unproject( camera )\n\t\t.sub( origin );\n\n\tif ( ! raycaster.isRay ) {\n\n\t\t// compute the far value based on the distance from point on the near\n\t\t// plane and point on the far plane. Then normalize the direction.\n\t\traycaster.near = 0;\n\t\traycaster.far = direction.length();\n\t\traycaster.camera = camera;\n\n\t}\n\n\t// normalize the ray direction\n\tdirection.normalize();\n\n}\n","import {\n\tMatrix4,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tRaycaster,\n\tPlane,\n\tEventDispatcher,\n\tMathUtils,\n\tClock,\n\tRay,\n} from 'three';\nimport { PivotPointMesh } from './PivotPointMesh.js';\nimport { PointerTracker } from './PointerTracker.js';\nimport { mouseToCoords, makeRotateAroundPoint, setRaycasterFromCamera } from './utils.js';\n\nexport const NONE = 0;\nexport const DRAG = 1;\nexport const ROTATE = 2;\nexport const ZOOM = 3;\nexport const WAITING = 4;\n\nconst DRAG_PLANE_THRESHOLD = 0.05;\nconst DRAG_UP_THRESHOLD = 0.025;\n\nconst _rotMatrix = /* @__PURE__ */ new Matrix4();\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _delta = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _right = /* @__PURE__ */ new Vector3();\nconst _targetRight = /* @__PURE__ */ new Vector3();\nconst _rotationAxis = /* @__PURE__ */ new Vector3();\nconst _quaternion = /* @__PURE__ */ new Quaternion();\nconst _plane = /* @__PURE__ */ new Plane();\nconst _localUp = /* @__PURE__ */ new Vector3();\nconst _mouseBefore = /* @__PURE__ */ new Vector3();\nconst _mouseAfter = /* @__PURE__ */ new Vector3();\nconst _identityQuat = /* @__PURE__ */ new Quaternion();\nconst _ray = /* @__PURE__ */ new Ray();\n\nconst _zoomPointPointer = /* @__PURE__ */ new Vector2();\nconst _pointer = /* @__PURE__ */ new Vector2();\nconst _prevPointer = /* @__PURE__ */ new Vector2();\nconst _deltaPointer = /* @__PURE__ */ new Vector2();\nconst _centerPoint = /* @__PURE__ */ new Vector2();\nconst _startCenterPoint = /* @__PURE__ */ new Vector2();\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nexport class EnvironmentControls extends EventDispatcher {\n\n\tget enabled() {\n\n\t\treturn this._enabled;\n\n\t}\n\n\tset enabled( v ) {\n\n\t\tif ( v !== this.enabled ) {\n\n\t\t\tthis._enabled = v;\n\t\t\tthis.resetState();\n\t\t\tthis.pointerTracker.reset();\n\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\t\t\tthis.rotationInertia.set( 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconstructor( scene = null, camera = null, domElement = null, tilesRenderer = null ) {\n\n\t\tsuper();\n\n\t\tthis.isEnvironmentControls = true;\n\n\t\tthis.domElement = null;\n\t\tthis.camera = null;\n\t\tthis.scene = null;\n\t\tthis.tilesRenderer = null;\n\n\t\t// settings\n\t\tthis._enabled = true;\n\t\tthis.cameraRadius = 5;\n\t\tthis.rotationSpeed = 1;\n\t\tthis.minAltitude = 0;\n\t\tthis.maxAltitude = 0.45 * Math.PI;\n\t\tthis.minDistance = 10;\n\t\tthis.maxDistance = Infinity;\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\t\tthis.zoomSpeed = 1;\n\t\tthis.adjustHeight = true;\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.15;\n\n\t\tthis.fallbackPlane = new Plane( new Vector3( 0, 1, 0 ), 0 );\n\t\tthis.useFallbackPlane = true;\n\n\t\t// settings for GlobeControls\n\t\tthis.scaleZoomOrientationAtEdges = false;\n\t\tthis.autoAdjustCameraRotation = true;\n\n\t\t// internal state\n\t\tthis.state = NONE;\n\t\tthis.pointerTracker = new PointerTracker();\n\t\tthis.needsUpdate = false;\n\t\tthis.actionHeightOffset = 0;\n\n\t\tthis.pivotPoint = new Vector3();\n\n\t\t// used for zoom\n\t\tthis.zoomDirectionSet = false;\n\t\tthis.zoomPointSet = false;\n\t\tthis.zoomDirection = new Vector3();\n\t\tthis.zoomPoint = new Vector3();\n\t\tthis.zoomDelta = 0;\n\n\t\t// fields used for inertia\n\t\tthis.rotationInertiaPivot = new Vector3();\n\t\tthis.rotationInertia = new Vector2();\n\t\tthis.dragInertia = new Vector3();\n\t\tthis.inertiaTargetDistance = Infinity; \t\t// track the distance from the camera that we want to use to calculate the inertia end threshold\n\t\tthis.inertiaStableFrames = 0; \t\t\t\t// the number of frames that the camera has not moved while the user is interacting\n\n\t\t// circular pivot mesh\n\t\tthis.pivotMesh = new PivotPointMesh();\n\t\tthis.pivotMesh.raycast = () => {};\n\n\t\tthis.pivotMesh.scale.setScalar( 0.25 );\n\n\t\t// raycaster\n\t\tthis.raycaster = new Raycaster();\n\t\tthis.raycaster.firstHitOnly = true;\n\n\t\tthis.up = new Vector3( 0, 1, 0 );\n\t\tthis.clock = new Clock();\n\n\t\tthis._detachCallback = null;\n\t\tthis._upInitialized = false;\n\t\tthis._lastUsedState = NONE;\n\t\tthis._zoomPointWasSet = false;\n\n\t\t// always update the zoom target point in case the tiles are changing\n\t\tthis._tilesOnChangeCallback = () => this.zoomPointSet = false;\n\n\t\t// init\n\t\tif ( domElement ) this.attach( domElement );\n\t\tif ( camera ) this.setCamera( camera );\n\t\tif ( scene ) this.setScene( scene );\n\t\tif ( tilesRenderer ) this.setTilesRenderer( tilesRenderer );\n\n\t}\n\n\tsetScene( scene ) {\n\n\t\tthis.scene = scene;\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tthis.camera = camera;\n\t\tthis._upInitialized = false;\n\t\tthis.zoomDirectionSet = false;\n\t\tthis.zoomPointSet = false;\n\t\tthis.needsUpdate = true;\n\t\tthis.raycaster.camera = camera;\n\t\tthis.resetState();\n\n\t}\n\n\tsetTilesRenderer( tilesRenderer ) {\n\n\t\tconsole.warn( 'EnvironmentControls: \"setTilesRenderer\" has been deprecated. Use \"setScene\" and \"setEllipsoid\", instead.' );\n\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tif ( this.tilesRenderer !== null ) {\n\n\t\t\tthis.setScene( this.tilesRenderer.group );\n\n\t\t}\n\n\t}\n\n\tattach( domElement ) {\n\n\t\tif ( this.domElement ) {\n\n\t\t\tthrow new Error( 'EnvironmentControls: Controls already attached to element' );\n\n\t\t}\n\n\t\t// set the touch action to none so the browser does not\n\t\t// drag the page to refresh or scroll\n\t\tthis.domElement = domElement;\n\t\tthis.pointerTracker.domElement = domElement;\n\t\tdomElement.style.touchAction = 'none';\n\n\t\tconst contextMenuCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t};\n\n\t\tconst pointerdownCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst {\n\t\t\t\tcamera,\n\t\t\t\traycaster,\n\t\t\t\tdomElement,\n\t\t\t\tup,\n\t\t\t\tpivotMesh,\n\t\t\t\tpointerTracker,\n\t\t\t\tscene,\n\t\t\t\tpivotPoint,\n\t\t\t\tenabled,\n\t\t\t} = this;\n\n\t\t\t// init the pointer\n\t\t\tpointerTracker.addPointer( e );\n\t\t\tthis.needsUpdate = true;\n\n\t\t\t// handle cases where we need to capture the pointer or\n\t\t\t// reset state when we have too many pointers\n\t\t\tif ( pointerTracker.isPointerTouch() ) {\n\n\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t\tif ( pointerTracker.getPointerCount() === 0 ) {\n\n\t\t\t\t\t// TODO: is it correct to only capture a single pointer? Or do we need to do it for\n\t\t\t\t\t// every unique pointer id?\n\t\t\t\t\tdomElement.setPointerCapture( e.pointerId );\n\n\t\t\t\t} else if ( pointerTracker.getPointerCount() > 2 ) {\n\n\t\t\t\t\tthis.resetState();\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// the \"pointer\" for zooming and rotating should be based on the center point\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _pointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// prevent the drag distance from getting too severe by limiting the drag point\n\t\t\t// to a reasonable angle and reasonable distance with the drag plane\n\t\t\tconst dot = Math.abs( raycaster.ray.direction.dot( up ) );\n\t\t\tif ( dot < DRAG_PLANE_THRESHOLD || dot < DRAG_UP_THRESHOLD ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// find the hit point\n\t\t\tconst hit = this._raycast( raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\t// if two fingers, right click, or shift click are being used then we trigger\n\t\t\t\t// a rotation action to begin\n\t\t\t\tif (\n\t\t\t\t\tpointerTracker.getPointerCount() === 2 ||\n\t\t\t\t\tpointerTracker.isRightClicked() ||\n\t\t\t\t\tpointerTracker.isLeftClicked() && e.shiftKey\n\t\t\t\t) {\n\n\t\t\t\t\tthis.setState( pointerTracker.isPointerTouch() ? WAITING : ROTATE );\n\n\t\t\t\t\tpivotPoint.copy( hit.point );\n\t\t\t\t\tpivotMesh.position.copy( hit.point );\n\t\t\t\t\tpivotMesh.visible = pointerTracker.isPointerTouch() ? false : enabled;\n\t\t\t\t\tpivotMesh.updateMatrixWorld();\n\t\t\t\t\tscene.add( pivotMesh );\n\n\t\t\t\t} else if ( pointerTracker.isLeftClicked() ) {\n\n\t\t\t\t\t// if the clicked point is coming from below the plane then don't perform the drag\n\t\t\t\t\tthis.setState( DRAG );\n\t\t\t\t\tpivotPoint.copy( hit.point );\n\n\t\t\t\t\tpivotMesh.position.copy( hit.point );\n\t\t\t\t\tpivotMesh.updateMatrixWorld();\n\t\t\t\t\tscene.add( pivotMesh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tlet _pointerMoveQueued = false;\n\t\tconst pointermoveCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tconst { pointerTracker } = this;\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst {\n\t\t\t\tpivotMesh,\n\t\t\t\tenabled,\n\t\t\t} = this;\n\n\t\t\t// whenever the pointer moves we need to re-derive the zoom direction and point\n\t\t\tthis.zoomDirectionSet = false;\n\t\t\tthis.zoomPointSet = false;\n\n\t\t\tif ( this.state !== NONE ) {\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tpointerTracker.setHoverEvent( e );\n\t\t\tif ( ! pointerTracker.updatePointer( e ) ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( pointerTracker.isPointerTouch() && pointerTracker.getPointerCount() === 2 ) {\n\n\t\t\t\t// We queue this event to ensure that all pointers have been updated\n\t\t\t\tif ( ! _pointerMoveQueued ) {\n\n\t\t\t\t\t_pointerMoveQueued = true;\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\t_pointerMoveQueued = false;\n\n\t\t\t\t\t\t// adjust the pointer position to be the center point\n\t\t\t\t\t\tpointerTracker.getCenterPoint( _centerPoint );\n\n\t\t\t\t\t\t// detect zoom transition\n\t\t\t\t\t\tconst startDist = pointerTracker.getStartTouchPointerDistance();\n\t\t\t\t\t\tconst pointerDist = pointerTracker.getTouchPointerDistance();\n\t\t\t\t\t\tconst separateDelta = pointerDist - startDist;\n\t\t\t\t\t\tif ( this.state === NONE || this.state === WAITING ) {\n\n\t\t\t\t\t\t\t// check which direction was moved in first - if the pointers are pinching then\n\t\t\t\t\t\t\t// it's a zoom. But if they move in parallel it's a rotation\n\t\t\t\t\t\t\tpointerTracker.getCenterPoint( _centerPoint );\n\t\t\t\t\t\t\tpointerTracker.getStartCenterPoint( _startCenterPoint );\n\n\t\t\t\t\t\t\t// adjust the drag requirement by the dpr\n\t\t\t\t\t\t\tconst dragThreshold = 2.0 * window.devicePixelRatio;\n\t\t\t\t\t\t\tconst parallelDelta = _centerPoint.distanceTo( _startCenterPoint );\n\t\t\t\t\t\t\tif ( Math.abs( separateDelta ) > dragThreshold || parallelDelta > dragThreshold ) {\n\n\t\t\t\t\t\t\t\tif ( Math.abs( separateDelta ) > parallelDelta ) {\n\n\t\t\t\t\t\t\t\t\tthis.setState( ZOOM );\n\t\t\t\t\t\t\t\t\tthis.zoomDirectionSet = false;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tthis.setState( ROTATE );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.state === ZOOM ) {\n\n\t\t\t\t\t\t\tconst previousDist = pointerTracker.getPreviousTouchPointerDistance();\n\t\t\t\t\t\t\tthis.zoomDelta += pointerDist - previousDist;\n\t\t\t\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t\t\t\t} else if ( this.state === ROTATE ) {\n\n\t\t\t\t\t\t\tpivotMesh.visible = enabled;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: we have the potential to fire change multiple times per frame - should we debounce?\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t};\n\n\t\tconst pointerupCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tconst { pointerTracker } = this;\n\t\t\tif ( ! this.enabled || pointerTracker.getPointerCount() === 0 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tpointerTracker.deletePointer( e );\n\n\t\t\tif (\n\t\t\t\tpointerTracker.getPointerType() === 'touch' &&\n\t\t\t\tpointerTracker.getPointerCount() === 0\n\t\t\t) {\n\n\t\t\t\tdomElement.releasePointerCapture( e.pointerId );\n\n\t\t\t}\n\n\t\t\tthis.resetState();\n\t\t\tthis.needsUpdate = true;\n\n\t\t};\n\n\t\tconst wheelCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst { pointerTracker } = this;\n\t\t\tpointerTracker.setHoverEvent( e );\n\t\t\tpointerTracker.updatePointer( e );\n\n\t\t\t// TODO: do we need events here?\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tlet delta;\n\t\t\tswitch ( e.deltaMode ) {\n\n\t\t\t\tcase 2: // Pages\n\t\t\t\t\tdelta = e.deltaY * 800;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: // Lines\n\t\t\t\t\tdelta = e.deltaY * 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0: // Pixels\n\t\t\t\t\tdelta = e.deltaY;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// use LOG to scale the scroll delta and hopefully normalize them across platforms\n\t\t\tconst deltaSign = Math.sign( delta );\n\t\t\tconst normalizedDelta = Math.abs( delta );\n\t\t\tthis.zoomDelta -= 0.25 * deltaSign * normalizedDelta;\n\t\t\tthis.needsUpdate = true;\n\n\t\t\tthis._lastUsedState = ZOOM;\n\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t};\n\n\t\tconst pointerleaveCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.resetState();\n\n\t\t};\n\n\t\tdomElement.addEventListener( 'contextmenu', contextMenuCallback );\n\t\tdomElement.addEventListener( 'pointerdown', pointerdownCallback );\n\t\tdomElement.addEventListener( 'wheel', wheelCallback, { passive: false } );\n\n\t\t// Register movement events on the root element so dragging does not break when dragging over other elements.\n\t\t// Use \"getRootNode\" to enable offscreenCanvas usage.\n\t\t// \"pointerleave\" event fires when leaving the window.\n\t\tconst document = domElement.getRootNode();\n\t\tdocument.addEventListener( 'pointermove', pointermoveCallback );\n\t\tdocument.addEventListener( 'pointerup', pointerupCallback );\n\t\tdocument.addEventListener( 'pointerleave', pointerleaveCallback );\n\n\t\tthis._detachCallback = () => {\n\n\t\t\tdomElement.removeEventListener( 'contextmenu', contextMenuCallback );\n\t\t\tdomElement.removeEventListener( 'pointerdown', pointerdownCallback );\n\t\t\tdomElement.removeEventListener( 'wheel', wheelCallback );\n\n\t\t\tdocument.removeEventListener( 'pointermove', pointermoveCallback );\n\t\t\tdocument.removeEventListener( 'pointerup', pointerupCallback );\n\t\t\tdocument.removeEventListener( 'pointerleave', pointerleaveCallback );\n\n\t\t};\n\n\t}\n\n\tdetach() {\n\n\t\tthis.domElement = null;\n\n\t\tif ( this._detachCallback ) {\n\n\t\t\tthis._detachCallback();\n\t\t\tthis._detachCallback = null;\n\t\t\tthis.pointerTracker.reset();\n\n\t\t}\n\n\t}\n\n\t// override-able functions for retrieving the up direction at a point\n\tgetUpDirection( point, target ) {\n\n\t\ttarget.copy( this.up );\n\n\t}\n\n\tgetCameraUpDirection( target ) {\n\n\t\tthis.getUpDirection( this.camera.position, target );\n\n\t}\n\n\t// returns the active / last used pivot point for the scene\n\tgetPivotPoint( target ) {\n\n\t\tlet result = null;\n\n\t\t// get the last interacted point as the focus\n\t\tif ( this._lastUsedState === ZOOM ) {\n\n\t\t\tif ( this._zoomPointWasSet ) {\n\n\t\t\t\tresult = target.copy( this.zoomPoint );\n\n\t\t\t}\n\n\t\t} else if ( this._lastUsedState === ROTATE || this._lastUsedState === DRAG ) {\n\n\t\t\tresult = target.copy( this.pivotPoint );\n\n\t\t}\n\n\t\t// If the last used point is outside the camera view then skip it\n\t\tconst { camera, raycaster } = this;\n\t\tif ( result !== null ) {\n\n\t\t\t_vec.copy( result ).project( camera );\n\t\t\tif ( _vec.x < - 1 || _vec.x > 1 || _vec.y < - 1 || _vec.y > 1 ) {\n\n\t\t\t\tresult = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// default to the raycast hit if we have not result or the hit is closer to the camera\n\t\t// set a ray in the local ellipsoid frame\n\t\tsetRaycasterFromCamera( raycaster, { x: 0, y: 0 }, camera );\n\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\tif ( result === null || hit.distance < result.distanceTo( raycaster.ray.origin ) ) {\n\n\t\t\t\tresult = target.copy( hit.point );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tresetState() {\n\n\t\tif ( this.state !== NONE ) {\n\n\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tthis.state = NONE;\n\t\tthis.pivotMesh.removeFromParent();\n\t\tthis.pivotMesh.visible = this.enabled;\n\t\tthis.actionHeightOffset = 0;\n\t\tthis.pointerTracker.reset();\n\n\t}\n\n\tsetState( state = this.state, fireEvent = true ) {\n\n\t\tif ( this.state === state ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.state === NONE && fireEvent ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t}\n\n\t\tthis.pivotMesh.visible = this.enabled;\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.inertiaStableFrames = 0;\n\t\tthis.state = state;\n\n\t\tif ( state !== NONE && state !== WAITING ) {\n\n\t\t\tthis._lastUsedState = state;\n\n\t\t}\n\n\t}\n\n\tupdate( deltaTime = Math.min( this.clock.getDelta(), 64 / 1000 ) ) {\n\n\t\tif ( ! this.enabled || ! this.camera || deltaTime === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tpivotPoint,\n\t\t\tup,\n\t\t\tstate,\n\t\t\tadjustHeight,\n\t\t\tautoAdjustCameraRotation,\n\t\t} = this;\n\n\t\tcamera.updateMatrixWorld();\n\n\t\t// set the \"up\" vector immediately so it's available in the following functions\n\t\tthis.getCameraUpDirection( _localUp );\n\t\tif ( ! this._upInitialized ) {\n\n\t\t\tthis._upInitialized = true;\n\t\t\tthis.up.copy( _localUp );\n\n\t\t}\n\n\t\t// we need to update the zoom point whenever we update in case the scene is animating or changing\n\t\tthis.zoomPointSet = false;\n\n\t\t// update the actions\n\t\tconst inertiaNeedsUpdate = this._inertiaNeedsUpdate();\n\t\tconst adjustCameraRotation = this.needsUpdate || inertiaNeedsUpdate;\n\t\tif ( this.needsUpdate || inertiaNeedsUpdate ) {\n\n\t\t\tconst zoomDelta = this.zoomDelta;\n\n\t\t\tthis._updateZoom();\n\t\t\tthis._updatePosition( deltaTime );\n\t\t\tthis._updateRotation( deltaTime );\n\n\t\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\t\tthis.inertiaTargetDistance = _vec.copy( pivotPoint ).sub( camera.position ).dot( _forward );\n\n\t\t\t} else if ( state === NONE ) {\n\n\t\t\t\tthis._updateInertia( deltaTime );\n\n\t\t\t}\n\n\t\t\tif ( state !== NONE || zoomDelta !== 0 || inertiaNeedsUpdate ) {\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t\t// update the up direction based on where the camera moved to\n\t\t// if using an orthographic camera then rotate around drag pivot\n\t\t// reuse the \"hit\" information since it can be slow to perform multiple hits\n\t\tconst hit = camera.isOrthographicCamera ? null : adjustHeight && this._getPointBelowCamera() || null;\n\t\tthis.getCameraUpDirection( _localUp );\n\t\tthis._setFrame( _localUp );\n\n\t\t// when dragging the camera and drag point may be moved\n\t\t// to accommodate terrain so we try to move it back down\n\t\t// to the original point.\n\t\tif ( ( this.state === DRAG || this.state === ROTATE ) && this.actionHeightOffset !== 0 ) {\n\n\t\t\tconst { actionHeightOffset } = this;\n\t\t\tcamera.position.addScaledVector( up, - actionHeightOffset );\n\t\t\tpivotPoint.addScaledVector( up, - actionHeightOffset );\n\n\t\t\t// adjust the height\n\t\t\tif ( hit ) {\n\n\t\t\t\thit.distance -= actionHeightOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.actionHeightOffset = 0;\n\n\t\tif ( hit ) {\n\n\t\t\tconst dist = hit.distance;\n\t\t\tif ( dist < cameraRadius ) {\n\n\t\t\t\tconst delta = cameraRadius - dist;\n\t\t\t\tcamera.position.addScaledVector( up, delta );\n\t\t\t\tpivotPoint.addScaledVector( up, delta );\n\t\t\t\tthis.actionHeightOffset = delta;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.pointerTracker.updateFrame();\n\n\t\tif ( adjustCameraRotation && autoAdjustCameraRotation ) {\n\n\t\t\tthis.getCameraUpDirection( _localUp );\n\t\t\tthis._alignCameraUp( _localUp, 1 );\n\n\t\t\tthis.getCameraUpDirection( _localUp );\n\t\t\tthis._clampRotation( _localUp );\n\n\n\t\t}\n\n\t}\n\n\t// updates the camera to position it based on the constraints of the controls\n\tadjustCamera( camera ) {\n\n\t\tconst { adjustHeight, cameraRadius } = this;\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t// adjust the camera height\n\t\t\tthis.getUpDirection( camera.position, _localUp );\n\t\t\tconst hit = adjustHeight && this._getPointBelowCamera( camera.position, _localUp ) || null;\n\t\t\tif ( hit ) {\n\n\t\t\t\tconst dist = hit.distance;\n\t\t\t\tif ( dist < cameraRadius ) {\n\n\t\t\t\t\tcamera.position.addScaledVector( _localUp, cameraRadius - dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.detach();\n\n\t}\n\n\t// private\n\t_updateInertia( deltaTime ) {\n\n\t\t// update the damping of momentum variables\n\t\tconst {\n\t\t\trotationInertia,\n\t\t\tpivotPoint,\n\t\t\tdragInertia,\n\t\t\tenableDamping,\n\t\t\tdampingFactor,\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tminDistance,\n\t\t\tinertiaTargetDistance,\n\t\t} = this;\n\n\t\tif ( ! this.enableDamping || this.inertiaStableFrames > 1 ) {\n\n\t\t\tdragInertia.set( 0, 0, 0 );\n\t\t\trotationInertia.set( 0, 0, 0 );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Based on Freya Holmer's frame-rate independent lerp function\n\t\tconst factor = Math.pow( 2, - deltaTime / dampingFactor );\n\t\tconst stableDistance = Math.max( camera.near, cameraRadius, minDistance, inertiaTargetDistance );\n\t\tconst resolution = 2 * 1e3;\n\t\tconst pixelWidth = 2 / resolution;\n\t\tconst pixelThreshold = 0.25 * pixelWidth;\n\n\t\t// scale the residual rotation motion\n\t\tif ( rotationInertia.lengthSq() > 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _delta.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _delta );\n\t\t\t_delta.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// get implied angle\n\t\t\t_vec.sub( pivotPoint ).normalize();\n\t\t\t_delta.sub( pivotPoint ).normalize();\n\n\t\t\t// calculate the rotation threshold\n\t\t\tconst threshold = _vec.angleTo( _delta ) / deltaTime;\n\t\t\trotationInertia.multiplyScalar( factor );\n\t\t\tif ( rotationInertia.lengthSq() < threshold ** 2 || ! enableDamping ) {\n\n\t\t\t\trotationInertia.set( 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scale the residual translation motion\n\t\tif ( dragInertia.lengthSq() > 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _delta.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _delta );\n\t\t\t_delta.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// calculate movement threshold\n\t\t\tconst threshold = _vec.distanceTo( _delta ) / deltaTime;\n\t\t\tdragInertia.multiplyScalar( factor );\n\t\t\tif ( dragInertia.lengthSq() < threshold ** 2 || ! enableDamping ) {\n\n\t\t\t\tdragInertia.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply the inertia changes\n\t\tif ( rotationInertia.lengthSq() > 0 ) {\n\n\t\t\tthis._applyRotation( rotationInertia.x * deltaTime, rotationInertia.y * deltaTime, pivotPoint );\n\n\t\t}\n\n\t\tif ( dragInertia.lengthSq() > 0 ) {\n\n\t\t\tcamera.position.addScaledVector( dragInertia, deltaTime );\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\t_inertiaNeedsUpdate() {\n\n\t\tconst { rotationInertia, dragInertia } = this;\n\t\treturn rotationInertia.lengthSq() !== 0 || dragInertia.lengthSq() !== 0;\n\n\t}\n\n\t_updateZoom() {\n\n\t\tconst {\n\t\t\tzoomPoint,\n\t\t\tzoomDirection,\n\t\t\tcamera,\n\t\t\tminDistance,\n\t\t\tmaxDistance,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tminZoom,\n\t\t\tmaxZoom,\n\t\t\tzoomSpeed,\n\t\t\tstate,\n\t\t} = this;\n\n\t\tlet scale = this.zoomDelta;\n\t\tthis.zoomDelta = 0;\n\n\t\t// get the latest hover / touch point\n\t\tif ( ! pointerTracker.getLatestPoint( _pointer ) || ( scale === 0 && state !== ZOOM ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// reset momentum\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\t// update the zoom direction\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// zoom straight into the globe if we haven't hit anything\n\t\t\tconst zoomIntoPoint = this.zoomPointSet || this._updateZoomPoint();\n\n\t\t\t// get the mouse position before zoom\n\t\t\t_mouseBefore.unproject( camera );\n\n\t\t\t// zoom the camera\n\t\t\tconst normalizedDelta = Math.pow( 0.95, Math.abs( scale * 0.05 ) );\n\t\t\tlet scaleFactor = scale > 0 ? 1 / Math.abs( normalizedDelta ) : normalizedDelta;\n\t\t\tscaleFactor *= zoomSpeed;\n\n\t\t\tif ( scaleFactor > 1 ) {\n\n\t\t\t\tif ( maxZoom < camera.zoom * scaleFactor ) {\n\n\t\t\t\t\tscaleFactor = 1;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( minZoom > camera.zoom * scaleFactor ) {\n\n\t\t\t\t\tscaleFactor = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcamera.zoom *= scaleFactor;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t// adjust the surface point to be in the same position if the globe is hovered over\n\t\t\tif ( zoomIntoPoint ) {\n\n\t\t\t\t// get the mouse position after zoom\n\t\t\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _mouseAfter );\n\t\t\t\t_mouseAfter.unproject( camera );\n\n\t\t\t\t// shift the camera on the near plane so the mouse is in the same spot\n\t\t\t\tcamera.position.sub( _mouseAfter ).add( _mouseBefore );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// initialize the zoom direction\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// track the zoom direction we're going to use\n\t\t\tconst finalZoomDirection = _vec.copy( zoomDirection );\n\n\t\t\tif ( this.zoomPointSet || this._updateZoomPoint() ) {\n\n\t\t\t\tconst dist = zoomPoint.distanceTo( camera.position );\n\n\t\t\t\t// scale the distance based on how far there is to move\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\tconst remainingDistance = Math.min( 0, dist - maxDistance );\n\t\t\t\t\tscale = scale * dist * zoomSpeed * 0.0025;\n\t\t\t\t\tscale = Math.max( scale, remainingDistance );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst remainingDistance = Math.max( 0, dist - minDistance );\n\t\t\t\t\tscale = scale * Math.max( dist - minDistance, 0 ) * zoomSpeed * 0.0025;\n\t\t\t\t\tscale = Math.min( scale, remainingDistance );\n\n\t\t\t\t}\n\n\t\t\t\tcamera.position.addScaledVector( zoomDirection, scale );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t} else {\n\n\t\t\t\t// if we're zooming into nothing then use the distance from the ground to scale movement\n\t\t\t\tconst hit = this._getPointBelowCamera();\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tconst dist = hit.distance;\n\t\t\t\t\tfinalZoomDirection.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\t\t\tcamera.position.addScaledVector( finalZoomDirection, scale * dist * 0.01 );\n\t\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateZoomDirection() {\n\n\t\tif ( this.zoomDirectionSet ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { domElement, raycaster, camera, zoomDirection, pointerTracker } = this;\n\t\tpointerTracker.getLatestPoint( _pointer );\n\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _mouseBefore );\n\t\tsetRaycasterFromCamera( raycaster, _mouseBefore, camera );\n\t\tzoomDirection.copy( raycaster.ray.direction ).normalize();\n\t\tthis.zoomDirectionSet = true;\n\n\t}\n\n\t// update the point being zoomed in to based on the zoom direction\n\t_updateZoomPoint() {\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tzoomDirectionSet,\n\t\t\tzoomDirection,\n\t\t\traycaster,\n\t\t\tzoomPoint,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t} = this;\n\n\t\tthis._zoomPointWasSet = false;\n\n\t\tif ( ! zoomDirectionSet ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// If using an orthographic camera we have to account for the mouse position when picking the point\n\t\tif ( camera.isOrthographicCamera && pointerTracker.getLatestPoint( _zoomPointPointer ) ) {\n\n\t\t\tmouseToCoords( _zoomPointPointer.x, _zoomPointPointer.y, domElement, _zoomPointPointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _zoomPointPointer, camera );\n\n\t\t} else {\n\n\t\t\traycaster.ray.origin.copy( camera.position );\n\t\t\traycaster.ray.direction.copy( zoomDirection );\n\t\t\traycaster.near = 0;\n\t\t\traycaster.far = Infinity;\n\n\t\t}\n\n\t\t// get the hit point\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\tzoomPoint.copy( hit.point );\n\t\t\tthis.zoomPointSet = true;\n\t\t\tthis._zoomPointWasSet = true;\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// returns the point below the camera\n\t_getPointBelowCamera( point = this.camera.position, up = this.up ) {\n\n\t\tconst { raycaster } = this;\n\t\traycaster.ray.direction.copy( up ).multiplyScalar( - 1 );\n\t\traycaster.ray.origin.copy( point ).addScaledVector( up, 1e5 );\n\t\traycaster.near = 0;\n\t\traycaster.far = Infinity;\n\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\thit.distance -= 1e5;\n\n\t\t}\n\n\t\treturn hit;\n\n\t}\n\n\t// update the drag action\n\t_updatePosition( deltaTime ) {\n\n\t\tconst {\n\t\t\traycaster,\n\t\t\tcamera,\n\t\t\tpivotPoint,\n\t\t\tup,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tstate,\n\t\t\tdragInertia,\n\t\t} = this;\n\n\t\tif ( state === DRAG ) {\n\n\t\t\t// get the pointer and plane\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _pointer );\n\n\t\t\t_plane.setFromNormalAndCoplanarPoint( up, pivotPoint );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// prevent the drag distance from getting too severe by limiting the drag point\n\t\t\t// to a reasonable angle with the drag plane\n\t\t\tif ( Math.abs( raycaster.ray.direction.dot( up ) ) < DRAG_PLANE_THRESHOLD ) {\n\n\t\t\t\t// rotate the pointer direction down to the correct angle for horizontal dragging\n\t\t\t\tconst angle = Math.acos( DRAG_PLANE_THRESHOLD );\n\n\t\t\t\t_rotationAxis\n\t\t\t\t\t.crossVectors( raycaster.ray.direction, up )\n\t\t\t\t\t.normalize();\n\n\t\t\t\traycaster.ray.direction\n\t\t\t\t\t.copy( up )\n\t\t\t\t\t.applyAxisAngle( _rotationAxis, angle )\n\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\t// TODO: dragging causes the camera to rise because we're getting \"pushed\" up by lower resolution tiles and\n\t\t\t// don't lower back down. We should maintain a target height above tiles where possible\n\t\t\t// prevent the drag from inverting\n\n\t\t\t// if we drag to a point that's near the edge of the earth then we want to prevent it\n\t\t\t// from wrapping around and causing unexpected rotations\n\t\t\tthis.getUpDirection( pivotPoint, _localUp );\n\t\t\tif ( Math.abs( raycaster.ray.direction.dot( _localUp ) ) < DRAG_UP_THRESHOLD ) {\n\n\t\t\t\tconst angle = Math.acos( DRAG_UP_THRESHOLD );\n\n\t\t\t\t_rotationAxis\n\t\t\t\t\t.crossVectors( raycaster.ray.direction, _localUp )\n\t\t\t\t\t.normalize();\n\n\t\t\t\traycaster.ray.direction\n\t\t\t\t\t.copy( _localUp )\n\t\t\t\t\t.applyAxisAngle( _rotationAxis, angle )\n\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\t// find the point on the plane that we should drag to\n\t\t\tif ( raycaster.ray.intersectPlane( _plane, _vec ) ) {\n\n\t\t\t\t_delta.subVectors( pivotPoint, _vec );\n\t\t\t\tcamera.position.add( _delta );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t// update the drag inertia\n\t\t\t\t_delta.multiplyScalar( 1 / deltaTime );\n\t\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdragInertia.copy( _delta );\n\t\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateRotation( deltaTime ) {\n\n\t\tconst {\n\t\t\tpivotPoint,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tstate,\n\t\t\trotationInertia,\n\t\t} = this;\n\n\t\tif ( state === ROTATE ) {\n\n\t\t\t// get the rotation motion and divide out the container height to normalize for element size\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tpointerTracker.getPreviousCenterPoint( _prevPointer );\n\t\t\t_deltaPointer.subVectors( _pointer, _prevPointer ).multiplyScalar( 2 * Math.PI / domElement.clientHeight );\n\n\t\t\tthis._applyRotation( _deltaPointer.x, _deltaPointer.y, pivotPoint );\n\n\t\t\t// update rotation inertia\n\t\t\t_deltaPointer.multiplyScalar( 1 / deltaTime );\n\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t} else {\n\n\t\t\t\trotationInertia.copy( _deltaPointer );\n\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_applyRotation( x, y, pivotPoint ) {\n\n\t\tif ( x === 0 && y === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tminAltitude,\n\t\t\tmaxAltitude,\n\t\t\trotationSpeed,\n\t\t} = this;\n\n\t\tconst azimuth = - x * rotationSpeed;\n\t\tlet altitude = y * rotationSpeed;\n\n\t\t// calculate current angles and clamp\n\t\t_forward.set( 0, 0, 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\t\tthis.getUpDirection( pivotPoint, _localUp );\n\n\t\t// get the signed angle relative to the top down view\n\t\tlet angle;\n\t\tif ( _localUp.dot( _forward ) > 1 - 1e-10 ) {\n\n\t\t\tangle = 0;\n\n\t\t} else {\n\n\t\t\t_vec.crossVectors( _localUp, _forward ).normalize();\n\n\t\t\tconst sign = Math.sign( _vec.dot( _right ) );\n\t\t\tangle = sign * _localUp.angleTo( _forward );\n\n\t\t}\n\n\t\t// clamp the rotation to be within the provided limits\n\t\t// clamp to 0 here, as well, so we don't \"pop\" to the the value range\n\t\tif ( altitude > 0 ) {\n\n\t\t\taltitude = Math.min( angle - minAltitude, altitude );\n\t\t\taltitude = Math.max( 0, altitude );\n\n\t\t} else {\n\n\t\t\taltitude = Math.max( angle - maxAltitude, altitude );\n\t\t\taltitude = Math.min( 0, altitude );\n\n\t\t}\n\n\t\t// rotate around the up axis\n\t\t_quaternion.setFromAxisAngle( _localUp, azimuth );\n\t\tmakeRotateAroundPoint( pivotPoint, _quaternion, _rotMatrix );\n\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\n\t\t// get a rotation axis for altitude and rotate\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\t\t_quaternion.setFromAxisAngle( _right, - altitude );\n\t\tmakeRotateAroundPoint( pivotPoint, _quaternion, _rotMatrix );\n\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\n\t\t// update the transform members\n\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t}\n\n\t// sets the \"up\" axis for the current surface of the tileset\n\t_setFrame( newUp ) {\n\n\t\tconst {\n\t\t\tup,\n\t\t\tcamera,\n\t\t\tzoomPoint,\n\t\t\tzoomDirectionSet,\n\t\t\tzoomPointSet,\n\t\t\tscaleZoomOrientationAtEdges,\n\t\t} = this;\n\n\t\t// If we're zooming then reorient around the zoom point\n\t\tif ( zoomDirectionSet && ( zoomPointSet || this._updateZoomPoint() ) ) {\n\n\t\t\t// get the amount needed to rotate\n\t\t\t_quaternion.setFromUnitVectors( up, newUp );\n\n\t\t\tif ( scaleZoomOrientationAtEdges ) {\n\n\t\t\t\tthis.getUpDirection( zoomPoint, _vec );\n\n\t\t\t\tlet amt = Math.max( _vec.dot( up ) - 0.6, 0 ) / 0.4;\n\t\t\t\tamt = MathUtils.mapLinear( amt, 0, 0.5, 0, 1 );\n\t\t\t\tamt = Math.min( amt, 1 );\n\n\t\t\t\t// scale the value if we're using an orthographic camera so\n\t\t\t\t// GlobeControls works correctly\n\t\t\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\t\t\tamt *= 0.1;\n\n\t\t\t\t}\n\n\t\t\t\t_quaternion.slerp( _identityQuat, 1.0 - amt );\n\n\t\t\t}\n\n\t\t\t// rotates the camera position around the point being zoomed in to\n\t\t\tmakeRotateAroundPoint( zoomPoint, _quaternion, _rotMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t\t// recompute the zoom direction after updating rotation to align with frame\n\t\t\tthis.zoomDirectionSet = false;\n\t\t\tthis._updateZoomDirection();\n\n\t\t}\n\n\t\tup.copy( newUp );\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t_raycast( raycaster ) {\n\n\t\tconst { scene, useFallbackPlane, fallbackPlane } = this;\n\t\tconst result = raycaster.intersectObject( scene )[ 0 ] || null;\n\t\tif ( result ) {\n\n\t\t\treturn result;\n\n\t\t} else if ( useFallbackPlane ) {\n\n\t\t\t// if we don't hit any geometry then try to intersect the fallback\n\t\t\t// plane so the camera can still be manipulated\n\t\t\tconst plane = fallbackPlane;\n\t\t\tif ( raycaster.ray.intersectPlane( plane, _vec ) ) {\n\n\t\t\t\tconst planeHit = {\n\t\t\t\t\tpoint: _vec.clone(),\n\t\t\t\t\tdistance: raycaster.ray.origin.distanceTo( _vec ),\n\t\t\t\t};\n\n\t\t\t\treturn planeHit;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// tilt the camera to align with the provided \"up\" value\n\t_alignCameraUp( up, alpha = 1 ) {\n\n\t\tconst { camera, state, pivotPoint, zoomPoint, zoomPointSet } = this;\n\n\t\t// get the transform vectors\n\t\tcamera.updateMatrixWorld();\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( - 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\n\t\t// compute an alpha based on the camera direction so we don't try to update the up direction\n\t\t// when the camera is facing that way.\n\t\tlet multiplier = MathUtils.mapLinear( 1 - Math.abs( _forward.dot( up ) ), 0, 0.2, 0, 1 );\n\t\tmultiplier = MathUtils.clamp( multiplier, 0, 1 );\n\t\talpha *= multiplier;\n\n\t\t// calculate the target direction for the right-facing vector\n\t\t_targetRight.crossVectors( up, _forward );\n\t\t_targetRight.lerp( _right, 1 - alpha ).normalize();\n\n\t\t// adjust the camera transformation\n\t\t_quaternion.setFromUnitVectors( _right, _targetRight );\n\t\tcamera.quaternion.premultiply( _quaternion );\n\n\t\t// calculate the active point\n\t\tlet fixedPoint = null;\n\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\tfixedPoint = _pos.copy( pivotPoint );\n\n\t\t} else if ( zoomPointSet ) {\n\n\t\t\tfixedPoint = _pos.copy( zoomPoint );\n\n\t\t}\n\n\t\t// shift the camera in an effort to keep the fixed point in the same spot\n\t\tif ( fixedPoint ) {\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.copy( fixedPoint ).applyMatrix4( _invMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\t_center.subVectors( fixedPoint, _vec );\n\t\t\tcamera.position.add( _center );\n\n\t\t}\n\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t// clamp rotation to the given \"up\" vector\n\t_clampRotation( up ) {\n\n\t\tconst { camera, minAltitude, maxAltitude, state, pivotPoint, zoomPoint, zoomPointSet } = this;\n\n\t\tcamera.updateMatrixWorld();\n\n\t\t// calculate current angles and clamp\n\t\t_forward.set( 0, 0, 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\n\t\t// get the signed angle relative to the top down view\n\t\tlet angle;\n\t\tif ( up.dot( _forward ) > 1 - 1e-10 ) {\n\n\t\t\tangle = 0;\n\n\t\t} else {\n\n\t\t\t_vec.crossVectors( up, _forward );\n\n\t\t\tconst sign = Math.sign( _vec.dot( _right ) );\n\t\t\tangle = sign * up.angleTo( _forward );\n\n\t\t}\n\n\t\t// find the angle to target\n\t\tlet targetAngle;\n\t\tif ( angle > maxAltitude ) {\n\n\t\t\ttargetAngle = maxAltitude;\n\n\t\t} else if ( angle < minAltitude ) {\n\n\t\t\ttargetAngle = minAltitude;\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// construct a rotation basis\n\t\t_forward.copy( up );\n\t\t_quaternion.setFromAxisAngle( _right, targetAngle );\n\t\t_forward.applyQuaternion( _quaternion ).normalize();\n\t\t_vec.crossVectors( _forward, _right ).normalize();\n\n\t\t_rotMatrix.makeBasis( _right, _vec, _forward );\n\t\tcamera.quaternion.setFromRotationMatrix( _rotMatrix );\n\n\t\t// calculate the active point\n\t\tlet fixedPoint = null;\n\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\tfixedPoint = _pos.copy( pivotPoint );\n\n\t\t} else if ( zoomPointSet ) {\n\n\t\t\tfixedPoint = _pos.copy( zoomPoint );\n\n\t\t}\n\n\t\t// shift the camera in an effort to keep the fixed point in the same spot\n\t\tif ( fixedPoint ) {\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.copy( fixedPoint ).applyMatrix4( _invMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\t_center.subVectors( fixedPoint, _vec );\n\t\t\tcamera.position.add( _center );\n\n\t\t}\n\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n}\n","import {\n\tMatrix4,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tMathUtils,\n\tRay,\n\tGroup,\n} from 'three';\nimport { DRAG, ZOOM, EnvironmentControls, NONE } from './EnvironmentControls.js';\nimport { makeRotateAroundPoint, mouseToCoords, setRaycasterFromCamera } from './utils.js';\nimport { Ellipsoid } from '../math/Ellipsoid.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\n\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _rotMatrix = /* @__PURE__ */ new Matrix4();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _targetRight = /* @__PURE__ */ new Vector3();\nconst _globalUp = /* @__PURE__ */ new Vector3();\nconst _quaternion = /* @__PURE__ */ new Quaternion();\nconst _zoomPointUp = /* @__PURE__ */ new Vector3();\nconst _toCenter = /* @__PURE__ */ new Vector3();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _ellipsoid = /* @__PURE__ */ new Ellipsoid();\nconst _pointer = /* @__PURE__ */ new Vector2();\nconst _latLon = {};\n\n// hand picked minimum elevation to tune far plane near surface\nconst MIN_ELEVATION = 2550;\nexport class GlobeControls extends EnvironmentControls {\n\n\tget tilesGroup() {\n\n\t\tconsole.warn( 'GlobeControls: \"tilesGroup\" has been deprecated. Use \"ellipsoidGroup\", instead.' );\n\t\treturn this.ellipsoidFrame;\n\n\t}\n\n\tget ellipsoidFrame() {\n\n\t\treturn this.ellipsoidGroup.matrixWorld;\n\n\t}\n\n\tget ellipsoidFrameInverse() {\n\n\t\tconst { ellipsoidGroup, ellipsoidFrame, _ellipsoidFrameInverse } = this;\n\t\treturn ellipsoidGroup.matrixWorldInverse ?\n\t\t\tellipsoidGroup.matrixWorldInverse :\n\t\t\t_ellipsoidFrameInverse.copy( ellipsoidFrame ).invert();\n\n\t}\n\n\tconstructor( scene = null, camera = null, domElement = null, tilesRenderer = null ) {\n\n\t\t// store which mode the drag stats are in\n\t\tsuper( scene, camera, domElement );\n\n\t\tthis.isGlobeControls = true;\n\n\t\tthis._dragMode = 0;\n\t\tthis._rotationMode = 0;\n\t\tthis.maxZoom = 0.01;\n\t\tthis.nearMargin = 0.25;\n\t\tthis.farMargin = 0;\n\t\tthis.useFallbackPlane = false;\n\t\tthis.autoAdjustCameraRotation = false;\n\n\t\tthis.globeInertia = new Quaternion();\n\t\tthis.globeInertiaFactor = 0;\n\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.ellipsoidGroup = new Group();\n\t\tthis._ellipsoidFrameInverse = new Matrix4();\n\n\t\tif ( tilesRenderer !== null ) {\n\n\t\t\tthis.setTilesRenderer( tilesRenderer );\n\n\t\t}\n\n\t}\n\n\tsetTilesRenderer( tilesRenderer ) {\n\n\t\tsuper.setTilesRenderer( tilesRenderer );\n\t\tif ( tilesRenderer !== null ) {\n\n\t\t\tthis.setEllipsoid( tilesRenderer.ellipsoid, tilesRenderer.group );\n\n\t\t}\n\n\t}\n\n\tsetEllipsoid( ellipsoid, ellipsoidGroup ) {\n\n\t\tthis.ellipsoid = ellipsoid || WGS84_ELLIPSOID.clone();\n\t\tthis.ellipsoidGroup = ellipsoidGroup || new Group();\n\n\t}\n\n\tgetPivotPoint( target ) {\n\n\t\tconst { camera, ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\n\t\t// get camera values\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t// set a ray in the local ellipsoid frame\n\t\t_ray.origin.copy( camera.position );\n\t\t_ray.direction.copy( _forward );\n\t\t_ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t// get the estimated closest point\n\t\tellipsoid\n\t\t\t.closestPointToRayEstimate( _ray, _vec )\n\t\t\t.applyMatrix4( ellipsoidFrame );\n\n\t\t// use the closest point if no pivot was provided or it's closer\n\t\tif (\n\t\t\tsuper.getPivotPoint( target ) === null ||\n\t\t\t_pos.subVectors( target, _ray.origin ).dot( _ray.direction ) > _pos.subVectors( _vec, _ray.origin ).dot( _ray.direction )\n\t\t) {\n\n\t\t\ttarget.copy( _vec );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// get the vector to the center of the provided globe\n\tgetVectorToCenter( target ) {\n\n\t\tconst { ellipsoidFrame, camera } = this;\n\t\treturn target\n\t\t\t.setFromMatrixPosition( ellipsoidFrame )\n\t\t\t.sub( camera.position );\n\n\t}\n\n\t// get the distance to the center of the globe\n\tgetDistanceToCenter() {\n\n\t\treturn this\n\t\t\t.getVectorToCenter( _vec )\n\t\t\t.length();\n\n\t}\n\n\tgetUpDirection( point, target ) {\n\n\t\t// get the \"up\" direction based on the wgs84 ellipsoid\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\t\t_vec.copy( point ).applyMatrix4( ellipsoidFrameInverse );\n\n\t\tellipsoid.getPositionToNormal( _vec, target );\n\t\ttarget.transformDirection( ellipsoidFrame );\n\n\t}\n\n\tgetCameraUpDirection( target ) {\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid, camera } = this;\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\tthis._getVirtualOrthoCameraPosition( _vec );\n\n\t\t\t_vec.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\tellipsoid.getPositionToNormal( _vec, target );\n\t\t\ttarget.transformDirection( ellipsoidFrame );\n\n\t\t} else {\n\n\t\t\tthis.getUpDirection( camera.position, target );\n\n\t\t}\n\n\t}\n\n\tupdate( deltaTime = Math.min( this.clock.getDelta(), 64 / 1000 ) ) {\n\n\t\tif ( ! this.enabled || ! this.camera || deltaTime === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { camera, pivotMesh } = this;\n\n\t\t// if we're outside the transition threshold then we toggle some reorientation behavior\n\t\t// when adjusting the up frame while moving the camera\n\t\tif ( this._isNearControls() ) {\n\n\t\t\tthis.scaleZoomOrientationAtEdges = this.zoomDelta < 0;\n\n\t\t} else {\n\n\t\t\tif ( this.state !== NONE && this._dragMode !== 1 && this._rotationMode !== 1 ) {\n\n\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t}\n\n\t\t\tthis.scaleZoomOrientationAtEdges = false;\n\n\t\t}\n\n\t\tconst adjustCameraRotation = this.needsUpdate || this._inertiaNeedsUpdate();\n\n\t\t// fire basic controls update\n\t\tsuper.update( deltaTime );\n\n\t\t// update the camera planes and the ortho camera position\n\t\tthis.adjustCamera( camera );\n\n\t\t// align the camera up vector if the camera as updated\n\t\tif ( adjustCameraRotation && this._isNearControls() ) {\n\n\t\t\tthis.getCameraUpDirection( _globalUp );\n\t\t\tthis._alignCameraUp( _globalUp, 1 );\n\n\t\t\tthis.getCameraUpDirection( _globalUp );\n\t\t\tthis._clampRotation( _globalUp );\n\n\t\t}\n\n\t}\n\n\n\t// Updates the passed camera near and far clip planes to encapsulate the ellipsoid from the\n\t// current position in addition to adjusting the height.\n\tadjustCamera( camera ) {\n\n\t\tsuper.adjustCamera( camera );\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid, nearMargin, farMargin } = this;\n\t\tconst maxRadius = Math.max( ...ellipsoid.radius );\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t// adjust the clip planes\n\t\t\tconst distanceToCenter = _vec\n\t\t\t\t.setFromMatrixPosition( ellipsoidFrame )\n\t\t\t\t.sub( camera.position ).length();\n\n\t\t\t// update the projection matrix\n\t\t\t// interpolate from the 25% radius margin around the globe down to the surface\n\t\t\t// so we can avoid z fighting when near value is too far at a high altitude\n\t\t\tconst margin = nearMargin * maxRadius;\n\t\t\tconst alpha = MathUtils.clamp( ( distanceToCenter - maxRadius ) / margin, 0, 1 );\n\t\t\tconst minNear = MathUtils.lerp( 1, 1000, alpha );\n\t\t\tcamera.near = Math.max( minNear, distanceToCenter - maxRadius - margin );\n\n\t\t\t// update the far plane to the horizon distance\n\t\t\t_pos.copy( camera.position ).applyMatrix4( ellipsoidFrameInverse );\n\t\t\tellipsoid.getPositionToCartographic( _pos, _latLon );\n\n\t\t\t// use a minimum elevation for computing the horizon distance to avoid the far clip\n\t\t\t// plane approaching zero or clipping mountains over the horizon in the distance as\n\t\t\t// the camera goes to or below sea level.\n\t\t\tconst elevation = Math.max( ellipsoid.getPositionElevation( _pos ), MIN_ELEVATION );\n\t\t\tconst horizonDistance = ellipsoid.calculateHorizonDistance( _latLon.lat, elevation );\n\n\t\t\tcamera.far = horizonDistance + 0.1 + maxRadius * farMargin;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t} else {\n\n\t\t\tthis._getVirtualOrthoCameraPosition( camera.position, camera );\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.setFromMatrixPosition( ellipsoidFrame ).applyMatrix4( _invMatrix );\n\n\t\t\tconst distanceToCenter = - _vec.z;\n\t\t\tcamera.near = distanceToCenter - maxRadius * ( 1 + nearMargin );\n\t\t\tcamera.far = distanceToCenter + 0.1 + maxRadius * farMargin;\n\n\t\t\t// adjust the position of the ortho camera such that the near value is 0\n\t\t\tcamera.position.addScaledVector( _forward, camera.near );\n\t\t\tcamera.far -= camera.near;\n\t\t\tcamera.near = 0;\n\n\t\t\tcamera.updateProjectionMatrix();\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\t// resets the \"stuck\" drag modes\n\tsetState( ...args ) {\n\n\t\tsuper.setState( ...args );\n\t\tthis._dragMode = 0;\n\t\tthis._rotationMode = 0;\n\n\t}\n\n\t_updateInertia( deltaTime ) {\n\n\t\tsuper._updateInertia( deltaTime );\n\n\t\tconst {\n\t\t\tglobeInertia,\n\t\t\tenableDamping,\n\t\t\tdampingFactor,\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tminDistance,\n\t\t\tinertiaTargetDistance,\n\t\t\tellipsoidFrame,\n\t\t} = this;\n\n\t\tif ( ! this.enableDamping || this.inertiaStableFrames > 1 ) {\n\n\t\t\tthis.globeInertiaFactor = 0;\n\t\t\tthis.globeInertia.identity();\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst factor = Math.pow( 2, - deltaTime / dampingFactor );\n\t\tconst stableDistance = Math.max( camera.near, cameraRadius, minDistance, inertiaTargetDistance );\n\t\tconst resolution = 2 * 1e3;\n\t\tconst pixelWidth = 2 / resolution;\n\t\tconst pixelThreshold = 0.25 * pixelWidth;\n\n\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\n\t\tif ( this.globeInertiaFactor !== 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _pos.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _pos );\n\t\t\t_pos.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// get implied angle\n\t\t\t_vec.sub( _center ).normalize();\n\t\t\t_pos.sub( _center ).normalize();\n\n\t\t\tthis.globeInertiaFactor *= factor;\n\t\t\tconst threshold = _vec.angleTo( _pos ) / deltaTime;\n\t\t\tconst globeAngle = 2 * Math.acos( globeInertia.w ) * this.globeInertiaFactor;\n\t\t\tif ( globeAngle < threshold || ! enableDamping ) {\n\n\t\t\t\tthis.globeInertiaFactor = 0;\n\t\t\t\tglobeInertia.identity();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.globeInertiaFactor !== 0 ) {\n\n\t\t\t// ensure our w component is non-one if the xyz values are\n\t\t\t// non zero to ensure we can animate\n\t\t\tif (\n\t\t\t\tglobeInertia.w === 1 && (\n\t\t\t\t\tglobeInertia.x !== 0 ||\n\t\t\t\t\tglobeInertia.y !== 0 ||\n\t\t\t\t\tglobeInertia.z !== 0\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tglobeInertia.w = Math.min( globeInertia.w, 1 - 1e-9 );\n\n\t\t\t}\n\n\t\t\t// construct the rotation matrix\n\t\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\t\t\t_quaternion.identity().slerp( globeInertia, this.globeInertiaFactor * deltaTime );\n\t\t\tmakeRotateAroundPoint( _center, _quaternion, _rotMatrix );\n\n\t\t\t// apply the rotation\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t}\n\n\t}\n\n\t_inertiaNeedsUpdate() {\n\n\t\treturn super._inertiaNeedsUpdate() || this.globeInertiaFactor !== 0;\n\n\t}\n\n\t_updatePosition( deltaTime ) {\n\n\t\tif ( this.state === DRAG ) {\n\n\t\t\t// save the drag mode state so we can update the pivot mesh visuals in \"update\"\n\t\t\tif ( this._dragMode === 0 ) {\n\n\t\t\t\tthis._dragMode = this._isNearControls() ? 1 : - 1;\n\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\traycaster,\n\t\t\t\tcamera,\n\t\t\t\tpivotPoint,\n\t\t\t\tpointerTracker,\n\t\t\t\tdomElement,\n\t\t\t\tellipsoidFrame,\n\t\t\t\tellipsoidFrameInverse,\n\t\t\t} = this;\n\n\t\t\t// reuse cache variables\n\t\t\tconst pivotDir = _pos;\n\t\t\tconst newPivotDir = _targetRight;\n\n\t\t\t// get the pointer and ray\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _pointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// transform to ellipsoid frame\n\t\t\traycaster.ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\t// construct an ellipsoid that matches a sphere with the radius of the globe so\n\t\t\t// the drag position matches where the initial click was\n\t\t\tconst pivotRadius = _vec.copy( pivotPoint ).applyMatrix4( ellipsoidFrameInverse ).length();\n\t\t\t_ellipsoid.radius.setScalar( pivotRadius );\n\n\t\t\t// if we drag off the sphere then end the operation and follow through on the inertia\n\t\t\tif ( ! _ellipsoid.intersectRay( raycaster.ray, _vec ) ) {\n\n\t\t\t\tthis.resetState();\n\t\t\t\tthis._updateInertia( deltaTime );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_vec.applyMatrix4( ellipsoidFrame );\n\n\t\t\t// get the point directions\n\t\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\t\t\tpivotDir.subVectors( pivotPoint, _center ).normalize();\n\t\t\tnewPivotDir.subVectors( _vec, _center ).normalize();\n\n\t\t\t// construct the rotation\n\t\t\t_quaternion.setFromUnitVectors( newPivotDir, pivotDir );\n\t\t\tmakeRotateAroundPoint( _center, _quaternion, _rotMatrix );\n\n\t\t\t// apply the rotation\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t} else {\n\n\t\t\t\tthis.globeInertia.copy( _quaternion );\n\t\t\t\tthis.globeInertiaFactor = 1 / deltaTime;\n\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// disable rotation once we're outside the control transition\n\t_updateRotation( ...args ) {\n\n\t\tif ( this._rotationMode === 1 || this._isNearControls() ) {\n\n\t\t\tthis._rotationMode = 1;\n\t\t\tsuper._updateRotation( ...args );\n\n\t\t} else {\n\n\t\t\tthis.pivotMesh.visible = false;\n\t\t\tthis._rotationMode = - 1;\n\n\t\t}\n\n\n\t}\n\n\t_updateZoom() {\n\n\t\tconst { zoomDelta, ellipsoid, zoomSpeed, zoomPoint, camera, maxZoom, state } = this;\n\n\t\tif ( state !== ZOOM && zoomDelta === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// reset momentum\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\tthis.globeInertia.identity();\n\t\tthis.globeInertiaFactor = 0;\n\n\t\t// used to scale the tilt transitions based on zoom intensity\n\t\tconst deltaAlpha = MathUtils.clamp( MathUtils.mapLinear( Math.abs( zoomDelta ), 0, 20, 0, 1 ), 0, 1 );\n\t\tif ( this._isNearControls() || zoomDelta > 0 ) {\n\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// When zooming try to tilt the camera towards the center of the planet to avoid the globe\n\t\t\t// spinning as you zoom out from the horizon\n\t\t\tif ( zoomDelta < 0 && ( this.zoomPointSet || this._updateZoomPoint() ) ) {\n\n\t\t\t\t// get the forward vector and vector toward the center of the ellipsoid\n\t\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).normalize();\n\t\t\t\t_toCenter.copy( this.up ).multiplyScalar( - 1 );\n\n\t\t\t\t// Calculate alpha values to use to scale the amount of tilt that occurs as the camera moves.\n\t\t\t\t// Scales based on mouse position near the horizon and current tilt.\n\t\t\t\tthis.getUpDirection( zoomPoint, _zoomPointUp );\n\t\t\t\tconst upAlpha = MathUtils.clamp( MathUtils.mapLinear( - _zoomPointUp.dot( _toCenter ), 1, 0.95, 0, 1 ), 0, 1 );\n\t\t\t\tconst forwardAlpha = 1 - _forward.dot( _toCenter );\n\t\t\t\tconst cameraAlpha = camera.isOrthographicCamera ? 0.05 : 1;\n\t\t\t\tconst adjustedDeltaAlpha = MathUtils.clamp( deltaAlpha * 3, 0, 1 );\n\n\t\t\t\t// apply scale\n\t\t\t\tconst alpha = Math.min( upAlpha * forwardAlpha * cameraAlpha * adjustedDeltaAlpha, 0.1 );\n\t\t\t\t_toCenter.lerpVectors( _forward, _toCenter, alpha ).normalize();\n\n\t\t\t\t// perform rotation\n\t\t\t\t_quaternion.setFromUnitVectors( _forward, _toCenter );\n\t\t\t\tmakeRotateAroundPoint( zoomPoint, _quaternion, _rotMatrix );\n\t\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _toCenter );\n\n\t\t\t\t// update zoom direction\n\t\t\t\tthis.zoomDirection.subVectors( zoomPoint, camera.position ).normalize();\n\n\t\t\t}\n\n\t\t\tsuper._updateZoom();\n\n\t\t} else if ( camera.isPerspectiveCamera ) {\n\n\t\t\t// orient the camera to focus on the earth during the zoom\n\t\t\tconst transitionDistance = this._getPerspectiveTransitionDistance();\n\t\t\tconst maxDistance = this._getMaxPerspectiveDistance();\n\t\t\tconst distanceAlpha = MathUtils.mapLinear( this.getDistanceToCenter(), transitionDistance, maxDistance, 0, 1 );\n\t\t\tthis._tiltTowardsCenter( MathUtils.lerp( 0, 0.4, distanceAlpha * deltaAlpha ) );\n\t\t\tthis._alignCameraUpToNorth( MathUtils.lerp( 0, 0.2, distanceAlpha * deltaAlpha ) );\n\n\t\t\t// calculate zoom in a similar way to environment controls so\n\t\t\t// the zoom speeds are comparable\n\t\t\tconst dist = this.getDistanceToCenter() - ellipsoid.radius.x;\n\t\t\tconst scale = zoomDelta * dist * zoomSpeed * 0.0025;\n\t\t\tconst clampedScale = Math.max( scale, Math.min( this.getDistanceToCenter() - maxDistance, 0 ) );\n\n\t\t\t// zoom out directly from the globe center\n\t\t\tthis.getVectorToCenter( _vec ).normalize();\n\t\t\tthis.camera.position.addScaledVector( _vec, clampedScale );\n\t\t\tthis.camera.updateMatrixWorld();\n\n\t\t\tthis.zoomDelta = 0;\n\n\t\t} else {\n\n\t\t\tconst transitionZoom = this._getOrthographicTransitionZoom();\n\t\t\tconst minZoom = this._getMinOrthographicZoom();\n\t\t\tconst distanceAlpha = MathUtils.mapLinear( camera.zoom, transitionZoom, minZoom, 0, 1 );\n\t\t\tthis._tiltTowardsCenter( MathUtils.lerp( 0, 0.4, distanceAlpha * deltaAlpha ) );\n\t\t\tthis._alignCameraUpToNorth( MathUtils.lerp( 0, 0.2, distanceAlpha * deltaAlpha ) );\n\n\t\t\tconst scale = this.zoomDelta;\n\t\t\tconst normalizedDelta = Math.pow( 0.95, Math.abs( scale * 0.05 ) );\n\t\t\tconst scaleFactor = scale > 0 ? 1 / Math.abs( normalizedDelta ) : normalizedDelta;\n\n\t\t\tconst maxScaleFactor = minZoom / camera.zoom;\n\t\t\tconst clampedScaleFactor = Math.max( scaleFactor * zoomSpeed, Math.min( maxScaleFactor, 1 ) );\n\n\t\t\tcamera.zoom = Math.min( maxZoom, camera.zoom * clampedScaleFactor );\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\tthis.zoomDelta = 0;\n\t\t\tthis.zoomDirectionSet = false;\n\n\t\t}\n\n\t}\n\n\t// tilt the camera to align with north\n\t_alignCameraUpToNorth( alpha ) {\n\n\t\tconst { ellipsoidFrame } = this;\n\t\t_globalUp.set( 0, 0, 1 ).transformDirection( ellipsoidFrame );\n\t\tthis._alignCameraUp( _globalUp, alpha );\n\n\t}\n\n\t// tilt the camera to look at the center of the globe\n\t_tiltTowardsCenter( alpha ) {\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tellipsoidFrame,\n\t\t} = this;\n\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).normalize();\n\t\t_vec.setFromMatrixPosition( ellipsoidFrame ).sub( camera.position ).normalize();\n\t\t_vec.lerp( _forward, 1 - alpha ).normalize();\n\n\t\t_quaternion.setFromUnitVectors( _forward, _vec );\n\t\tcamera.quaternion.premultiply( _quaternion );\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t// returns the perspective camera transition distance can move to based on globe size and fov\n\t_getPerspectiveTransitionDistance() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isPerspectiveCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// When the smallest fov spans 65% of the ellipsoid then we use the near controls\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst fovHoriz = 2 * Math.atan( Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 ) * camera.aspect );\n\t\tconst distVert = ellipsoidRadius / Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 );\n\t\tconst distHoriz = ellipsoidRadius / Math.tan( fovHoriz * 0.5 );\n\t\tconst dist = Math.max( distVert, distHoriz );\n\n\t\treturn dist;\n\n\t}\n\n\t// returns the max distance the perspective camera can move to based on globe size and fov\n\t_getMaxPerspectiveDistance() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isPerspectiveCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// allow for zooming out such that the ellipsoid is half the size of the largest fov\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst fovHoriz = 2 * Math.atan( Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 ) * camera.aspect );\n\t\tconst distVert = ellipsoidRadius / Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 );\n\t\tconst distHoriz = ellipsoidRadius / Math.tan( fovHoriz * 0.5 );\n\t\tconst dist = 2 * Math.max( distVert, distHoriz );\n\n\t\treturn dist;\n\n\t}\n\n\t// returns the transition threshold for orthographic zoom based on the globe size and camera settings\n\t_getOrthographicTransitionZoom() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.max( orthoHeight, orthoWidth );\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst ellipsoidDiameter = 2 * ellipsoidRadius;\n\t\treturn 2 * orthoSize / ellipsoidDiameter;\n\n\t}\n\n\t// returns the minimum allowed orthographic zoom based on the globe size and camera settings\n\t_getMinOrthographicZoom() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.min( orthoHeight, orthoWidth );\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst ellipsoidDiameter = 2 * ellipsoidRadius;\n\t\treturn 0.7 * orthoSize / ellipsoidDiameter;\n\n\t}\n\n\t// returns the \"virtual position\" of the orthographic based on where it is and\n\t// where it's looking primarily so we can reasonably position the camera object\n\t// in space and derive a reasonable \"up\" value.\n\t_getVirtualOrthoCameraPosition( target, camera = this.camera ) {\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// get ray in globe coordinate frame\n\t\t_ray.origin.copy( camera.position );\n\t\t_ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t_ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t// get the closest point to the ray on the globe in the global coordinate frame\n\t\tellipsoid\n\t\t\t.closestPointToRayEstimate( _ray, _pos )\n\t\t\t.applyMatrix4( ellipsoidFrame );\n\n\t\t// get ortho camera info\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.max( orthoHeight, orthoWidth ) / camera.zoom;\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t// ensure we move the camera exactly along the forward vector to avoid shifting\n\t\t// the camera in other directions due to floating point error\n\t\tconst dist = _pos.sub( camera.position ).dot( _forward );\n\t\ttarget.copy( camera.position ).addScaledVector( _forward, dist - orthoSize * 4 );\n\n\t}\n\n\t_isNearControls() {\n\n\t\tconst { camera } = this;\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\treturn this.getDistanceToCenter() < this._getPerspectiveTransitionDistance();\n\n\t\t} else {\n\n\t\t\treturn camera.zoom > this._getOrthographicTransitionZoom();\n\n\t\t}\n\n\t}\n\n\t_raycast( raycaster ) {\n\n\t\tconst result = super._raycast( raycaster );\n\t\tif ( result === null ) {\n\n\t\t\t// if there was no hit then fallback to intersecting the ellipsoid.\n\t\t\tconst { ellipsoid, ellipsoidFrame, ellipsoidFrameInverse } = this;\n\t\t\t_ray.copy( raycaster.ray ).applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\tconst point = ellipsoid.intersectRay( _ray, _vec );\n\t\t\tif ( point !== null ) {\n\n\t\t\t\tpoint.applyMatrix4( ellipsoidFrame );\n\t\t\t\treturn {\n\t\t\t\t\tpoint: point.clone(),\n\t\t\t\t\tdistance: point.distanceTo( raycaster.ray.origin ),\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n}\n","import { Clock, EventDispatcher, MathUtils, OrthographicCamera, PerspectiveCamera, Quaternion, Vector3 } from 'three';\n\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _orthographicCamera = /* @__PURE__ */ new OrthographicCamera();\nconst _targetOffset = /* @__PURE__ */ new Vector3();\nconst _perspOffset = /* @__PURE__ */ new Vector3();\nconst _orthoOffset = /* @__PURE__ */ new Vector3();\nconst _quat = /* @__PURE__ */ new Quaternion();\nconst _targetQuat = /* @__PURE__ */ new Quaternion();\n\nexport class CameraTransitionManager extends EventDispatcher {\n\n\tget animating() {\n\n\t\treturn this._alpha !== 0 && this._alpha !== 1;\n\n\t}\n\n\tget alpha() {\n\n\t\t// the transition alpha towards the target camera\n\t\treturn this._target === 0 ? 1 - this._alpha : this._alpha;\n\n\t}\n\n\tget camera() {\n\n\t\tif ( this._alpha === 0 ) return this.perspectiveCamera;\n\t\tif ( this._alpha === 1 ) return this.orthographicCamera;\n\t\treturn this.transitionCamera;\n\n\t}\n\n\tget mode() {\n\n\t\treturn this._target === 0 ? 'perspective' : 'orthographic';\n\n\t}\n\n\tset mode( v ) {\n\n\t\tif ( v === this.mode ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst prevCamera = this.camera;\n\t\tif ( v === 'perspective' ) {\n\n\t\t\tthis._target = 0;\n\t\t\tthis._alpha = 0;\n\n\t\t} else {\n\n\t\t\tthis._target = 1;\n\t\t\tthis._alpha = 1;\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'camera-change', camera: this.camera, prevCamera: prevCamera } );\n\n\t}\n\n\tconstructor( perspectiveCamera = new PerspectiveCamera(), orthographicCamera = new OrthographicCamera() ) {\n\n\t\tsuper();\n\n\t\tthis.perspectiveCamera = perspectiveCamera;\n\t\tthis.orthographicCamera = orthographicCamera;\n\t\tthis.transitionCamera = new PerspectiveCamera();\n\n\t\t// settings\n\t\tthis.orthographicPositionalZoom = true;\n\t\tthis.orthographicOffset = 50;\n\t\tthis.fixedPoint = new Vector3();\n\t\tthis.duration = 200;\n\t\tthis.autoSync = true;\n\t\tthis.easeFunction = x => x;\n\n\t\tthis._target = 0;\n\t\tthis._alpha = 0;\n\t\tthis._clock = new Clock();\n\n\t}\n\n\ttoggle() {\n\n\t\t// reset the clock for cases where we're not calling \"update\" every frame\n\t\tthis._target = this._target === 1 ? 0 : 1;\n\t\tthis._clock.getDelta();\n\n\t\tthis.dispatchEvent( { type: 'toggle' } );\n\n\t}\n\n\tupdate( deltaTime = Math.min( this._clock.getDelta(), 64 / 1000 ) ) {\n\n\t\t// update transforms\n\t\tif ( this.autoSync ) {\n\n\t\t\tthis.syncCameras();\n\n\t\t}\n\n\t\t// perform transition\n\t\tconst { perspectiveCamera, orthographicCamera, transitionCamera, camera } = this;\n\t\tconst delta = deltaTime * 1e3;\n\n\t\tif ( this._alpha !== this._target ) {\n\n\t\t\tconst direction = Math.sign( this._target - this._alpha );\n\t\t\tconst step = direction * delta / this.duration;\n\t\t\tthis._alpha = MathUtils.clamp( this._alpha + step, 0, 1 );\n\n\t\t\tthis.dispatchEvent( { type: 'change', alpha: this.alpha } );\n\n\t\t}\n\n\t\t// find the new camera\n\t\tconst prevCamera = camera;\n\t\tlet newCamera = null;\n\t\tif ( this._alpha === 0 ) {\n\n\t\t\tnewCamera = perspectiveCamera;\n\n\t\t} else if ( this._alpha === 1 ) {\n\n\t\t\tnewCamera = orthographicCamera;\n\n\t\t} else {\n\n\t\t\tnewCamera = transitionCamera;\n\t\t\tthis._updateTransitionCamera();\n\n\t\t}\n\n\t\tif ( prevCamera !== newCamera ) {\n\n\t\t\tif ( newCamera === transitionCamera ) {\n\n\t\t\t\tthis.dispatchEvent( { type: 'transition-start' } );\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( { type: 'camera-change', camera: newCamera, prevCamera: prevCamera } );\n\n\t\t\tif ( prevCamera === transitionCamera ) {\n\n\t\t\t\tthis.dispatchEvent( { type: 'transition-end' } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsyncCameras() {\n\n\t\tconst fromCamera = this._getFromCamera();\n\t\tconst { perspectiveCamera, orthographicCamera, transitionCamera, fixedPoint } = this;\n\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( fromCamera.matrixWorld ).normalize();\n\n\t\tif ( fromCamera.isPerspectiveCamera ) {\n\n\t\t\t// offset the orthographic camera backwards based on user setting to avoid cases where the ortho\n\t\t\t// camera position will clip into terrain when once transitioned\n\t\t\tif ( this.orthographicPositionalZoom ) {\n\n\t\t\t\torthographicCamera.position.copy( perspectiveCamera.position ).addScaledVector( _forward, - this.orthographicOffset );\n\t\t\t\torthographicCamera.rotation.copy( perspectiveCamera.rotation );\n\t\t\t\torthographicCamera.updateMatrixWorld();\n\n\t\t\t} else {\n\n\t\t\t\tconst orthoDist = _vec.subVectors( fixedPoint, orthographicCamera.position ).dot( _forward );\n\t\t\t\tconst perspDist = _vec.subVectors( fixedPoint, perspectiveCamera.position ).dot( _forward );\n\n\t\t\t\t_vec.copy( perspectiveCamera.position ).addScaledVector( _forward, perspDist );\n\t\t\t\torthographicCamera.rotation.copy( perspectiveCamera.rotation );\n\t\t\t\torthographicCamera.position.copy( _vec ).addScaledVector( _forward, - orthoDist );\n\t\t\t\torthographicCamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\t// calculate the necessary orthographic zoom based on the current perspective camera position\n\t\t\tconst distToPoint = Math.abs( _vec.subVectors( perspectiveCamera.position, fixedPoint ).dot( _forward ) );\n\t\t\tconst projectionHeight = 2 * Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov * 0.5 ) * distToPoint;\n\t\t\tconst orthoHeight = orthographicCamera.top - orthographicCamera.bottom;\n\t\t\torthographicCamera.zoom = orthoHeight / projectionHeight;\n\t\t\torthographicCamera.updateProjectionMatrix();\n\n\t\t} else {\n\n\t\t\t// calculate the target distance from the point\n\t\t\tconst distToPoint = Math.abs( _vec.subVectors( orthographicCamera.position, fixedPoint ).dot( _forward ) );\n\t\t\tconst orthoHeight = ( orthographicCamera.top - orthographicCamera.bottom ) / orthographicCamera.zoom;\n\t\t\tconst targetDist = orthoHeight * 0.5 / Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov * 0.5 );\n\n\t\t\t// set the final camera position so the pivot point is stable\n\t\t\tperspectiveCamera.rotation.copy( orthographicCamera.rotation );\n\t\t\tperspectiveCamera.position.copy( orthographicCamera.position )\n\t\t\t\t.addScaledVector( _forward, distToPoint )\n\t\t\t\t.addScaledVector( _forward, - targetDist );\n\n\t\t\tperspectiveCamera.updateMatrixWorld();\n\n\t\t\t// shift the orthographic camera position so it aligns with the perspective cameras position as\n\t\t\t// calculated by the FoV. This ensures a consistent orthographic position on transition.\n\t\t\tif ( this.orthographicPositionalZoom ) {\n\n\t\t\t\torthographicCamera.position.copy( perspectiveCamera.position ).addScaledVector( _forward, - this.orthographicOffset );\n\t\t\t\torthographicCamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t}\n\n\t\ttransitionCamera.position.copy( perspectiveCamera.position );\n\t\ttransitionCamera.rotation.copy( perspectiveCamera.rotation );\n\n\t}\n\n\t_getTransitionDirection() {\n\n\t\treturn Math.sign( this._target - this._alpha );\n\n\t}\n\n\t_getToCamera() {\n\n\t\tconst dir = this._getTransitionDirection();\n\t\tif ( dir === 0 ) {\n\n\t\t\treturn this._target === 0 ? this.perspectiveCamera : this.orthographicCamera;\n\n\t\t} else if ( dir > 0 ) {\n\n\t\t\treturn this.orthographicCamera;\n\n\t\t} else {\n\n\t\t\treturn this.perspectiveCamera;\n\n\t\t}\n\n\t}\n\n\t_getFromCamera() {\n\n\t\tconst dir = this._getTransitionDirection();\n\t\tif ( dir === 0 ) {\n\n\t\t\treturn this._target === 0 ? this.perspectiveCamera : this.orthographicCamera;\n\n\t\t} else if ( dir > 0 ) {\n\n\t\t\treturn this.perspectiveCamera;\n\n\t\t} else {\n\n\t\t\treturn this.orthographicCamera;\n\n\t\t}\n\n\t}\n\n\t_updateTransitionCamera() {\n\n\t\t// Perform transition interpolation between the orthographic and perspective camera\n\t\t// alpha === 0 : perspective\n\t\t// alpha === 1 : orthographic\n\n\t\tconst { perspectiveCamera, orthographicCamera, transitionCamera, fixedPoint } = this;\n\t\tconst alpha = this.easeFunction( this._alpha );\n\n\t\t// get the forward vector\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( orthographicCamera.matrixWorld ).normalize();\n\n\t\t_orthographicCamera.copy( orthographicCamera );\n\t\t_orthographicCamera.position.addScaledVector( _forward, orthographicCamera.near );\n\t\torthographicCamera.far -= orthographicCamera.near;\n\t\torthographicCamera.near = 0;\n\n\t\t// compute the projection height based on the perspective camera\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( perspectiveCamera.matrixWorld ).normalize();\n\t\tconst distToPoint = Math.abs( _vec.subVectors( perspectiveCamera.position, fixedPoint ).dot( _forward ) );\n\t\tconst projectionHeight = 2 * Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov * 0.5 ) * distToPoint;\n\n\t\t// calculate the orientation to transition to\n\t\tconst targetQuat = _targetQuat.slerpQuaternions( perspectiveCamera.quaternion, _orthographicCamera.quaternion, alpha );\n\n\t\t// calculate the target distance and fov to position the camera at\n\t\tconst targetFov = MathUtils.lerp( perspectiveCamera.fov, 1, alpha );\n\t\tconst targetDistance = projectionHeight * 0.5 / Math.tan( MathUtils.DEG2RAD * targetFov * 0.5 );\n\n\t\t// calculate the offset from the fixed point\n\t\tconst orthoOffset = _orthoOffset.copy( _orthographicCamera.position ).sub( fixedPoint ).applyQuaternion( _quat.copy( _orthographicCamera.quaternion ).invert() );\n\t\tconst perspOffset = _perspOffset.copy( perspectiveCamera.position ).sub( fixedPoint ).applyQuaternion( _quat.copy( perspectiveCamera.quaternion ).invert() );\n\t\tconst targetOffset = _targetOffset.lerpVectors( perspOffset, orthoOffset, alpha );\n\t\ttargetOffset.z -= Math.abs( targetOffset.z ) - targetDistance;\n\n\t\t// calculate distances to the target point so the offset can be accounted for in near plane calculations\n\t\tconst distToPersp = - ( perspOffset.z - targetOffset.z );\n\t\tconst distToOrtho = - ( orthoOffset.z - targetOffset.z );\n\n\t\t// calculate the near and far plane positions\n\t\tconst targetNearPlane = MathUtils.lerp( distToPersp + perspectiveCamera.near, distToOrtho + _orthographicCamera.near, alpha );\n\t\tconst targetFarPlane = MathUtils.lerp( distToPersp + perspectiveCamera.far, distToOrtho + _orthographicCamera.far, alpha );\n\t\tconst planeDelta = Math.max( targetFarPlane, 0 ) - Math.max( targetNearPlane, 0 );\n\n\t\t// NOTE: The \"planeDelta * 1e-5\" can wind up being larger than either of the camera near planes, resulting\n\t\t// in some clipping during the transition phase.\n\n\t\t// update the camera state\n\t\ttransitionCamera.aspect = perspectiveCamera.aspect;\n\t\ttransitionCamera.fov = targetFov;\n\t\ttransitionCamera.near = Math.max( targetNearPlane, planeDelta * 1e-5 );\n\t\ttransitionCamera.far = targetFarPlane;\n\t\ttransitionCamera.position.copy( targetOffset ).applyQuaternion( targetQuat ).add( fixedPoint );\n\t\ttransitionCamera.quaternion.copy( targetQuat );\n\t\ttransitionCamera.updateProjectionMatrix();\n\t\ttransitionCamera.updateMatrixWorld();\n\n\t}\n\n}\n"],"names":["B3DMLoader","B3DMLoaderBase","manager","DefaultLoadingManager","Matrix4","buffer","b3dm","gltfBuffer","resolve","reject","fetchOptions","loader","GLTFLoader","workingPath","adjustmentTransform","model","batchTable","featureTable","scene","rtcCenter","rgb565torgb","rgb565","red5","green6","blue5","red8","green8","blue8","f","Vector2","decodeOctNormal","x","y","target","Vector3","t","MathUtils","DRACO_ATTRIBUTE_MAP","PNTSLoader","PNTSLoaderBase","result","material","PointsMaterial","extensions","translationOffset","geometry","byteOffset","byteLength","properties","dracoLoader","attributeIDs","key","mappedKey","taskConfig","POINTS_LENGTH","POSITION","NORMAL","NORMAL_OCT16P","RGB","RGBA","RGB565","CONSTANT_RGBA","POSITION_QUANTIZED","QUANTIZED_VOLUME_SCALE","QUANTIZED_VOLUME_OFFSET","BufferGeometry","decodedPositions","i","j","index","BufferAttribute","decodedNormals","n","normal","color","rgbColor","Color","opacity","object","Points","tempFwd","tempUp","tempRight","tempPos","tempQuat","Quaternion","tempSca","tempMat","tempMat2","tempGlobePos","tempEnuFrame","tempLocalQuat","tempLatLon","I3DMLoader","I3DMLoaderBase","WGS84_ELLIPSOID","url","i3dm","INSTANCES_LENGTH","NORMAL_UP","NORMAL_RIGHT","SCALE_NON_UNIFORM","SCALE","RTC_CENTER","EAST_NORTH_UP","feature","averageVector","instances","meshes","child","instancedMesh","InstancedMesh","l","instance","mesh","CMPTLoader","CMPTLoaderBase","ellipsoid","promises","type","slicedBuffer","promise","results","group","Group","TilesGroup","tilesRenderer","raycaster","intersects","force","elA","elB","isDifferent","itemA","itemB","children","updateParents","updateChildren","_localRay","Ray","_vec","_hitArray","distanceSort","a","b","intersectTileScene","tile","renderer","plugin","intersectTileSceneFirstHist","hit","isTileInitialized","raycastTraverseFirstHit","localRay","activeTiles","array","bestHit","bestHitDistSq","data","boundingVolumeDistSq","hitDistSq","raycastTraverse","boundingVolume","_vecX","_vecY","_vecZ","_sphereVec","_obbVec","TileBoundingVolume","ray","sphere","obb","sphereDistSq","obbDistSq","furthestDist","point","sphereDistance","obbDistance","frustum","otherSphere","otherObb","targetBox","targetMatrix","transform","OBB","scaleX","scaleY","scaleZ","z","radius","Sphere","west","south","east","north","minHeight","maxHeight","region","EllipsoidRegion","_mat3","Matrix3","findIntersectionPoint","plane1","plane2","plane3","A","ExtendedFrustum","Frustum","m","coordinateSystem","planes","points","_mat","_euler","Euler","INITIAL_FRUSTUM_CULLED","tempVector","tempVector2","viewErrorTarget","X_AXIS","Y_AXIS","updateFrustumCulled","toInitialValue","c","TilesRenderer","TilesRendererBase","value","v","args","LoadingManager","listener","EventDispatcher","e","callback","camera","cameras","cameraMap","xOrVec","width","height","cameraVec","root","asset","ext","needsUpdate","res","cameraInfo","info","position","resolution","projection","w","h","found","tilesetDir","parentTile","transformArr","transformInverse","extension","uri","abortSignal","cached","LoaderUtils.getWorkingPath","cachedTransform","upRotationMatrix","fileType","LoaderUtils.readMagicBytes","resourcePath","metadata","materials","textures","texture","parent","visible","bytesUsed","estimateBytesUsed","inView","inViewError","inViewDistance","maxError","minDistance","error","distance","pixelSize","sseDenominator","lat","lon","PivotPointMesh","Mesh","PlaneGeometry","PivotMaterial","uniforms","ShaderMaterial","_vec2","PointerTracker","previousPositions","pointerPositions","id","rect","pointerOrder","id0","id1","p0","p1","_matrix","makeRotateAroundPoint","quat","mouseToCoords","clientX","clientY","element","setRaycasterFromCamera","coords","origin","direction","NONE","DRAG","ROTATE","ZOOM","WAITING","DRAG_PLANE_THRESHOLD","DRAG_UP_THRESHOLD","_rotMatrix","_invMatrix","_delta","_pos","_center","_forward","_right","_targetRight","_rotationAxis","_quaternion","_plane","Plane","_localUp","_mouseBefore","_mouseAfter","_identityQuat","_ray","_zoomPointPointer","_pointer","_prevPointer","_deltaPointer","_centerPoint","_startCenterPoint","_changeEvent","_startEvent","_endEvent","EnvironmentControls","domElement","Raycaster","Clock","contextMenuCallback","pointerdownCallback","up","pivotMesh","pointerTracker","pivotPoint","enabled","dot","_pointerMoveQueued","pointermoveCallback","startDist","pointerDist","separateDelta","dragThreshold","parallelDelta","previousDist","pointerupCallback","wheelCallback","delta","deltaSign","normalizedDelta","pointerleaveCallback","document","state","fireEvent","deltaTime","cameraRadius","adjustHeight","autoAdjustCameraRotation","inertiaNeedsUpdate","adjustCameraRotation","zoomDelta","actionHeightOffset","dist","rotationInertia","dragInertia","enableDamping","dampingFactor","inertiaTargetDistance","factor","stableDistance","pixelThreshold","threshold","zoomPoint","zoomDirection","maxDistance","minZoom","maxZoom","zoomSpeed","scale","zoomIntoPoint","scaleFactor","finalZoomDirection","remainingDistance","zoomDirectionSet","angle","minAltitude","maxAltitude","rotationSpeed","azimuth","altitude","newUp","zoomPointSet","scaleZoomOrientationAtEdges","amt","useFallbackPlane","fallbackPlane","plane","alpha","multiplier","fixedPoint","targetAngle","_globalUp","_zoomPointUp","_toCenter","_ellipsoid","Ellipsoid","_latLon","MIN_ELEVATION","GlobeControls","ellipsoidGroup","ellipsoidFrame","_ellipsoidFrameInverse","ellipsoidFrameInverse","nearMargin","farMargin","maxRadius","distanceToCenter","margin","minNear","elevation","horizonDistance","globeInertia","pivotDir","newPivotDir","pivotRadius","deltaAlpha","upAlpha","forwardAlpha","cameraAlpha","adjustedDeltaAlpha","transitionDistance","distanceAlpha","clampedScale","transitionZoom","maxScaleFactor","clampedScaleFactor","ellipsoidRadius","fovHoriz","distVert","distHoriz","orthoHeight","orthoWidth","orthoSize","ellipsoidDiameter","_orthographicCamera","OrthographicCamera","_targetOffset","_perspOffset","_orthoOffset","_quat","_targetQuat","CameraTransitionManager","prevCamera","perspectiveCamera","PerspectiveCamera","orthographicCamera","transitionCamera","step","newCamera","fromCamera","orthoDist","perspDist","distToPoint","projectionHeight","targetDist","dir","targetQuat","targetFov","targetDistance","orthoOffset","perspOffset","targetOffset","distToPersp","distToOrtho","targetNearPlane","targetFarPlane","planeDelta"],"mappings":"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"}