{"version":3,"file":"CameraTransitionManager-DimD-zBE.js","sources":["../src/three/renderer/loaders/B3DMLoader.js","../src/three/renderer/loaders/rgb565torgb.js","../src/three/renderer/loaders/decodeOctNormal.js","../src/three/renderer/loaders/PNTSLoader.js","../src/three/renderer/loaders/I3DMLoader.js","../src/three/renderer/loaders/CMPTLoader.js","../src/three/renderer/tiles/TilesGroup.js","../src/three/renderer/tiles/raycastTraverse.js","../src/three/renderer/math/TileBoundingVolume.js","../src/three/renderer/math/ExtendedFrustum.js","../src/three/renderer/tiles/TilesRenderer.js","../src/three/renderer/controls/PivotPointMesh.js","../src/three/renderer/controls/PointerTracker.js","../src/three/renderer/controls/utils.js","../src/three/renderer/controls/EnvironmentControls.js","../src/three/renderer/controls/GlobeControls.js","../src/three/renderer/controls/CameraTransitionManager.js"],"sourcesContent":["import { B3DMLoaderBase } from '3d-tiles-renderer/core';\nimport { DefaultLoadingManager, Matrix4 } from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nexport class B3DMLoader extends B3DMLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.adjustmentTransform = new Matrix4();\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst b3dm = super.parse( buffer );\n\t\tconst gltfBuffer = b3dm.glbBytes.slice().buffer;\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tconst manager = this.manager;\n\t\t\tconst fetchOptions = this.fetchOptions;\n\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || new GLTFLoader( manager );\n\n\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t}\n\n\t\t\tif ( 'credentials' in fetchOptions ) {\n\n\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\n\t\t\t}\n\n\t\t\tif ( fetchOptions.headers ) {\n\n\t\t\t\tloader.setRequestHeader( fetchOptions.headers );\n\n\t\t\t}\n\n\t\t\t// GLTFLoader assumes the working path ends in a slash\n\t\t\tlet workingPath = this.workingPath;\n\t\t\tif ( ! /[\\\\/]$/.test( workingPath ) && workingPath.length ) {\n\n\t\t\t\tworkingPath += '/';\n\n\t\t\t}\n\n\t\t\tconst adjustmentTransform = this.adjustmentTransform;\n\n\t\t\tloader.parse( gltfBuffer, workingPath, model => {\n\n\t\t\t\tconst { batchTable, featureTable } = b3dm;\n\t\t\t\tconst { scene } = model;\n\n\t\t\t\tconst rtcCenter = featureTable.getData( 'RTC_CENTER', 1, 'FLOAT', 'VEC3' );\n\t\t\t\tif ( rtcCenter ) {\n\n\t\t\t\t\tscene.position.x += rtcCenter[ 0 ];\n\t\t\t\t\tscene.position.y += rtcCenter[ 1 ];\n\t\t\t\t\tscene.position.z += rtcCenter[ 2 ];\n\n\t\t\t\t}\n\n\t\t\t\tmodel.scene.updateMatrix();\n\t\t\t\tmodel.scene.matrix.multiply( adjustmentTransform );\n\t\t\t\tmodel.scene.matrix.decompose( model.scene.position, model.scene.quaternion, model.scene.scale );\n\n\t\t\t\tmodel.batchTable = batchTable;\n\t\t\t\tmodel.featureTable = featureTable;\n\n\t\t\t\tscene.batchTable = batchTable;\n\t\t\t\tscene.featureTable = featureTable;\n\n\t\t\t\tresolve( model );\n\n\t\t\t}, reject );\n\n\t\t} );\n\n\t}\n\n}\n","// The implementation of rgb565 to rgb888 is from\n// https://rgbcolorpicker.com/565\n\nexport function rgb565torgb( rgb565 ) {\n\n\t// Shift the red value to the right by 11 bits.\n\tconst red5 = rgb565 >> 11;\n\t// Shift the green value to the right by 5 bits and extract the lower 6 bits.\n\tconst green6 = ( rgb565 >> 5 ) & 0b111111;\n\t// Extract the lower 5 bits.\n\tconst blue5 = rgb565 & 0b11111;\n\n\t// Convert 5-bit red to 8-bit red.\n\tconst red8 = Math.round( ( red5 / 31 ) * 255 );\n\t// Convert 6-bit green to 8-bit green.\n\tconst green8 = Math.round( ( green6 / 63 ) * 255 );\n\t// Convert 5-bit blue to 8-bit blue.\n\tconst blue8 = Math.round( ( blue5 / 31 ) * 255 );\n\n\treturn [ red8, green8, blue8 ];\n\n}\n","import { Vector2, MathUtils, Vector3 } from 'three';\n\nconst f = /* @__PURE__ */ new Vector2();\n\n/**\n * Decode an octahedron-encoded normal (as a pair of 8-bit unsigned numbers) into a Vector3.\n *\n * Resources:\n * - https://stackoverflow.com/a/74745666/2704779\n * - https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/\n * @param {number} x The unsigned 8-bit X coordinate on the projected octahedron.\n * @param {number} y The unsigned 8-bit Y coordinate on the projected octahedron.\n * @param {Vector3} [target] The target vector.\n */\nexport function decodeOctNormal( x, y, target = new Vector3() ) {\n\n\tf.set( x, y ).divideScalar( 256 ).multiplyScalar( 2 ).subScalar( 1 );\n\n\ttarget.set( f.x, f.y, 1 - Math.abs( f.x ) - Math.abs( f.y ) );\n\n\tconst t = MathUtils.clamp( - target.z, 0, 1 );\n\n\tif ( target.x >= 0 ) {\n\n\t\ttarget.setX( target.x - t );\n\n\t} else {\n\n\t\ttarget.setX( target.x + t );\n\n\t}\n\n\tif ( target.y >= 0 ) {\n\n\t\ttarget.setY( target.y - t );\n\n\t} else {\n\n\t\ttarget.setY( target.y + t );\n\n\t}\n\n\ttarget.normalize();\n\n\treturn target;\n\n}\n","import { PNTSLoaderBase } from '3d-tiles-renderer/core';\nimport {\n\tPoints,\n\tPointsMaterial,\n\tBufferGeometry,\n\tBufferAttribute,\n\tDefaultLoadingManager,\n\tVector3,\n\tColor,\n} from 'three';\nimport { rgb565torgb } from './rgb565torgb.js';\nimport { decodeOctNormal } from './decodeOctNormal.js';\n\nconst DRACO_ATTRIBUTE_MAP = {\n\tRGB: 'color',\n\tPOSITION: 'position',\n};\n\nexport class PNTSLoader extends PNTSLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\n\t}\n\n\tparse( buffer ) {\n\n\t\treturn super.parse( buffer ).then( async ( result ) => {\n\n\t\t\tconst { featureTable, batchTable } = result;\n\n\t\t\tconst material = new PointsMaterial();\n\t\t\tconst extensions = featureTable.header.extensions;\n\t\t\tconst translationOffset = new Vector3();\n\t\t\tlet geometry;\n\n\t\t\t// handle loading the draco data\n\t\t\tif ( extensions && extensions[ '3DTILES_draco_point_compression' ] ) {\n\n\t\t\t\tconst { byteOffset, byteLength, properties } = extensions[ '3DTILES_draco_point_compression' ];\n\t\t\t\tconst dracoLoader = this.manager.getHandler( 'draco.drc' );\n\t\t\t\tif ( dracoLoader == null ) {\n\n\t\t\t\t\tthrow new Error( 'PNTSLoader: dracoLoader not available.' );\n\n\t\t\t\t}\n\n\t\t\t\t// map PNTS keys to draco types\n\t\t\t\tconst attributeIDs = {};\n\t\t\t\tfor ( const key in properties ) {\n\n\t\t\t\t\tif ( key in DRACO_ATTRIBUTE_MAP && key in properties ) {\n\n\t\t\t\t\t\tconst mappedKey = DRACO_ATTRIBUTE_MAP[ key ];\n\t\t\t\t\t\tattributeIDs[ mappedKey ] = properties[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// decode the geometry\n\t\t\t\tconst taskConfig = {\n\t\t\t\t\tattributeIDs,\n\t\t\t\t\tattributeTypes: {\n\t\t\t\t\t\tposition: 'Float32Array',\n\t\t\t\t\t\tcolor: 'Uint8Array',\n\t\t\t\t\t},\n\t\t\t\t\tuseUniqueIDs: true,\n\t\t\t\t};\n\n\t\t\t\tconst buffer = featureTable.getBuffer( byteOffset, byteLength );\n\t\t\t\tgeometry = await dracoLoader.decodeGeometry( buffer, taskConfig );\n\t\t\t\tif ( geometry.attributes.color ) {\n\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle non compressed case\n\t\t\t\tconst POINTS_LENGTH = featureTable.getData( 'POINTS_LENGTH' );\n\t\t\t\tconst POSITION = featureTable.getData( 'POSITION', POINTS_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\tconst NORMAL = featureTable.getData( 'NORMAL', POINTS_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\tconst NORMAL_OCT16P = featureTable.getData( 'NORMAL', POINTS_LENGTH, 'UNSIGNED_BYTE', 'VEC2' );\n\t\t\t\tconst RGB = featureTable.getData( 'RGB', POINTS_LENGTH, 'UNSIGNED_BYTE', 'VEC3' );\n\t\t\t\tconst RGBA = featureTable.getData( 'RGBA', POINTS_LENGTH, 'UNSIGNED_BYTE', 'VEC4' );\n\t\t\t\tconst RGB565 = featureTable.getData( 'RGB565', POINTS_LENGTH, 'UNSIGNED_SHORT', 'SCALAR' );\n\t\t\t\tconst CONSTANT_RGBA = featureTable.getData( 'CONSTANT_RGBA', POINTS_LENGTH, 'UNSIGNED_BYTE', 'VEC4' );\n\t\t\t\tconst POSITION_QUANTIZED = featureTable.getData( 'POSITION_QUANTIZED', POINTS_LENGTH, 'UNSIGNED_SHORT', 'VEC3' );\n\t\t\t\tconst QUANTIZED_VOLUME_SCALE = featureTable.getData( 'QUANTIZED_VOLUME_SCALE', POINTS_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\tconst QUANTIZED_VOLUME_OFFSET = featureTable.getData( 'QUANTIZED_VOLUME_OFFSET', POINTS_LENGTH, 'FLOAT', 'VEC3' );\n\n\t\t\t\tgeometry = new BufferGeometry();\n\n\t\t\t\tif ( POSITION_QUANTIZED ) {\n\n\t\t\t\t\tconst decodedPositions = new Float32Array( POINTS_LENGTH * 3 );\n\t\t\t\t\tfor ( let i = 0; i < POINTS_LENGTH; i ++ ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = 3 * i + j;\n\t\t\t\t\t\t\tdecodedPositions[ index ] = ( POSITION_QUANTIZED[ index ] / 65535.0 ) * QUANTIZED_VOLUME_SCALE[ j ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttranslationOffset.x = QUANTIZED_VOLUME_OFFSET[ 0 ];\n\t\t\t\t\ttranslationOffset.y = QUANTIZED_VOLUME_OFFSET[ 1 ];\n\t\t\t\t\ttranslationOffset.z = QUANTIZED_VOLUME_OFFSET[ 2 ];\n\t\t\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( decodedPositions, 3, false ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( POSITION, 3, false ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( NORMAL !== null ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( NORMAL, 3, false ) );\n\n\t\t\t\t} else if ( NORMAL_OCT16P !== null ) {\n\n\t\t\t\t\tconst decodedNormals = new Float32Array( POINTS_LENGTH * 3 );\n\n\t\t\t\t\tconst n = new Vector3();\n\n\t\t\t\t\tfor ( let i = 0; i < POINTS_LENGTH; i ++ ) {\n\n\t\t\t\t\t\tconst x = NORMAL_OCT16P[ i * 2 ];\n\t\t\t\t\t\tconst y = NORMAL_OCT16P[ i * 2 + 1 ];\n\n\t\t\t\t\t\tconst normal = decodeOctNormal( x, y, n );\n\n\t\t\t\t\t\tdecodedNormals[ i * 3 ] = normal.x;\n\t\t\t\t\t\tdecodedNormals[ i * 3 + 1 ] = normal.y;\n\t\t\t\t\t\tdecodedNormals[ i * 3 + 2 ] = normal.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( decodedNormals, 3, false ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( RGBA !== null ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( RGBA, 4, true ) );\n\t\t\t\t\tmaterial.vertexColors = true;\n\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\tmaterial.depthWrite = false;\n\n\t\t\t\t} else if ( RGB !== null ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( RGB, 3, true ) );\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t} else if ( RGB565 !== null ) {\n\n\t\t\t\t\tconst color = new Uint8Array( POINTS_LENGTH * 3 );\n\t\t\t\t\tfor ( let i = 0; i < POINTS_LENGTH; i ++ ) {\n\n\t\t\t\t\t\tconst rgbColor = rgb565torgb( RGB565[ i ] );\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = 3 * i + j;\n\t\t\t\t\t\t\tcolor[ index ] = rgbColor[ j ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( color, 3, true ) );\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t} else if ( CONSTANT_RGBA !== null ) {\n\n\t\t\t\t\tconst color = new Color( CONSTANT_RGBA[ 0 ], CONSTANT_RGBA[ 1 ], CONSTANT_RGBA[ 2 ] );\n\t\t\t\t\tmaterial.color = color;\n\t\t\t\t\tconst opacity = CONSTANT_RGBA[ 3 ] / 255;\n\t\t\t\t\tif ( opacity < 1 ) {\n\n\t\t\t\t\t\tmaterial.opacity = opacity;\n\t\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\t\tmaterial.depthWrite = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst object = new Points( geometry, material );\n\t\t\tobject.position.copy( translationOffset );\n\t\t\tresult.scene = object;\n\t\t\tresult.scene.featureTable = featureTable;\n\t\t\tresult.scene.batchTable = batchTable;\n\n\t\t\tconst rtcCenter = featureTable.getData( 'RTC_CENTER', 1, 'FLOAT', 'VEC3' );\n\t\t\tif ( rtcCenter ) {\n\n\t\t\t\tresult.scene.position.x += rtcCenter[ 0 ];\n\t\t\t\tresult.scene.position.y += rtcCenter[ 1 ];\n\t\t\t\tresult.scene.position.z += rtcCenter[ 2 ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t} );\n\n\t}\n\n}\n","import { I3DMLoaderBase } from '3d-tiles-renderer/core';\nimport { DefaultLoadingManager, Matrix4, InstancedMesh, Vector3, Quaternion } from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\n\nconst tempFwd = /* @__PURE__ */ new Vector3();\nconst tempUp = /* @__PURE__ */ new Vector3();\nconst tempRight = /* @__PURE__ */ new Vector3();\nconst tempPos = /* @__PURE__ */ new Vector3();\nconst tempQuat = /* @__PURE__ */ new Quaternion();\nconst tempSca = /* @__PURE__ */ new Vector3();\nconst tempMat = /* @__PURE__ */ new Matrix4();\nconst tempMat2 = /* @__PURE__ */ new Matrix4();\n\nconst tempGlobePos = /* @__PURE__ */ new Vector3();\nconst tempEnuFrame = /* @__PURE__ */ new Matrix4();\nconst tempLocalQuat = /* @__PURE__ */ new Quaternion();\nconst tempLatLon = {};\n\n// Oct-encoding helper functions\n// Decode oct-encoded normal from unsigned [0, rangeMax] to normalized vector\n// Based on CesiumJS's AttributeCompression.octDecodeInRange\nfunction octDecodeInRange( x, y, rangeMax, result ) {\n\n\t// Map from unsigned [0, rangeMax] to signed normalized [-1.0, 1.0]\n\tx = ( x / rangeMax ) * 2.0 - 1.0;\n\ty = ( y / rangeMax ) * 2.0 - 1.0;\n\n\tresult.x = x;\n\tresult.y = y;\n\tresult.z = 1.0 - Math.abs( x ) - Math.abs( y );\n\n\tif ( result.z < 0.0 ) {\n\n\t\tconst oldX = result.x;\n\t\tresult.x = ( 1.0 - Math.abs( result.y ) ) * ( oldX >= 0.0 ? 1.0 : - 1.0 );\n\t\tresult.y = ( 1.0 - Math.abs( oldX ) ) * ( result.y >= 0.0 ? 1.0 : - 1.0 );\n\n\t}\n\n\tresult.normalize();\n\treturn result;\n\n}\n\nexport class I3DMLoader extends I3DMLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.adjustmentTransform = new Matrix4();\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\n\t}\n\n\tresolveExternalURL( url ) {\n\n\t\treturn this.manager.resolveURL( super.resolveExternalURL( url ) );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\treturn super\n\t\t\t.parse( buffer )\n\t\t\t.then( i3dm => {\n\n\t\t\t\tconst { featureTable, batchTable } = i3dm;\n\t\t\t\tconst gltfBuffer = i3dm.glbBytes.slice().buffer;\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tconst fetchOptions = this.fetchOptions;\n\t\t\t\t\tconst manager = this.manager;\n\t\t\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || new GLTFLoader( manager );\n\n\t\t\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'credentials' in fetchOptions ) {\n\n\t\t\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( fetchOptions.headers ) {\n\n\t\t\t\t\t\tloader.setRequestHeader( fetchOptions.headers );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// GLTFLoader assumes the working path ends in a slash\n\t\t\t\t\tlet workingPath = i3dm.gltfWorkingPath ?? this.workingPath;\n\t\t\t\t\tif ( ! /[\\\\/]$/.test( workingPath ) ) {\n\n\t\t\t\t\t\tworkingPath += '/';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst adjustmentTransform = this.adjustmentTransform;\n\n\t\t\t\t\tloader.parse( gltfBuffer, workingPath, model => {\n\n\t\t\t\t\t\tconst INSTANCES_LENGTH = featureTable.getData( 'INSTANCES_LENGTH' );\n\t\t\t\t\t\tlet POSITION = featureTable.getData( 'POSITION', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst POSITION_QUANTIZED = featureTable.getData( 'POSITION_QUANTIZED', INSTANCES_LENGTH, 'UNSIGNED_SHORT', 'VEC3' );\n\t\t\t\t\t\tconst QUANTIZED_VOLUME_OFFSET = featureTable.getData( 'QUANTIZED_VOLUME_OFFSET', 1, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst QUANTIZED_VOLUME_SCALE = featureTable.getData( 'QUANTIZED_VOLUME_SCALE', 1, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst NORMAL_UP = featureTable.getData( 'NORMAL_UP', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst NORMAL_RIGHT = featureTable.getData( 'NORMAL_RIGHT', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst NORMAL_UP_OCT32P = featureTable.getData( 'NORMAL_UP_OCT32P', INSTANCES_LENGTH, 'UNSIGNED_SHORT', 'VEC2' );\n\t\t\t\t\t\tconst NORMAL_RIGHT_OCT32P = featureTable.getData( 'NORMAL_RIGHT_OCT32P', INSTANCES_LENGTH, 'UNSIGNED_SHORT', 'VEC2' );\n\t\t\t\t\t\tconst SCALE_NON_UNIFORM = featureTable.getData( 'SCALE_NON_UNIFORM', INSTANCES_LENGTH, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst SCALE = featureTable.getData( 'SCALE', INSTANCES_LENGTH, 'FLOAT', 'SCALAR' );\n\t\t\t\t\t\tconst RTC_CENTER = featureTable.getData( 'RTC_CENTER', 1, 'FLOAT', 'VEC3' );\n\t\t\t\t\t\tconst EAST_NORTH_UP = featureTable.getData( 'EAST_NORTH_UP' );\n\n\t\t\t\t\t\t// use quantized position if position is missing\n\t\t\t\t\t\tif ( ! POSITION && POSITION_QUANTIZED ) {\n\n\t\t\t\t\t\t\tPOSITION = new Float32Array( INSTANCES_LENGTH * 3 );\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < INSTANCES_LENGTH; i ++ ) {\n\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 0 ] = QUANTIZED_VOLUME_OFFSET[ 0 ] + ( POSITION_QUANTIZED[ i * 3 + 0 ] / 65535.0 ) * QUANTIZED_VOLUME_SCALE[ 0 ];\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 1 ] = QUANTIZED_VOLUME_OFFSET[ 1 ] + ( POSITION_QUANTIZED[ i * 3 + 1 ] / 65535.0 ) * QUANTIZED_VOLUME_SCALE[ 1 ];\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 2 ] = QUANTIZED_VOLUME_OFFSET[ 2 ] + ( POSITION_QUANTIZED[ i * 3 + 2 ] / 65535.0 ) * QUANTIZED_VOLUME_SCALE[ 2 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// get the average vector center so we can avoid floating point error due to lower\n\t\t\t\t\t\t// precision transformation calculations on the GPU\n\t\t\t\t\t\tconst averageVector = new Vector3();\n\t\t\t\t\t\tfor ( let i = 0; i < INSTANCES_LENGTH; i ++ ) {\n\n\t\t\t\t\t\t\taverageVector.x += POSITION[ i * 3 + 0 ] / INSTANCES_LENGTH;\n\t\t\t\t\t\t\taverageVector.y += POSITION[ i * 3 + 1 ] / INSTANCES_LENGTH;\n\t\t\t\t\t\t\taverageVector.z += POSITION[ i * 3 + 2 ] / INSTANCES_LENGTH;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find all the children and create associated instance meshes\n\t\t\t\t\t\tconst instances = [];\n\t\t\t\t\t\tconst meshes = [];\n\t\t\t\t\t\tmodel.scene.updateMatrixWorld();\n\n\t\t\t\t\t\tmodel.scene.traverse( child => {\n\n\t\t\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\t\t\tmeshes.push( child );\n\n\t\t\t\t\t\t\t\tconst { geometry, material } = child;\n\t\t\t\t\t\t\t\tconst instancedMesh = new InstancedMesh( geometry, material, INSTANCES_LENGTH );\n\t\t\t\t\t\t\t\tinstancedMesh.position.copy( averageVector );\n\n\t\t\t\t\t\t\t\tif ( RTC_CENTER ) {\n\n\t\t\t\t\t\t\t\t\tinstancedMesh.position.x += RTC_CENTER[ 0 ];\n\t\t\t\t\t\t\t\t\tinstancedMesh.position.y += RTC_CENTER[ 1 ];\n\t\t\t\t\t\t\t\t\tinstancedMesh.position.z += RTC_CENTER[ 2 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tinstances.push( instancedMesh );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// generate positions for all instances\n\t\t\t\t\t\tfor ( let i = 0; i < INSTANCES_LENGTH; i ++ ) {\n\n\t\t\t\t\t\t\t// position\n\t\t\t\t\t\t\ttempPos.set(\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 0 ] - averageVector.x,\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 1 ] - averageVector.y,\n\t\t\t\t\t\t\t\tPOSITION[ i * 3 + 2 ] - averageVector.z,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// rotation\n\t\t\t\t\t\t\ttempQuat.identity();\n\n\t\t\t\t\t\t\t// account for EAST_NORTH_UP per-instance below\n\n\t\t\t\t\t\t\t// Use NORMAL_UP and NORMAL_RIGHT if available (higher precision)\n\t\t\t\t\t\t\t// Otherwise fall back to oct-encoded normals\n\t\t\t\t\t\t\tif ( NORMAL_UP && NORMAL_RIGHT ) {\n\n\t\t\t\t\t\t\t\ttempUp.set(\n\t\t\t\t\t\t\t\t\tNORMAL_UP[ i * 3 + 0 ],\n\t\t\t\t\t\t\t\t\tNORMAL_UP[ i * 3 + 1 ],\n\t\t\t\t\t\t\t\t\tNORMAL_UP[ i * 3 + 2 ],\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempRight.set(\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT[ i * 3 + 0 ],\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT[ i * 3 + 1 ],\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT[ i * 3 + 2 ],\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempFwd.crossVectors( tempRight, tempUp )\n\t\t\t\t\t\t\t\t\t.normalize();\n\n\t\t\t\t\t\t\t\ttempMat.makeBasis(\n\t\t\t\t\t\t\t\t\ttempRight,\n\t\t\t\t\t\t\t\t\ttempUp,\n\t\t\t\t\t\t\t\t\ttempFwd,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempQuat.setFromRotationMatrix( tempMat );\n\n\t\t\t\t\t\t\t} else if ( NORMAL_UP_OCT32P && NORMAL_RIGHT_OCT32P ) {\n\n\t\t\t\t\t\t\t\t// Decode oct-encoded normals\n\t\t\t\t\t\t\t\toctDecodeInRange(\n\t\t\t\t\t\t\t\t\tNORMAL_UP_OCT32P[ i * 2 + 0 ],\n\t\t\t\t\t\t\t\t\tNORMAL_UP_OCT32P[ i * 2 + 1 ],\n\t\t\t\t\t\t\t\t\t65535,\n\t\t\t\t\t\t\t\t\ttempUp\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\toctDecodeInRange(\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT_OCT32P[ i * 2 + 0 ],\n\t\t\t\t\t\t\t\t\tNORMAL_RIGHT_OCT32P[ i * 2 + 1 ],\n\t\t\t\t\t\t\t\t\t65535,\n\t\t\t\t\t\t\t\t\ttempRight\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempFwd.crossVectors( tempRight, tempUp )\n\t\t\t\t\t\t\t\t\t.normalize();\n\n\t\t\t\t\t\t\t\ttempMat.makeBasis(\n\t\t\t\t\t\t\t\t\ttempRight,\n\t\t\t\t\t\t\t\t\ttempUp,\n\t\t\t\t\t\t\t\t\ttempFwd,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\ttempQuat.setFromRotationMatrix( tempMat );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// scale\n\t\t\t\t\t\t\ttempSca.set( 1, 1, 1 );\n\n\t\t\t\t\t\t\tif ( SCALE_NON_UNIFORM ) {\n\n\t\t\t\t\t\t\t\ttempSca.set(\n\t\t\t\t\t\t\t\t\tSCALE_NON_UNIFORM[ i * 3 + 0 ],\n\t\t\t\t\t\t\t\t\tSCALE_NON_UNIFORM[ i * 3 + 1 ],\n\t\t\t\t\t\t\t\t\tSCALE_NON_UNIFORM[ i * 3 + 2 ],\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( SCALE ) {\n\n\t\t\t\t\t\t\t\ttempSca.multiplyScalar( SCALE[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// multiple in the original meshes world transform\n\t\t\t\t\t\t\tfor ( let j = 0, l = instances.length; j < l; j ++ ) {\n\n\t\t\t\t\t\t\t\tconst instance = instances[ j ];\n\t\t\t\t\t\t\t\ttempLocalQuat.copy( tempQuat );\n\n\t\t\t\t\t\t\t\t// Handle east-north-up frame generation\n\t\t\t\t\t\t\t\tif ( EAST_NORTH_UP ) {\n\n\t\t\t\t\t\t\t\t\tinstance.updateMatrixWorld();\n\n\t\t\t\t\t\t\t\t\t// transform the instance position to global frame and get the rotation from the associated ENU frame.\n\t\t\t\t\t\t\t\t\ttempGlobePos.copy( tempPos ).applyMatrix4( instance.matrixWorld );\n\t\t\t\t\t\t\t\t\tthis.ellipsoid.getPositionToCartographic( tempGlobePos, tempLatLon );\n\t\t\t\t\t\t\t\t\tthis.ellipsoid.getEastNorthUpFrame( tempLatLon.lat, tempLatLon.lon, tempEnuFrame );\n\t\t\t\t\t\t\t\t\ttempLocalQuat.setFromRotationMatrix( tempEnuFrame );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttempMat.compose( tempPos, tempLocalQuat, tempSca ).multiply( adjustmentTransform );\n\n\t\t\t\t\t\t\t\tconst mesh = meshes[ j ];\n\t\t\t\t\t\t\t\ttempMat2.multiplyMatrices( tempMat, mesh.matrixWorld );\n\t\t\t\t\t\t\t\tinstance.setMatrixAt( i, tempMat2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// replace all geometry with the instances\n\t\t\t\t\t\tmodel.scene.clear();\n\t\t\t\t\t\tmodel.scene.add( ...instances );\n\n\t\t\t\t\t\tmodel.batchTable = batchTable;\n\t\t\t\t\t\tmodel.featureTable = featureTable;\n\n\t\t\t\t\t\tmodel.scene.batchTable = batchTable;\n\t\t\t\t\t\tmodel.scene.featureTable = featureTable;\n\n\t\t\t\t\t\tresolve( model );\n\n\t\t\t\t\t}, reject );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t}\n\n}\n","import { Group, DefaultLoadingManager, Matrix4 } from 'three';\nimport { CMPTLoaderBase } from '3d-tiles-renderer/core';\nimport { B3DMLoader } from './B3DMLoader.js';\nimport { PNTSLoader } from './PNTSLoader.js';\nimport { I3DMLoader } from './I3DMLoader.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\n\nexport class CMPTLoader extends CMPTLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.adjustmentTransform = new Matrix4();\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst result = super.parse( buffer );\n\t\tconst { manager, ellipsoid, adjustmentTransform } = this;\n\t\tconst promises = [];\n\n\t\tfor ( const i in result.tiles ) {\n\n\t\t\tconst { type, buffer } = result.tiles[ i ];\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'b3dm': {\n\n\t\t\t\t\tconst slicedBuffer = buffer.slice();\n\t\t\t\t\tconst loader = new B3DMLoader( manager );\n\t\t\t\t\tloader.workingPath = this.workingPath;\n\t\t\t\t\tloader.fetchOptions = this.fetchOptions;\n\t\t\t\t\tloader.adjustmentTransform.copy( adjustmentTransform );\n\n\t\t\t\t\tconst promise = loader.parse( slicedBuffer.buffer );\n\t\t\t\t\tpromises.push( promise );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcase 'pnts': {\n\n\t\t\t\t\tconst slicedBuffer = buffer.slice();\n\t\t\t\t\tconst loader = new PNTSLoader( manager );\n\t\t\t\t\tloader.workingPath = this.workingPath;\n\t\t\t\t\tloader.fetchOptions = this.fetchOptions;\n\n\t\t\t\t\tconst promise = loader.parse( slicedBuffer.buffer );\n\t\t\t\t\tpromises.push( promise );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcase 'i3dm': {\n\n\t\t\t\t\tconst slicedBuffer = buffer.slice();\n\t\t\t\t\tconst loader = new I3DMLoader( manager );\n\t\t\t\t\tloader.workingPath = this.workingPath;\n\t\t\t\t\tloader.fetchOptions = this.fetchOptions;\n\n\t\t\t\t\tloader.ellipsoid.copy( ellipsoid );\n\t\t\t\t\tloader.adjustmentTransform.copy( adjustmentTransform );\n\n\t\t\t\t\tconst promise = loader.parse( slicedBuffer.buffer );\n\t\t\t\t\tpromises.push( promise );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( promises ).then( results => {\n\n\t\t\tconst group = new Group();\n\t\t\tresults.forEach( result => {\n\n\t\t\t\tgroup.add( result.scene );\n\n\t\t\t} );\n\n\t\t\treturn {\n\n\t\t\t\ttiles: results,\n\t\t\t\tscene: group,\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n}\n","import { Group, Matrix4 } from 'three';\n\n// Specialization of \"Group\" that only updates world matrices of children if\n// the transform has changed since the last update and ignores the \"force\"\n// parameter under the assumption that the children tiles will not move.\nconst tempMat = /* @__PURE__ */ new Matrix4();\nexport class TilesGroup extends Group {\n\n\tconstructor( tilesRenderer ) {\n\n\t\tsuper();\n\t\tthis.isTilesGroup = true;\n\t\tthis.name = 'TilesRenderer.TilesGroup';\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\t// returning \"false\" ends raycast traversal\n\t\tif ( this.tilesRenderer.optimizeRaycast ) {\n\n\t\t\tthis.tilesRenderer.raycast( raycaster, intersects );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) {\n\n\t\t\tthis.updateMatrix();\n\n\t\t}\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\ttempMat.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\ttempMat.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t// check if the matrix changed relative to what it was.\n\t\t\tconst elA = tempMat.elements;\n\t\t\tconst elB = this.matrixWorld.elements;\n\t\t\tlet isDifferent = false;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\tconst itemA = elA[ i ];\n\t\t\t\tconst itemB = elB[ i ];\n\t\t\t\tconst diff = Math.abs( itemA - itemB );\n\n\t\t\t\tif ( diff > Number.EPSILON ) {\n\n\t\t\t\t\tisDifferent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isDifferent ) {\n\n\t\t\t\tthis.matrixWorld.copy( tempMat );\n\t\t\t\tthis.matrixWorldInverse.copy( tempMat ).invert();\n\n\t\t\t\t// update children\n\t\t\t\t// the children will not have to change unless the parent group has updated\n\t\t\t\tconst children = this.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tchildren[ i ].updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tif ( this.parent && updateParents ) {\n\n\t\t\tthis.parent.updateWorldMatrix( updateParents, false );\n\n\t\t}\n\n\t\t// run the normal update function to ensure children and inverse matrices are in sync\n\t\tthis.updateMatrixWorld( true );\n\n\t}\n\n}\n","import { Ray, Vector3 } from 'three';\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst _localRay = /* @__PURE__ */ new Ray();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _hitArray = [];\n\nfunction distanceSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectTileScene( tile, raycaster, renderer, intersects ) {\n\n\tconst { scene } = tile.engineData;\n\tconst didRaycast = renderer.invokeOnePlugin( plugin => plugin.raycastTile && plugin.raycastTile( tile, scene, raycaster, intersects ) );\n\tif ( ! didRaycast ) {\n\n\t\traycaster.intersectObject( scene, true, intersects );\n\n\t}\n\n}\n\nfunction intersectTileSceneFirstHist( tile, raycaster, renderer ) {\n\n\tintersectTileScene( tile, raycaster, renderer, _hitArray );\n\t_hitArray.sort( distanceSort );\n\n\tconst hit = _hitArray[ 0 ] || null;\n\t_hitArray.length = 0;\n\treturn hit;\n\n}\n\nfunction isTileInitialized( tile ) {\n\n\treturn 'traversal' in tile;\n\n}\n\n// Returns the closest hit when traversing the tree\nexport function raycastTraverseFirstHit( renderer, tile, raycaster, localRay = null ) {\n\n\tconst { group, activeTiles } = renderer;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// get a set of intersections so we intersect the nearest one first\n\tconst array = [];\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst child = children[ i ];\n\t\tif ( ! isTileInitialized( child ) || ! child.traversal.used ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// track the tile and hit distance for sorting\n\t\tconst boundingVolume = child.engineData.boundingVolume;\n\t\tif ( boundingVolume.intersectRay( localRay, _vec ) !== null ) {\n\n\t\t\t_vec.applyMatrix4( group.matrixWorld );\n\t\t\tarray.push( {\n\t\t\t\tdistance: _vec.distanceToSquared( raycaster.ray.origin ),\n\t\t\t\ttile: child,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sort them by ascending distance\n\tarray.sort( distanceSort );\n\n\t// If the root is active make sure we've checked it\n\tlet bestHit = null;\n\tlet bestHitDistSq = Infinity;\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tconst hit = intersectTileSceneFirstHist( tile, raycaster, renderer );\n\t\tif ( hit ) {\n\n\t\t\tbestHit = hit;\n\t\t\tbestHitDistSq = hit.distance * hit.distance;\n\n\t\t}\n\n\t}\n\n\t// traverse until we find the best hit and early out if a tile bounds\n\t// couldn't possible include a best hit\n\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\tconst data = array[ i ];\n\t\tconst boundingVolumeDistSq = data.distance;\n\t\tconst tile = data.tile;\n\t\tif ( boundingVolumeDistSq > bestHitDistSq ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tconst hit = raycastTraverseFirstHit( renderer, tile, raycaster, localRay );\n\t\tif ( hit ) {\n\n\t\t\tconst hitDistSq = hit.distance * hit.distance;\n\t\t\tif ( hitDistSq < bestHitDistSq ) {\n\n\t\t\t\tbestHit = hit;\n\t\t\t\tbestHitDistSq = hitDistSq;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bestHit;\n\n}\n\nexport function raycastTraverse( renderer, tile, raycaster, intersects, localRay = null ) {\n\n\t// if the tile has not been asynchronously initialized then there's no point in\n\t// traversing the tiles to check intersections.\n\tif ( ! isTileInitialized( tile ) ) {\n\n\t\treturn;\n\n\t}\n\n\tconst { group, activeTiles } = renderer;\n\tconst { boundingVolume } = tile.engineData;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// exit early if the tile isn't used or the bounding volume is not intersected\n\tif ( ! tile.traversal.used || ! boundingVolume.intersectsRay( localRay ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// only intersect the tile geometry if it's active\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tintersectTileScene( tile, raycaster, renderer, intersects );\n\n\t}\n\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\traycastTraverse( renderer, children[ i ], raycaster, intersects, localRay );\n\n\t}\n\n}\n","import { Vector3, Sphere } from 'three';\nimport { OBB } from './OBB.js';\nimport { EllipsoidRegion } from './EllipsoidRegion.js';\n\nconst _vecX = /* @__PURE__ */ new Vector3();\nconst _vecY = /* @__PURE__ */ new Vector3();\nconst _vecZ = /* @__PURE__ */ new Vector3();\nconst _sphereVec = /* @__PURE__ */ new Vector3();\nconst _obbVec = /* @__PURE__ */ new Vector3();\n\n// TODO: check region more precisely in all functions\nexport class TileBoundingVolume {\n\n\tconstructor() {\n\n\t\tthis.sphere = null;\n\t\tthis.obb = null;\n\t\tthis.region = null;\n\n\t\tthis.regionObb = null;\n\n\t}\n\n\tintersectsRay( ray ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\t// Early out if we don't hit this tile sphere\n\t\tif ( sphere && ! ray.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Early out if we don't this this tile box\n\t\tif ( obb && ! obb.intersectsRay( ray ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectRay( ray, target = null ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistSq = - Infinity;\n\t\tlet obbDistSq = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\tif ( ray.intersectSphere( sphere, _sphereVec ) ) {\n\n\t\t\t\tsphereDistSq = sphere.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _sphereVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tif ( obb.intersectRay( ray, _obbVec ) ) {\n\n\t\t\t\tobbDistSq = obb.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _obbVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if we didn't hit anything then exit\n\t\tconst furthestDist = Math.max( sphereDistSq, obbDistSq );\n\t\tif ( furthestDist === - Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// get the furthest hit point if needed\n\t\tray.at( Math.sqrt( furthestDist ), target );\n\t\treturn target;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistance = - Infinity;\n\t\tlet obbDistance = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\t// Sphere#distanceToPoint is negative inside the sphere, whereas Box3#distanceToPoint is\n\t\t\t// zero inside the box. Clipping the distance to a minimum of zero ensures that both\n\t\t\t// types of bounding volume behave the same way.\n\t\t\tsphereDistance = Math.max( sphere.distanceToPoint( point ), 0 );\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tobbDistance = obb.distanceToPoint( point );\n\n\t\t}\n\n\t\t// return the further distance of the two volumes\n\t\treturn sphereDistance > obbDistance ? sphereDistance : obbDistance;\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! frustum.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsFrustum( frustum ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// if we don't have a sphere or obb then just say we did intersect\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsSphere( otherSphere ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! sphere.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsOBB( otherObb ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! otherObb.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsOBB( otherObb ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tgetOBB( targetBox, targetMatrix ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tif ( obb ) {\n\n\t\t\ttargetBox.copy( obb.box );\n\t\t\ttargetMatrix.copy( obb.transform );\n\n\t\t} else {\n\n\t\t\tthis.getAABB( targetBox );\n\t\t\ttargetMatrix.identity();\n\n\t\t}\n\n\t}\n\n\tgetAABB( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\tthis.sphere.getBoundingBox( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\ttarget.copy( obb.box ).applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tgetSphere( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\ttarget.copy( this.sphere );\n\n\t\t} else if ( this.region ) {\n\n\t\t\tthis.region.getBoundingSphere( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\tobb.box.getBoundingSphere( target );\n\t\t\ttarget.applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tsetObbData( data, transform ) {\n\n\t\tconst obb = new OBB();\n\n\t\t// get the extents of the bounds in each axis\n\t\t_vecX.set( data[ 3 ], data[ 4 ], data[ 5 ] );\n\t\t_vecY.set( data[ 6 ], data[ 7 ], data[ 8 ] );\n\t\t_vecZ.set( data[ 9 ], data[ 10 ], data[ 11 ] );\n\n\t\tconst scaleX = _vecX.length();\n\t\tconst scaleY = _vecY.length();\n\t\tconst scaleZ = _vecZ.length();\n\n\t\t_vecX.normalize();\n\t\t_vecY.normalize();\n\t\t_vecZ.normalize();\n\n\t\t// handle the case where the box has a dimension of 0 in one axis\n\t\tif ( scaleX === 0 ) {\n\n\t\t\t_vecX.crossVectors( _vecY, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleY === 0 ) {\n\n\t\t\t_vecY.crossVectors( _vecX, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleZ === 0 ) {\n\n\t\t\t_vecZ.crossVectors( _vecX, _vecY );\n\n\t\t}\n\n\t\t// create the oriented frame that the box exists in\n\t\tobb.transform\n\t\t\t.set(\n\t\t\t\t_vecX.x, _vecY.x, _vecZ.x, data[ 0 ],\n\t\t\t\t_vecX.y, _vecY.y, _vecZ.y, data[ 1 ],\n\t\t\t\t_vecX.z, _vecY.z, _vecZ.z, data[ 2 ],\n\t\t\t\t0, 0, 0, 1\n\t\t\t)\n\t\t\t.premultiply( transform );\n\n\t\t// scale the box by the extents\n\t\tobb.box.min.set( - scaleX, - scaleY, - scaleZ );\n\t\tobb.box.max.set( scaleX, scaleY, scaleZ );\n\t\tobb.update();\n\t\tthis.obb = obb;\n\n\t}\n\n\tsetSphereData( x, y, z, radius, transform ) {\n\n\t\tconst sphere = new Sphere();\n\t\tsphere.center.set( x, y, z );\n\t\tsphere.radius = radius;\n\t\tsphere.applyMatrix4( transform );\n\t\tthis.sphere = sphere;\n\n\t}\n\n\tsetRegionData( ellipsoid, west, south, east, north, minHeight, maxHeight ) {\n\n\t\tconst region = new EllipsoidRegion(\n\t\t\t...ellipsoid.radius,\n\t\t\tsouth, north,\n\t\t\twest, east,\n\t\t\tminHeight, maxHeight,\n\t\t);\n\n\t\tconst obb = new OBB();\n\t\tregion.getBoundingBox( obb.box, obb.transform );\n\t\tobb.update();\n\n\t\tthis.region = region;\n\t\tthis.regionObb = obb;\n\n\t}\n\n}\n","import { Frustum, Matrix3, Vector3 } from 'three';\n\nconst _mat3 = /* @__PURE__ */ new Matrix3();\n\n// Solve a system of equations to find the point where the three planes intersect\nfunction findIntersectionPoint( plane1, plane2, plane3, target ) {\n\n\t// Create the matrix A using the normals of the planes as rows\n\tconst A = _mat3.set(\n\t\tplane1.normal.x, plane1.normal.y, plane1.normal.z,\n\t\tplane2.normal.x, plane2.normal.y, plane2.normal.z,\n\t\tplane3.normal.x, plane3.normal.y, plane3.normal.z\n\t);\n\n\t// Create the vector B using the constants of the planes\n\ttarget.set( - plane1.constant, - plane2.constant, - plane3.constant );\n\n\t// Solve for X by applying the inverse matrix to B\n\ttarget.applyMatrix3( A.invert() );\n\n\treturn target;\n\n}\n\nclass ExtendedFrustum extends Frustum {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.points = Array( 8 ).fill().map( () => new Vector3() );\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem ) {\n\n\t\tsuper.setFromProjectionMatrix( m, coordinateSystem );\n\t\tthis.calculateFrustumPoints();\n\t\treturn this;\n\n\t}\n\n\tcalculateFrustumPoints() {\n\n\t\tconst { planes, points } = this;\n\t\tconst planeIntersections = [\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 4 ] ], // Near top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 4 ] ], // Near top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 4 ] ], // Near bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 4 ] ], // Near bottom right\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 5 ] ], // Far top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 5 ] ], // Far top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 5 ] ], // Far bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 5 ] ], // Far bottom right\n\t\t];\n\n\t\tplaneIntersections.forEach( ( planes, index ) => {\n\n\t\t\tfindIntersectionPoint( planes[ 0 ], planes[ 1 ], planes[ 2 ], points[ index ] );\n\n\t\t} );\n\n\t}\n\n}\n\nexport { ExtendedFrustum };\n","import { TilesRendererBase, LoaderUtils } from '3d-tiles-renderer/core';\nimport { B3DMLoader } from '../loaders/B3DMLoader.js';\nimport { PNTSLoader } from '../loaders/PNTSLoader.js';\nimport { I3DMLoader } from '../loaders/I3DMLoader.js';\nimport { CMPTLoader } from '../loaders/CMPTLoader.js';\nimport { TilesGroup } from './TilesGroup.js';\nimport {\n\tMatrix4,\n\tVector3,\n\tVector2,\n\tEuler,\n\tLoadingManager,\n\tEventDispatcher,\n\tGroup,\n} from 'three';\nimport { raycastTraverse, raycastTraverseFirstHit } from './raycastTraverse.js';\nimport { TileBoundingVolume } from '../math/TileBoundingVolume.js';\nimport { ExtendedFrustum } from '../math/ExtendedFrustum.js';\nimport { estimateBytesUsed } from '../utils/MemoryUtils.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nconst _mat = /* @__PURE__ */ new Matrix4();\nconst _euler = /* @__PURE__ */ new Euler();\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst INITIAL_FRUSTUM_CULLED = Symbol( 'INITIAL_FRUSTUM_CULLED' );\nconst tempMat = /* @__PURE__ */ new Matrix4();\nconst tempVector = /* @__PURE__ */ new Vector3();\nconst tempVector2 = /* @__PURE__ */ new Vector2();\n\nconst X_AXIS = /* @__PURE__ */ new Vector3( 1, 0, 0 );\nconst Y_AXIS = /* @__PURE__ */ new Vector3( 0, 1, 0 );\n\nfunction updateFrustumCulled( object, toInitialValue ) {\n\n\tobject.traverse( c => {\n\n\t\tc.frustumCulled = c[ INITIAL_FRUSTUM_CULLED ] && toInitialValue;\n\n\t} );\n\n}\n\nexport class TilesRenderer extends TilesRendererBase {\n\n\tget autoDisableRendererCulling() {\n\n\t\treturn this._autoDisableRendererCulling;\n\n\t}\n\n\tset autoDisableRendererCulling( value ) {\n\n\t\tif ( this._autoDisableRendererCulling !== value ) {\n\n\t\t\tsuper._autoDisableRendererCulling = value;\n\t\t\tthis.forEachLoadedModel( ( scene ) => {\n\n\t\t\t\tupdateFrustumCulled( scene, ! value );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tget optimizeRaycast() {\n\n\t\treturn this._optimizeRaycast;\n\n\t}\n\n\tset optimizeRaycast( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"optimizeRaycast\" option has been deprecated.' );\n\t\tthis._optimizeRaycast = v;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.group = new TilesGroup( this );\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.cameras = [];\n\t\tthis.cameraMap = new Map();\n\t\tthis.cameraInfo = [];\n\t\tthis._optimizeRaycast = true;\n\t\tthis._upRotationMatrix = new Matrix4();\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\t// flag indicating whether frustum culling should be disabled\n\t\tthis._autoDisableRendererCulling = true;\n\n\t\tthis.manager = new LoadingManager();\n\n\t\t// saved for event dispatcher functions\n\t\tthis._listeners = {};\n\n\t}\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\tEventDispatcher.prototype.addEventListener.call( this, type, listener );\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\treturn EventDispatcher.prototype.hasEventListener.call( this, type, listener );\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( type === 'load-tile-set' ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: \"load-tile-set\" event has been deprecated. Use \"load-tileset\" instead.' );\n\t\t\ttype = 'load-tileset';\n\n\t\t}\n\n\t\tEventDispatcher.prototype.removeEventListener.call( this, type, listener );\n\n\t}\n\n\tdispatchEvent( e ) {\n\n\t\tif ( 'tileset' in e ) {\n\n\t\t\tObject.defineProperty( e, 'tileSet', {\n\t\t\t\tget() {\n\n\t\t\t\t\tconsole.warn( 'TilesRenderer: \"event.tileSet\" has been deprecated. Use \"event.tileset\" instead.' );\n\t\t\t\t\treturn e.tileset;\n\n\t\t\t\t},\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t} );\n\n\t\t}\n\n\t\tEventDispatcher.prototype.dispatchEvent.call( this, e );\n\n\t}\n\n\t/* Public API */\n\tgetBoundingBox( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.engineData.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getAABB( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetOrientedBoundingBox( targetBox, targetMatrix ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.engineData.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getOBB( targetBox, targetMatrix );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.engineData.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getSphere( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tforEachLoadedModel( callback ) {\n\n\t\tthis.traverse( tile => {\n\n\t\t\tconst scene = tile.engineData && tile.engineData.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tcallback( scene, tile );\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( raycaster.firstHitOnly ) {\n\n\t\t\tconst hit = raycastTraverseFirstHit( this, this.root, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\traycastTraverse( this, this.root, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\thasCamera( camera ) {\n\n\t\treturn this.cameraMap.has( camera );\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\tcameraMap.set( camera, new Vector2() );\n\t\t\tcameras.push( camera );\n\t\t\tthis.dispatchEvent( { type: 'add-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tsetResolution( camera, xOrVec, y ) {\n\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst width = xOrVec.isVector2 ? xOrVec.x : xOrVec;\n\t\tconst height = xOrVec.isVector2 ? xOrVec.y : y;\n\t\tconst cameraVec = cameraMap.get( camera );\n\n\t\tif ( cameraVec.width !== width || cameraVec.height !== height ) {\n\n\t\t\tcameraVec.set( width, height );\n\t\t\tthis.dispatchEvent( { type: 'camera-resolution-change' } );\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tsetResolutionFromRenderer( camera, renderer ) {\n\n\t\trenderer.getSize( tempVector2 );\n\n\t\treturn this.setResolution( camera, tempVector2.x, tempVector2.y );\n\n\t}\n\n\tdeleteCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( cameraMap.has( camera ) ) {\n\n\t\t\tconst index = cameras.indexOf( camera );\n\t\t\tcameras.splice( index, 1 );\n\t\t\tcameraMap.delete( camera );\n\t\t\tthis.dispatchEvent( { type: 'delete-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/* Overriden */\n\tloadRootTileset( ...args ) {\n\n\t\treturn super.loadRootTileset( ...args )\n\t\t\t.then( root => {\n\n\t\t\t\t// cache the gltf tileset rotation matrix\n\t\t\t\tconst { asset, extensions = {} } = root;\n\t\t\t\tconst upAxis = asset && asset.gltfUpAxis || 'y';\n\t\t\t\tswitch ( upAxis.toLowerCase() ) {\n\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( Y_AXIS, - Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( X_AXIS, Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// update the ellipsoid based on the extension\n\t\t\t\tif ( '3DTILES_ellipsoid' in extensions ) {\n\n\t\t\t\t\tconst ext = extensions[ '3DTILES_ellipsoid' ];\n\t\t\t\t\tconst { ellipsoid } = this;\n\t\t\t\t\tellipsoid.name = ext.body;\n\t\t\t\t\tif ( ext.radii ) {\n\n\t\t\t\t\t\tellipsoid.radius.set( ...ext.radii );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tellipsoid.radius.set( 1, 1, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t}\n\n\tprepareForTraversal() {\n\n\t\tconst group = this.group;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tconst cameraInfo = this.cameraInfo;\n\n\t\t// automatically scale the array of cameraInfo to match the cameras\n\t\twhile ( cameraInfo.length > cameras.length ) {\n\n\t\t\tcameraInfo.pop();\n\n\t\t}\n\n\t\twhile ( cameraInfo.length < cameras.length ) {\n\n\t\t\tcameraInfo.push( {\n\n\t\t\t\tfrustum: new ExtendedFrustum(),\n\t\t\t\tisOrthographic: false,\n\t\t\t\tsseDenominator: - 1, // used if isOrthographic:false\n\t\t\t\tposition: new Vector3(),\n\t\t\t\tinvScale: - 1,\n\t\t\t\tpixelSize: 0, // used if isOrthographic:true\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// extract scale of group container\n\t\ttempVector.setFromMatrixScale( group.matrixWorldInverse );\n\t\tif ( Math.abs( Math.max( tempVector.x - tempVector.y, tempVector.x - tempVector.z ) ) > 1e-6 ) {\n\n\t\t\tconsole.warn( 'ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.' );\n\n\t\t}\n\n\t\t// store the camera cameraInfo in the 3d tiles root frame\n\t\tfor ( let i = 0, l = cameraInfo.length; i < l; i ++ ) {\n\n\t\t\tconst camera = cameras[ i ];\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tconst frustum = info.frustum;\n\t\t\tconst position = info.position;\n\t\t\tconst resolution = cameraMap.get( camera );\n\n\t\t\tif ( resolution.width === 0 || resolution.height === 0 ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: resolution for camera error calculation is not set.' );\n\n\t\t\t}\n\n\t\t\t// Read the calculated projection matrix directly to support custom Camera implementations\n\t\t\tconst projection = camera.projectionMatrix.elements;\n\n\t\t\t// The last element of the projection matrix is 1 for orthographic, 0 for perspective\n\t\t\tinfo.isOrthographic = projection[ 15 ] === 1;\n\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\t// See OrthographicCamera.updateProjectionMatrix and Matrix4.makeOrthographic:\n\t\t\t\t// the view width and height are used to populate matrix elements 0 and 5.\n\t\t\t\tconst w = 2 / projection[ 0 ];\n\t\t\t\tconst h = 2 / projection[ 5 ];\n\t\t\t\tinfo.pixelSize = Math.max( h / resolution.height, w / resolution.width );\n\n\t\t\t} else {\n\n\t\t\t\t// See PerspectiveCamera.updateProjectionMatrix and Matrix4.makePerspective:\n\t\t\t\t// the vertical FOV is used to populate matrix element 5.\n\t\t\t\tinfo.sseDenominator = ( 2 / projection[ 5 ] ) / resolution.height;\n\n\t\t\t}\n\n\t\t\t// get frustum in group root frame\n\t\t\ttempMat.copy( group.matrixWorld );\n\t\t\ttempMat.premultiply( camera.matrixWorldInverse );\n\t\t\ttempMat.premultiply( camera.projectionMatrix );\n\n\t\t\tfrustum.setFromProjectionMatrix( tempMat );\n\n\t\t\t// get transform position in group root frame\n\t\t\tposition.set( 0, 0, 0 );\n\t\t\tposition.applyMatrix4( camera.matrixWorld );\n\t\t\tposition.applyMatrix4( group.matrixWorldInverse );\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tsuper.update();\n\n\t\t// check for cameras _after_ base update so we can enable pre-loading the root tileset\n\t\tif ( this.cameras.length === 0 && this.root ) {\n\n\t\t\tlet found = false;\n\t\t\tthis.invokeAllPlugins( plugin => found = found || Boolean( plugin !== this && plugin.calculateTileViewError ) );\n\t\t\tif ( found === false ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: no cameras defined. Cannot update 3d tiles.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tilesetDir, parentTile = null ) {\n\n\t\tsuper.preprocessNode( tile, tilesetDir, parentTile );\n\n\t\tconst transform = new Matrix4();\n\t\tif ( tile.transform ) {\n\n\t\t\tconst transformArr = tile.transform;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransform.elements[ i ] = transformArr[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parentTile ) {\n\n\t\t\ttransform.premultiply( parentTile.engineData.transform );\n\n\t\t}\n\n\t\tconst transformInverse = new Matrix4().copy( transform ).invert();\n\t\tconst boundingVolume = new TileBoundingVolume();\n\t\tif ( 'sphere' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setSphereData( ...tile.boundingVolume.sphere, transform );\n\n\t\t}\n\n\t\tif ( 'box' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setObbData( tile.boundingVolume.box, transform );\n\n\t\t}\n\n\t\tif ( 'region' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setRegionData( this.ellipsoid, ...tile.boundingVolume.region );\n\n\t\t}\n\n\t\t// Extend the base engineData structure with Three.js-specific fields\n\t\t// Base class initializes: scene, metadata, boundingVolume\n\t\ttile.engineData.transform = transform;\n\t\ttile.engineData.transformInverse = transformInverse;\n\t\ttile.engineData.boundingVolume = boundingVolume;\n\t\ttile.engineData.geometry = null;\n\t\ttile.engineData.materials = null;\n\t\ttile.engineData.textures = null;\n\n\t}\n\n\tasync parseTile( buffer, tile, extension, uri, abortSignal ) {\n\n\t\tconst engineData = tile.engineData;\n\t\tconst workingPath = LoaderUtils.getWorkingPath( uri );\n\t\tconst fetchOptions = this.fetchOptions;\n\n\t\tconst manager = this.manager;\n\t\tlet promise = null;\n\n\t\tconst tileTransform = engineData.transform;\n\t\tconst upRotationMatrix = this._upRotationMatrix;\n\t\tconst fileType = ( LoaderUtils.readMagicBytes( buffer ) || extension ).toLowerCase();\n\t\tswitch ( fileType ) {\n\n\t\t\tcase 'b3dm': {\n\n\t\t\t\tconst loader = new B3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'pnts': {\n\n\t\t\t\tconst loader = new PNTSLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'i3dm': {\n\n\t\t\t\tconst loader = new I3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'cmpt': {\n\n\t\t\t\tconst loader = new CMPTLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene\t);\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// 3DTILES_content_gltf\n\t\t\tcase 'gltf':\n\t\t\tcase 'glb': {\n\n\t\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || manager.getHandler( 'path.glb' ) || new GLTFLoader( manager );\n\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\t\t\t\tloader.setRequestHeader( fetchOptions.headers || {} );\n\t\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t\t}\n\n\t\t\t\t// assume any pre-registered loader has paths configured as the user desires, but if we're making\n\t\t\t\t// a new loader, use the working path during parse to support relative uris on other hosts\n\t\t\t\tlet resourcePath = loader.resourcePath || loader.path || workingPath;\n\t\t\t\tif ( ! /[\\\\/]$/.test( resourcePath ) && resourcePath.length ) {\n\n\t\t\t\t\tresourcePath += '/';\n\n\t\t\t\t}\n\n\t\t\t\tpromise = loader.parseAsync( buffer, resourcePath ).then( result => {\n\n\t\t\t\t\t// glTF files are not guaranteed to include a scene object\n\t\t\t\t\tresult.scene = result.scene || new Group();\n\n\t\t\t\t\t// apply the local up-axis correction rotation\n\t\t\t\t\t// GLTFLoader seems to never set a transformation on the root scene object so\n\t\t\t\t\t// any transformations applied to it can be assumed to be applied after load\n\t\t\t\t\t// (such as applying RTC_CENTER) meaning they should happen _after_ the z-up\n\t\t\t\t\t// rotation fix which is why \"multiply\" happens here.\n\t\t\t\t\tconst { scene } = result;\n\t\t\t\t\tscene.updateMatrix();\n\t\t\t\t\tscene.matrix\n\t\t\t\t\t\t.multiply( upRotationMatrix )\n\t\t\t\t\t\t.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t\t\t\treturn result;\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tdefault: {\n\n\t\t\t\tpromise = this.invokeOnePlugin( plugin => plugin.parseToMesh && plugin.parseToMesh( buffer, tile, extension, uri, abortSignal ) );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// wait for the tile to load\n\t\tconst result = await promise;\n\t\tif ( result === null ) {\n\n\t\t\tthrow new Error( `TilesRenderer: Content type \"${ fileType }\" not supported.` );\n\n\t\t}\n\n\t\t// get the scene data\n\t\tlet scene;\n\t\tlet metadata;\n\t\tif ( result.isObject3D ) {\n\n\t\t\tscene = result;\n\t\t\tmetadata = null;\n\n\t\t} else {\n\n\t\t\tscene = result.scene;\n\t\t\tmetadata = result;\n\n\t\t}\n\n\t\t// ensure the matrix is up to date in case the scene has a transform applied\n\t\tscene.updateMatrix();\n\t\tscene.matrix.premultiply( tileTransform );\n\t\tscene.matrix.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t// wait for extra processing by plugins if needed\n\t\tawait this.invokeAllPlugins( plugin => {\n\n\t\t\treturn plugin.processTileModel && plugin.processTileModel( scene, tile );\n\n\t\t} );\n\n\t\t// frustum culling\n\t\tscene.traverse( c => {\n\n\t\t\tc[ INITIAL_FRUSTUM_CULLED ] = c.frustumCulled;\n\n\t\t} );\n\t\tupdateFrustumCulled( scene, ! this.autoDisableRendererCulling );\n\n\t\t// collect all original geometries, materials, etc to be disposed of later\n\t\tconst materials = [];\n\t\tconst geometry = [];\n\t\tconst textures = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.geometry ) {\n\n\t\t\t\tgeometry.push( c.geometry );\n\n\t\t\t}\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tmaterials.push( c.material );\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// exit early if a new request has already started\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\t// dispose of any image bitmaps that have been opened.\n\t\t\t// TODO: share this code with the \"disposeTile\" code below, possibly allow for the tiles\n\t\t\t// renderer base to trigger a disposal of unneeded data\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tengineData.materials = materials;\n\t\tengineData.geometry = geometry;\n\t\tengineData.textures = textures;\n\t\tengineData.scene = scene;\n\t\tengineData.metadata = metadata;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// TODO: call this \"disposeTileModel\"?\n\t\tsuper.disposeTile( tile );\n\n\t\t// This could get called before the tile has finished downloading\n\t\tconst engineData = tile.engineData;\n\t\tif ( engineData.scene ) {\n\n\t\t\tconst materials = engineData.materials;\n\t\t\tconst geometry = engineData.geometry;\n\t\t\tconst textures = engineData.textures;\n\t\t\tconst parent = engineData.scene.parent;\n\n\t\t\t// dispose of any textures required by the mesh features extension\n\t\t\t// TODO: these are being discarded here to remove the image bitmaps -\n\t\t\t// can this be handled in another way? Or more generically?\n\t\t\tengineData.scene.traverse( child => {\n\n\t\t\t\tif ( child.userData.meshFeatures ) {\n\n\t\t\t\t\tchild.userData.meshFeatures.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tif ( child.userData.structuralMetadata ) {\n\n\t\t\t\t\tchild.userData.structuralMetadata.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tfor ( let i = 0, l = geometry.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterials[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tparent.remove( engineData.scene );\n\n\t\t\t}\n\n\t\t\tengineData.scene = null;\n\t\t\tengineData.materials = null;\n\t\t\tengineData.textures = null;\n\t\t\tengineData.geometry = null;\n\t\t\tengineData.metadata = null;\n\n\t\t}\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.engineData.scene;\n\t\tconst group = this.group;\n\n\t\tif ( visible ) {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.add( scene );\n\t\t\t\tscene.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.remove( scene );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsuper.setTileVisible( tile, visible );\n\n\t}\n\n\tcalculateBytesUsed( tile, scene ) {\n\n\t\tconst bytesUsed = this._bytesUsed;\n\t\tif ( ! bytesUsed.has( tile ) && scene ) {\n\n\t\t\tbytesUsed.set( tile, estimateBytesUsed( scene ) );\n\n\t\t}\n\n\t\treturn bytesUsed.get( tile ) ?? null;\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\tconst engineData = tile.engineData;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraInfo = this.cameraInfo;\n\t\tconst boundingVolume = engineData.boundingVolume;\n\n\t\tlet inView = false;\n\t\tlet inViewError = 0;\n\t\tlet inViewDistance = Infinity;\n\t\tlet maxCameraError = 0;\n\t\tlet minCameraDistance = Infinity;\n\n\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t// calculate the camera error\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tlet error;\n\t\t\tlet distance;\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\tconst pixelSize = info.pixelSize;\n\t\t\t\terror = tile.geometricError / pixelSize;\n\t\t\t\tdistance = Infinity;\n\n\t\t\t} else {\n\n\t\t\t\t// avoid dividing 0 by 0 which can result in NaN. If the distance to the tile is\n\t\t\t\t// 0 then the error should be infinity.\n\t\t\t\tconst sseDenominator = info.sseDenominator;\n\t\t\t\tdistance = boundingVolume.distanceToPoint( info.position );\n\t\t\t\terror = distance === 0 ? Infinity : tile.geometricError / ( distance * sseDenominator );\n\n\t\t\t}\n\n\t\t\t// Track which camera frustums this tile is in so we can use it\n\t\t\t// to ignore the error calculations for cameras that can't see it\n\t\t\tconst frustum = cameraInfo[ i ].frustum;\n\t\t\tif ( boundingVolume.intersectsFrustum( frustum ) ) {\n\n\t\t\t\tinView = true;\n\t\t\t\tinViewError = Math.max( inViewError, error );\n\t\t\t\tinViewDistance = Math.min( inViewDistance, distance );\n\n\t\t\t}\n\n\t\t\tmaxCameraError = Math.max( maxCameraError, error );\n\t\t\tminCameraDistance = Math.min( minCameraDistance, distance );\n\n\t\t}\n\n\t\tif ( inView ) {\n\n\t\t\t// write the in-camera error and distance parameters\n\t\t\ttarget.inView = true;\n\t\t\ttarget.error = inViewError;\n\t\t\ttarget.distanceFromCamera = inViewDistance;\n\n\t\t} else {\n\n\t\t\t// otherwise write variables for load priority\n\t\t\ttarget.inView = false;\n\t\t\ttarget.error = maxCameraError;\n\t\t\ttarget.distanceFromCamera = minCameraDistance;\n\n\t\t}\n\n\t}\n\n\t// adjust the rotation of the group such that Y is altitude, X is North, and Z is East\n\tsetLatLonToYUp( lat, lon ) {\n\n\t\tconsole.warn( 'TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.' );\n\n\t\tconst { ellipsoid, group } = this;\n\n\t\t_euler.set( Math.PI / 2, Math.PI / 2, 0 );\n\t\t_mat.makeRotationFromEuler( _euler );\n\n\t\tellipsoid.getEastNorthUpFrame( lat, lon, 0, group.matrix )\n\t\t\t.multiply( _mat )\n\t\t\t.invert()\n\t\t\t.decompose(\n\t\t\t\tgroup.position,\n\t\t\t\tgroup.quaternion,\n\t\t\t\tgroup.scale,\n\t\t\t);\n\n\t\tgroup.updateMatrixWorld( true );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.group.removeFromParent();\n\n\t}\n\n}\n","import { Mesh, PlaneGeometry, ShaderMaterial, Vector2 } from 'three';\n\nexport class PivotPointMesh extends Mesh {\n\n\tconstructor() {\n\n\t\tsuper( new PlaneGeometry( 0, 0 ), new PivotMaterial() );\n\t\tthis.renderOrder = Infinity;\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\t\trenderer.getSize( uniforms.resolution.value );\n\n\t}\n\n\tupdateMatrixWorld() {\n\n\t\tthis.matrixWorld.makeTranslation( this.position );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PivotMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: true,\n\n\t\t\tuniforms: {\n\n\t\t\t\tresolution: { value: new Vector2() },\n\t\t\t\tsize: { value: 15 },\n\t\t\t\tthickness: { value: 2 },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\t\t\t\t\tvec2 offset = uv * 2.0 - vec2( 1.0 );\n\t\t\t\t\toffset.y *= aspect;\n\n\t\t\t\t\tvec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tscreenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;\n\n\t\t\t\t\tgl_Position = screenPoint;\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat ht = 0.5 * thickness;\n\t\t\t\t\tfloat planeDim = size + thickness;\n\t\t\t\t\tfloat offset = ( planeDim - ht - 2.0 ) / planeDim;\n\t\t\t\t\tfloat texelThickness = ht / planeDim;\n\n\t\t\t\t\tvec2 vec = vUv * 2.0 - vec2( 1.0 );\n\t\t\t\t\tfloat dist = abs( length( vec ) - offset );\n\t\t\t\t\tfloat fw = fwidth( dist ) * 0.5;\n\t\t\t\t\tfloat a = smoothstep( texelThickness - fw, texelThickness + fw, dist );\n\n\t\t\t\t\tgl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n","import { Vector2 } from 'three';\n\nconst _vec = /* @__PURE__ */ new Vector2();\nconst _vec2 = /* @__PURE__ */ new Vector2();\nexport class PointerTracker {\n\n\tconstructor() {\n\n\t\tthis.domElement = null;\n\t\tthis.buttons = 0;\n\t\tthis.pointerType = null;\n\t\tthis.pointerOrder = [];\n\t\tthis.previousPositions = {};\n\t\tthis.pointerPositions = {};\n\t\tthis.startPositions = {};\n\t\tthis.pointerSetThisFrame = {};\n\t\tthis.hoverPosition = new Vector2();\n\t\tthis.hoverSet = false;\n\n\t}\n\n\treset() {\n\n\t\tthis.buttons = 0;\n\t\tthis.pointerType = null;\n\t\tthis.pointerOrder = [];\n\t\tthis.previousPositions = {};\n\t\tthis.pointerPositions = {};\n\t\tthis.startPositions = {};\n\t\tthis.pointerSetThisFrame = {};\n\t\tthis.hoverPosition = new Vector2();\n\t\tthis.hoverSet = false;\n\n\t}\n\n\t// The pointers can be set multiple times per frame so track whether the pointer has\n\t// been set this frame or not so we don't overwrite the previous position and lose information\n\t// about pointer movement\n\tupdateFrame() {\n\n\t\tconst { previousPositions, pointerPositions } = this;\n\t\tfor ( const id in pointerPositions ) {\n\n\t\t\tpreviousPositions[ id ].copy( pointerPositions[ id ] );\n\n\t\t}\n\n\t}\n\n\tsetHoverEvent( e ) {\n\n\t\tif ( e.pointerType === 'mouse' || e.type === 'wheel' ) {\n\n\t\t\tthis.getAdjustedPointer( e, this.hoverPosition );\n\t\t\tthis.hoverSet = true;\n\n\t\t}\n\n\t}\n\n\tgetLatestPoint( target ) {\n\n\t\tif ( this.pointerType !== null ) {\n\n\t\t\tthis.getCenterPoint( target );\n\t\t\treturn target;\n\n\t\t} else if ( this.hoverSet ) {\n\n\t\t\ttarget.copy( this.hoverPosition );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// get the pointer position in the coordinate system of the target element\n\tgetAdjustedPointer( e, target ) {\n\n\t\tconst domRef = this.domElement ? this.domElement : e.target;\n\t\tconst rect = domRef.getBoundingClientRect();\n\t\tconst x = e.clientX - rect.left;\n\t\tconst y = e.clientY - rect.top;\n\t\ttarget.set( x, y );\n\n\t}\n\n\taddPointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tconst position = new Vector2();\n\t\tthis.getAdjustedPointer( e, position );\n\t\tthis.pointerOrder.push( id );\n\t\tthis.pointerPositions[ id ] = position;\n\t\tthis.previousPositions[ id ] = position.clone();\n\t\tthis.startPositions[ id ] = position.clone();\n\n\t\tif ( this.getPointerCount() === 1 ) {\n\n\t\t\tthis.pointerType = e.pointerType;\n\t\t\tthis.buttons = e.buttons;\n\n\t\t}\n\n\t}\n\n\tupdatePointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tif ( ! ( id in this.pointerPositions ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tthis.getAdjustedPointer( e, this.pointerPositions[ id ] );\n\t\treturn true;\n\n\t}\n\n\tdeletePointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tconst pointerOrder = this.pointerOrder;\n\t\tpointerOrder.splice( pointerOrder.indexOf( id ), 1 );\n\t\tdelete this.pointerPositions[ id ];\n\t\tdelete this.previousPositions[ id ];\n\t\tdelete this.startPositions[ id ];\n\n\t\tif ( this.getPointerCount() === 0 ) {\n\n\t\t\tthis.buttons = 0;\n\t\t\tthis.pointerType = null;\n\n\t\t}\n\n\t}\n\n\tgetPointerCount() {\n\n\t\treturn this.pointerOrder.length;\n\n\t}\n\n\tgetCenterPoint( target, pointerPositions = this.pointerPositions ) {\n\n\t\tconst pointerOrder = this.pointerOrder;\n\t\tif ( this.getPointerCount() === 1 || this.getPointerType() === 'mouse' ) {\n\n\t\t\tconst id = pointerOrder[ 0 ];\n\t\t\ttarget.copy( pointerPositions[ id ] );\n\t\t\treturn target;\n\n\t\t} else if ( this.getPointerCount() === 2 ) {\n\n\t\t\tconst id0 = this.pointerOrder[ 0 ];\n\t\t\tconst id1 = this.pointerOrder[ 1 ];\n\n\t\t\tconst p0 = pointerPositions[ id0 ];\n\t\t\tconst p1 = pointerPositions[ id1 ];\n\n\t\t\ttarget.addVectors( p0, p1 ).multiplyScalar( 0.5 );\n\t\t\treturn target;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetPreviousCenterPoint( target ) {\n\n\t\treturn this.getCenterPoint( target, this.previousPositions );\n\n\t}\n\n\tgetStartCenterPoint( target ) {\n\n\t\treturn this.getCenterPoint( target, this.startPositions );\n\n\t}\n\n\tgetMoveDistance() {\n\n\t\tthis.getCenterPoint( _vec );\n\t\tthis.getPreviousCenterPoint( _vec2 );\n\n\t\treturn _vec.sub( _vec2 ).length();\n\n\t}\n\n\tgetTouchPointerDistance( pointerPositions = this.pointerPositions ) {\n\n\t\tif ( this.getPointerCount() <= 1 || this.getPointerType() === 'mouse' ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst { pointerOrder } = this;\n\t\tconst id0 = pointerOrder[ 0 ];\n\t\tconst id1 = pointerOrder[ 1 ];\n\n\t\tconst p0 = pointerPositions[ id0 ];\n\t\tconst p1 = pointerPositions[ id1 ];\n\n\t\treturn p0.distanceTo( p1 );\n\n\t}\n\n\tgetPreviousTouchPointerDistance() {\n\n\t\treturn this.getTouchPointerDistance( this.previousPositions );\n\n\t}\n\n\tgetStartTouchPointerDistance() {\n\n\t\treturn this.getTouchPointerDistance( this.startPositions );\n\n\t}\n\n\tgetPointerType() {\n\n\t\treturn this.pointerType;\n\n\t}\n\n\tisPointerTouch() {\n\n\t\treturn this.getPointerType() === 'touch';\n\n\t}\n\n\tgetPointerButtons() {\n\n\t\treturn this.buttons;\n\n\t}\n\n\tisLeftClicked() {\n\n\t\treturn Boolean( this.buttons & 1 );\n\n\t}\n\n\tisRightClicked() {\n\n\t\treturn Boolean( this.buttons & 2 );\n\n\t}\n\n}\n","import { Matrix4, Ray, Vector3 } from 'three';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// helper function for constructing a matrix for rotating around a point\nexport function makeRotateAroundPoint( point, quat, target ) {\n\n\ttarget.makeTranslation( - point.x, - point.y, - point.z );\n\n\t_matrix.makeRotationFromQuaternion( quat );\n\ttarget.premultiply( _matrix );\n\n\t_matrix.makeTranslation( point.x, point.y, point.z );\n\ttarget.premultiply( _matrix );\n\n\treturn target;\n\n}\n\n// get the three.js pointer coords from an adjusted pointer (via PointerTracker)\nexport function adjustedPointerToCoords( pointer, element, target ) {\n\n\ttarget.x = ( pointer.x / element.clientWidth ) * 2 - 1;\n\ttarget.y = - ( pointer.y / element.clientHeight ) * 2 + 1;\n\n\tif ( target.isVector3 ) {\n\n\t\ttarget.z = 0;\n\n\t}\n\n}\n\n// find the closest ray on the horizon when the ray passes above the sphere\nexport function closestRaySpherePointFromRotation( ray, radius, target ) {\n\n\tconst hypotenuse = ray.origin.length();\n\n\t// angle inside the sphere\n\tconst theta = Math.acos( radius / hypotenuse );\n\n\t// the direction to the camera\n\ttarget\n\t\t.copy( ray.origin )\n\t\t.multiplyScalar( - 1 )\n\t\t.normalize();\n\n\t// get the normal of the plane the ray and origin lie in\n\tconst rotationVec = _vec\n\t\t.crossVectors( target, ray.direction )\n\t\t.normalize();\n\n\t// rotate the camera direction by angle and scale it to the surface\n\ttarget\n\t\t.multiplyScalar( - 1 )\n\t\t.applyAxisAngle( rotationVec, - theta )\n\t\t.normalize()\n\t\t.multiplyScalar( radius );\n\n}\n\n\n// custom version of set raycaster from camera that relies on the underlying matrices\n// so the ray origin is position at the camera near clip.\nexport function setRaycasterFromCamera( raycaster, coords, camera ) {\n\n\tconst ray = raycaster instanceof Ray ? raycaster : raycaster.ray;\n\tconst { origin, direction } = ray;\n\n\t// get the origin and direction of the frustum ray\n\torigin\n\t\t.set( coords.x, coords.y, - 1 )\n\t\t.unproject( camera );\n\n\tdirection\n\t\t.set( coords.x, coords.y, 1 )\n\t\t.unproject( camera )\n\t\t.sub( origin );\n\n\tif ( ! raycaster.isRay ) {\n\n\t\t// compute the far value based on the distance from point on the near\n\t\t// plane and point on the far plane. Then normalize the direction.\n\t\traycaster.near = 0;\n\t\traycaster.far = direction.length();\n\t\traycaster.camera = camera;\n\n\t}\n\n\t// normalize the ray direction\n\tdirection.normalize();\n\n}\n","import {\n\tMatrix4,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tRaycaster,\n\tPlane,\n\tEventDispatcher,\n\tMathUtils,\n\tClock,\n\tRay,\n} from 'three';\nimport { PivotPointMesh } from './PivotPointMesh.js';\nimport { PointerTracker } from './PointerTracker.js';\nimport { adjustedPointerToCoords, makeRotateAroundPoint, setRaycasterFromCamera } from './utils.js';\n\nexport const NONE = 0;\nexport const DRAG = 1;\nexport const ROTATE = 2;\nexport const ZOOM = 3;\nexport const WAITING = 4;\n\nconst DRAG_PLANE_THRESHOLD = 0.05;\nconst DRAG_UP_THRESHOLD = 0.025;\n\nconst _rotMatrix = /* @__PURE__ */ new Matrix4();\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _delta = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _right = /* @__PURE__ */ new Vector3();\nconst _targetRight = /* @__PURE__ */ new Vector3();\nconst _rotationAxis = /* @__PURE__ */ new Vector3();\nconst _quaternion = /* @__PURE__ */ new Quaternion();\nconst _plane = /* @__PURE__ */ new Plane();\nconst _localUp = /* @__PURE__ */ new Vector3();\nconst _mouseBefore = /* @__PURE__ */ new Vector3();\nconst _mouseAfter = /* @__PURE__ */ new Vector3();\nconst _identityQuat = /* @__PURE__ */ new Quaternion();\nconst _ray = /* @__PURE__ */ new Ray();\n\nconst _zoomPointPointer = /* @__PURE__ */ new Vector2();\nconst _pointer = /* @__PURE__ */ new Vector2();\nconst _prevPointer = /* @__PURE__ */ new Vector2();\nconst _deltaPointer = /* @__PURE__ */ new Vector2();\nconst _centerPoint = /* @__PURE__ */ new Vector2();\nconst _startCenterPoint = /* @__PURE__ */ new Vector2();\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nexport class EnvironmentControls extends EventDispatcher {\n\n\tget enabled() {\n\n\t\treturn this._enabled;\n\n\t}\n\n\tset enabled( v ) {\n\n\t\tif ( v !== this.enabled ) {\n\n\t\t\tthis._enabled = v;\n\t\t\tthis.resetState();\n\t\t\tthis.pointerTracker.reset();\n\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\t\t\tthis.rotationInertia.set( 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconstructor( scene = null, camera = null, domElement = null, tilesRenderer = null ) {\n\n\t\tsuper();\n\n\t\tthis.isEnvironmentControls = true;\n\n\t\tthis.domElement = null;\n\t\tthis.camera = null;\n\t\tthis.scene = null;\n\t\tthis.tilesRenderer = null;\n\n\t\t// settings\n\t\tthis._enabled = true;\n\t\tthis.cameraRadius = 5;\n\t\tthis.rotationSpeed = 1;\n\t\tthis.minAltitude = 0;\n\t\tthis.maxAltitude = 0.45 * Math.PI;\n\t\tthis.minDistance = 10;\n\t\tthis.maxDistance = Infinity;\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\t\tthis.zoomSpeed = 1;\n\t\tthis.adjustHeight = true;\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.15;\n\n\t\tthis.fallbackPlane = new Plane( new Vector3( 0, 1, 0 ), 0 );\n\t\tthis.useFallbackPlane = true;\n\n\t\t// settings for GlobeControls\n\t\tthis.scaleZoomOrientationAtEdges = false;\n\t\tthis.autoAdjustCameraRotation = true;\n\n\t\t// internal state\n\t\tthis.state = NONE;\n\t\tthis.pointerTracker = new PointerTracker();\n\t\tthis.needsUpdate = false;\n\t\tthis.actionHeightOffset = 0;\n\n\t\tthis.pivotPoint = new Vector3();\n\n\t\t// used for zoom\n\t\tthis.zoomDirectionSet = false;\n\t\tthis.zoomPointSet = false;\n\t\tthis.zoomDirection = new Vector3();\n\t\tthis.zoomPoint = new Vector3();\n\t\tthis.zoomDelta = 0;\n\n\t\t// fields used for inertia\n\t\tthis.rotationInertiaPivot = new Vector3();\n\t\tthis.rotationInertia = new Vector2();\n\t\tthis.dragInertia = new Vector3();\n\t\tthis.inertiaTargetDistance = Infinity; \t\t// track the distance from the camera that we want to use to calculate the inertia end threshold\n\t\tthis.inertiaStableFrames = 0; \t\t\t\t// the number of frames that the camera has not moved while the user is interacting\n\n\t\t// circular pivot mesh\n\t\tthis.pivotMesh = new PivotPointMesh();\n\t\tthis.pivotMesh.raycast = () => {};\n\n\t\tthis.pivotMesh.scale.setScalar( 0.25 );\n\n\t\t// raycaster\n\t\tthis.raycaster = new Raycaster();\n\t\tthis.raycaster.firstHitOnly = true;\n\n\t\tthis.up = new Vector3( 0, 1, 0 );\n\t\tthis.clock = new Clock();\n\n\t\tthis._detachCallback = null;\n\t\tthis._upInitialized = false;\n\t\tthis._lastUsedState = NONE;\n\t\tthis._zoomPointWasSet = false;\n\n\t\t// always update the zoom target point in case the tiles are changing\n\t\tthis._tilesOnChangeCallback = () => this.zoomPointSet = false;\n\n\t\t// init\n\t\tif ( domElement ) this.attach( domElement );\n\t\tif ( camera ) this.setCamera( camera );\n\t\tif ( scene ) this.setScene( scene );\n\t\tif ( tilesRenderer ) this.setTilesRenderer( tilesRenderer );\n\n\t}\n\n\tsetScene( scene ) {\n\n\t\tthis.scene = scene;\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tthis.camera = camera;\n\t\tthis._upInitialized = false;\n\t\tthis.zoomDirectionSet = false;\n\t\tthis.zoomPointSet = false;\n\t\tthis.needsUpdate = true;\n\t\tthis.raycaster.camera = camera;\n\t\tthis.resetState();\n\n\t}\n\n\tsetTilesRenderer( tilesRenderer ) {\n\n\t\tconsole.warn( 'EnvironmentControls: \"setTilesRenderer\" has been deprecated. Use \"setScene\" and \"setEllipsoid\", instead.' );\n\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tif ( this.tilesRenderer !== null ) {\n\n\t\t\tthis.setScene( this.tilesRenderer.group );\n\n\t\t}\n\n\t}\n\n\tattach( domElement ) {\n\n\t\tif ( this.domElement ) {\n\n\t\t\tthrow new Error( 'EnvironmentControls: Controls already attached to element' );\n\n\t\t}\n\n\t\t// set the touch action to none so the browser does not\n\t\t// drag the page to refresh or scroll\n\t\tthis.domElement = domElement;\n\t\tthis.pointerTracker.domElement = domElement;\n\t\tdomElement.style.touchAction = 'none';\n\n\t\tconst contextMenuCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t};\n\n\t\tconst pointerdownCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst {\n\t\t\t\tcamera,\n\t\t\t\traycaster,\n\t\t\t\tdomElement,\n\t\t\t\tup,\n\t\t\t\tpivotMesh,\n\t\t\t\tpointerTracker,\n\t\t\t\tscene,\n\t\t\t\tpivotPoint,\n\t\t\t\tenabled,\n\t\t\t} = this;\n\n\t\t\t// init the pointer\n\t\t\tpointerTracker.addPointer( e );\n\t\t\tthis.needsUpdate = true;\n\n\t\t\t// handle cases where we need to capture the pointer or\n\t\t\t// reset state when we have too many pointers\n\t\t\tif ( pointerTracker.isPointerTouch() ) {\n\n\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t\tif ( pointerTracker.getPointerCount() === 0 ) {\n\n\t\t\t\t\t// TODO: is it correct to only capture a single pointer? Or do we need to do it for\n\t\t\t\t\t// every unique pointer id?\n\t\t\t\t\tdomElement.setPointerCapture( e.pointerId );\n\n\t\t\t\t} else if ( pointerTracker.getPointerCount() > 2 ) {\n\n\t\t\t\t\tthis.resetState();\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// the \"pointer\" for zooming and rotating should be based on the center point\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tadjustedPointerToCoords( _pointer, domElement, _pointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// prevent the drag distance from getting too severe by limiting the drag point\n\t\t\t// to a reasonable angle and reasonable distance with the drag plane\n\t\t\tconst dot = Math.abs( raycaster.ray.direction.dot( up ) );\n\t\t\tif ( dot < DRAG_PLANE_THRESHOLD || dot < DRAG_UP_THRESHOLD ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// find the hit point\n\t\t\tconst hit = this._raycast( raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\t// if two fingers, right click, or shift click are being used then we trigger\n\t\t\t\t// a rotation action to begin\n\t\t\t\tif (\n\t\t\t\t\tpointerTracker.getPointerCount() === 2 ||\n\t\t\t\t\tpointerTracker.isRightClicked() ||\n\t\t\t\t\tpointerTracker.isLeftClicked() && e.shiftKey\n\t\t\t\t) {\n\n\t\t\t\t\tthis.setState( pointerTracker.isPointerTouch() ? WAITING : ROTATE );\n\n\t\t\t\t\tpivotPoint.copy( hit.point );\n\t\t\t\t\tpivotMesh.position.copy( hit.point );\n\t\t\t\t\tpivotMesh.visible = pointerTracker.isPointerTouch() ? false : enabled;\n\t\t\t\t\tpivotMesh.updateMatrixWorld();\n\t\t\t\t\tscene.add( pivotMesh );\n\n\t\t\t\t} else if ( pointerTracker.isLeftClicked() ) {\n\n\t\t\t\t\t// if the clicked point is coming from below the plane then don't perform the drag\n\t\t\t\t\tthis.setState( DRAG );\n\t\t\t\t\tpivotPoint.copy( hit.point );\n\n\t\t\t\t\tpivotMesh.position.copy( hit.point );\n\t\t\t\t\tpivotMesh.updateMatrixWorld();\n\t\t\t\t\tscene.add( pivotMesh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tlet _pointerMoveQueued = false;\n\t\tconst pointermoveCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tconst { pointerTracker } = this;\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst {\n\t\t\t\tpivotMesh,\n\t\t\t\tenabled,\n\t\t\t} = this;\n\n\t\t\t// whenever the pointer moves we need to re-derive the zoom direction and point\n\t\t\tthis.zoomDirectionSet = false;\n\t\t\tthis.zoomPointSet = false;\n\n\t\t\tif ( this.state !== NONE ) {\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tpointerTracker.setHoverEvent( e );\n\t\t\tif ( ! pointerTracker.updatePointer( e ) ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( pointerTracker.isPointerTouch() && pointerTracker.getPointerCount() === 2 ) {\n\n\t\t\t\t// We queue this event to ensure that all pointers have been updated\n\t\t\t\tif ( ! _pointerMoveQueued ) {\n\n\t\t\t\t\t_pointerMoveQueued = true;\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\t_pointerMoveQueued = false;\n\n\t\t\t\t\t\t// adjust the pointer position to be the center point\n\t\t\t\t\t\tpointerTracker.getCenterPoint( _centerPoint );\n\n\t\t\t\t\t\t// detect zoom transition\n\t\t\t\t\t\tconst startDist = pointerTracker.getStartTouchPointerDistance();\n\t\t\t\t\t\tconst pointerDist = pointerTracker.getTouchPointerDistance();\n\t\t\t\t\t\tconst separateDelta = pointerDist - startDist;\n\t\t\t\t\t\tif ( this.state === NONE || this.state === WAITING ) {\n\n\t\t\t\t\t\t\t// check which direction was moved in first - if the pointers are pinching then\n\t\t\t\t\t\t\t// it's a zoom. But if they move in parallel it's a rotation\n\t\t\t\t\t\t\tpointerTracker.getCenterPoint( _centerPoint );\n\t\t\t\t\t\t\tpointerTracker.getStartCenterPoint( _startCenterPoint );\n\n\t\t\t\t\t\t\t// adjust the drag requirement by the dpr\n\t\t\t\t\t\t\tconst dragThreshold = 2.0 * window.devicePixelRatio;\n\t\t\t\t\t\t\tconst parallelDelta = _centerPoint.distanceTo( _startCenterPoint );\n\t\t\t\t\t\t\tif ( Math.abs( separateDelta ) > dragThreshold || parallelDelta > dragThreshold ) {\n\n\t\t\t\t\t\t\t\tif ( Math.abs( separateDelta ) > parallelDelta ) {\n\n\t\t\t\t\t\t\t\t\tthis.setState( ZOOM );\n\t\t\t\t\t\t\t\t\tthis.zoomDirectionSet = false;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tthis.setState( ROTATE );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.state === ZOOM ) {\n\n\t\t\t\t\t\t\tconst previousDist = pointerTracker.getPreviousTouchPointerDistance();\n\t\t\t\t\t\t\tthis.zoomDelta += pointerDist - previousDist;\n\t\t\t\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t\t\t\t} else if ( this.state === ROTATE ) {\n\n\t\t\t\t\t\t\tpivotMesh.visible = enabled;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: we have the potential to fire change multiple times per frame - should we debounce?\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t};\n\n\t\tconst pointerupCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tconst { pointerTracker } = this;\n\t\t\tif ( ! this.enabled || pointerTracker.getPointerCount() === 0 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tpointerTracker.deletePointer( e );\n\n\t\t\tif (\n\t\t\t\tpointerTracker.getPointerType() === 'touch' &&\n\t\t\t\tpointerTracker.getPointerCount() === 0\n\t\t\t) {\n\n\t\t\t\tdomElement.releasePointerCapture( e.pointerId );\n\n\t\t\t}\n\n\t\t\tthis.resetState();\n\t\t\tthis.needsUpdate = true;\n\n\t\t};\n\n\t\tconst wheelCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst { pointerTracker } = this;\n\t\t\tpointerTracker.setHoverEvent( e );\n\t\t\tpointerTracker.updatePointer( e );\n\n\t\t\t// TODO: do we need events here?\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tlet delta;\n\t\t\tswitch ( e.deltaMode ) {\n\n\t\t\t\tcase 2: // Pages\n\t\t\t\t\tdelta = e.deltaY * 800;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: // Lines\n\t\t\t\t\tdelta = e.deltaY * 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0: // Pixels\n\t\t\t\t\tdelta = e.deltaY;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// use LOG to scale the scroll delta and hopefully normalize them across platforms\n\t\t\tconst deltaSign = Math.sign( delta );\n\t\t\tconst normalizedDelta = Math.abs( delta );\n\t\t\tthis.zoomDelta -= 0.25 * deltaSign * normalizedDelta;\n\t\t\tthis.needsUpdate = true;\n\n\t\t\tthis._lastUsedState = ZOOM;\n\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t};\n\n\t\tconst pointerleaveCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.resetState();\n\n\t\t};\n\n\t\tdomElement.addEventListener( 'contextmenu', contextMenuCallback );\n\t\tdomElement.addEventListener( 'pointerdown', pointerdownCallback );\n\t\tdomElement.addEventListener( 'wheel', wheelCallback, { passive: false } );\n\n\t\t// Register movement events on the root element so dragging does not break when dragging over other elements.\n\t\t// Use \"getRootNode\" to enable offscreenCanvas usage.\n\t\t// \"pointerleave\" event fires when leaving the window.\n\t\tconst document = domElement.getRootNode();\n\t\tdocument.addEventListener( 'pointermove', pointermoveCallback );\n\t\tdocument.addEventListener( 'pointerup', pointerupCallback );\n\t\tdocument.addEventListener( 'pointerleave', pointerleaveCallback );\n\n\t\tthis._detachCallback = () => {\n\n\t\t\tdomElement.removeEventListener( 'contextmenu', contextMenuCallback );\n\t\t\tdomElement.removeEventListener( 'pointerdown', pointerdownCallback );\n\t\t\tdomElement.removeEventListener( 'wheel', wheelCallback );\n\n\t\t\tdocument.removeEventListener( 'pointermove', pointermoveCallback );\n\t\t\tdocument.removeEventListener( 'pointerup', pointerupCallback );\n\t\t\tdocument.removeEventListener( 'pointerleave', pointerleaveCallback );\n\n\t\t};\n\n\t}\n\n\tdetach() {\n\n\t\tthis.domElement = null;\n\n\t\tif ( this._detachCallback ) {\n\n\t\t\tthis._detachCallback();\n\t\t\tthis._detachCallback = null;\n\t\t\tthis.pointerTracker.reset();\n\n\t\t}\n\n\t}\n\n\t// override-able functions for retrieving the up direction at a point\n\tgetUpDirection( point, target ) {\n\n\t\ttarget.copy( this.up );\n\n\t}\n\n\tgetCameraUpDirection( target ) {\n\n\t\tthis.getUpDirection( this.camera.position, target );\n\n\t}\n\n\t// returns the active / last used pivot point for the scene\n\tgetPivotPoint( target ) {\n\n\t\tlet result = null;\n\n\t\t// get the last interacted point as the focus\n\t\tif ( this._lastUsedState === ZOOM ) {\n\n\t\t\tif ( this._zoomPointWasSet ) {\n\n\t\t\t\tresult = target.copy( this.zoomPoint );\n\n\t\t\t}\n\n\t\t} else if ( this._lastUsedState === ROTATE || this._lastUsedState === DRAG ) {\n\n\t\t\tresult = target.copy( this.pivotPoint );\n\n\t\t}\n\n\t\t// If the last used point is outside the camera view then skip it\n\t\tconst { camera, raycaster } = this;\n\t\tif ( result !== null ) {\n\n\t\t\t_vec.copy( result ).project( camera );\n\t\t\tif ( _vec.x < - 1 || _vec.x > 1 || _vec.y < - 1 || _vec.y > 1 ) {\n\n\t\t\t\tresult = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// default to the raycast hit if we have not result or the hit is closer to the camera\n\t\t// set a ray in the local ellipsoid frame\n\t\tsetRaycasterFromCamera( raycaster, { x: 0, y: 0 }, camera );\n\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\tif ( result === null || hit.distance < result.distanceTo( raycaster.ray.origin ) ) {\n\n\t\t\t\tresult = target.copy( hit.point );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tresetState() {\n\n\t\tif ( this.state !== NONE ) {\n\n\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tthis.state = NONE;\n\t\tthis.pivotMesh.removeFromParent();\n\t\tthis.pivotMesh.visible = this.enabled;\n\t\tthis.actionHeightOffset = 0;\n\t\tthis.pointerTracker.reset();\n\n\t}\n\n\tsetState( state = this.state, fireEvent = true ) {\n\n\t\tif ( this.state === state ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.state === NONE && fireEvent ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t}\n\n\t\tthis.pivotMesh.visible = this.enabled;\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.inertiaStableFrames = 0;\n\t\tthis.state = state;\n\n\t\tif ( state !== NONE && state !== WAITING ) {\n\n\t\t\tthis._lastUsedState = state;\n\n\t\t}\n\n\t}\n\n\tupdate( deltaTime = Math.min( this.clock.getDelta(), 64 / 1000 ) ) {\n\n\t\tif ( ! this.enabled || ! this.camera || deltaTime === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tpivotPoint,\n\t\t\tup,\n\t\t\tstate,\n\t\t\tadjustHeight,\n\t\t\tautoAdjustCameraRotation,\n\t\t} = this;\n\n\t\tcamera.updateMatrixWorld();\n\n\t\t// set the \"up\" vector immediately so it's available in the following functions\n\t\tthis.getCameraUpDirection( _localUp );\n\t\tif ( ! this._upInitialized ) {\n\n\t\t\tthis._upInitialized = true;\n\t\t\tthis.up.copy( _localUp );\n\n\t\t}\n\n\t\t// we need to update the zoom point whenever we update in case the scene is animating or changing\n\t\tthis.zoomPointSet = false;\n\n\t\t// update the actions\n\t\tconst inertiaNeedsUpdate = this._inertiaNeedsUpdate();\n\t\tconst adjustCameraRotation = this.needsUpdate || inertiaNeedsUpdate;\n\t\tif ( this.needsUpdate || inertiaNeedsUpdate ) {\n\n\t\t\tconst zoomDelta = this.zoomDelta;\n\n\t\t\tthis._updateZoom();\n\t\t\tthis._updatePosition( deltaTime );\n\t\t\tthis._updateRotation( deltaTime );\n\n\t\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\t\tthis.inertiaTargetDistance = _vec.copy( pivotPoint ).sub( camera.position ).dot( _forward );\n\n\t\t\t} else if ( state === NONE ) {\n\n\t\t\t\tthis._updateInertia( deltaTime );\n\n\t\t\t}\n\n\t\t\tif ( state !== NONE || zoomDelta !== 0 || inertiaNeedsUpdate ) {\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t\t// update the up direction based on where the camera moved to\n\t\t// if using an orthographic camera then rotate around drag pivot\n\t\t// reuse the \"hit\" information since it can be slow to perform multiple hits\n\t\tconst hit = camera.isOrthographicCamera ? null : adjustHeight && this._getPointBelowCamera() || null;\n\t\tthis.getCameraUpDirection( _localUp );\n\t\tthis._setFrame( _localUp );\n\n\t\t// when dragging the camera and drag point may be moved\n\t\t// to accommodate terrain so we try to move it back down\n\t\t// to the original point.\n\t\tif ( ( this.state === DRAG || this.state === ROTATE ) && this.actionHeightOffset !== 0 ) {\n\n\t\t\tconst { actionHeightOffset } = this;\n\t\t\tcamera.position.addScaledVector( up, - actionHeightOffset );\n\t\t\tpivotPoint.addScaledVector( up, - actionHeightOffset );\n\n\t\t\t// adjust the height\n\t\t\tif ( hit ) {\n\n\t\t\t\thit.distance -= actionHeightOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.actionHeightOffset = 0;\n\n\t\tif ( hit ) {\n\n\t\t\tconst dist = hit.distance;\n\t\t\tif ( dist < cameraRadius ) {\n\n\t\t\t\tconst delta = cameraRadius - dist;\n\t\t\t\tcamera.position.addScaledVector( up, delta );\n\t\t\t\tpivotPoint.addScaledVector( up, delta );\n\t\t\t\tthis.actionHeightOffset = delta;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.pointerTracker.updateFrame();\n\n\t\tif ( adjustCameraRotation && autoAdjustCameraRotation ) {\n\n\t\t\tthis.getCameraUpDirection( _localUp );\n\t\t\tthis._alignCameraUp( _localUp, 1 );\n\n\t\t\tthis.getCameraUpDirection( _localUp );\n\t\t\tthis._clampRotation( _localUp );\n\n\n\t\t}\n\n\t}\n\n\t// updates the camera to position it based on the constraints of the controls\n\tadjustCamera( camera ) {\n\n\t\tconst { adjustHeight, cameraRadius } = this;\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t// adjust the camera height\n\t\t\tthis.getUpDirection( camera.position, _localUp );\n\t\t\tconst hit = adjustHeight && this._getPointBelowCamera( camera.position, _localUp ) || null;\n\t\t\tif ( hit ) {\n\n\t\t\t\tconst dist = hit.distance;\n\t\t\t\tif ( dist < cameraRadius ) {\n\n\t\t\t\t\tcamera.position.addScaledVector( _localUp, cameraRadius - dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.detach();\n\n\t}\n\n\t// private\n\t_updateInertia( deltaTime ) {\n\n\t\t// update the damping of momentum variables\n\t\tconst {\n\t\t\trotationInertia,\n\t\t\tpivotPoint,\n\t\t\tdragInertia,\n\t\t\tenableDamping,\n\t\t\tdampingFactor,\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tminDistance,\n\t\t\tinertiaTargetDistance,\n\t\t} = this;\n\n\t\tif ( ! this.enableDamping || this.inertiaStableFrames > 1 ) {\n\n\t\t\tdragInertia.set( 0, 0, 0 );\n\t\t\trotationInertia.set( 0, 0, 0 );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Based on Freya Holmer's frame-rate independent lerp function\n\t\tconst factor = Math.pow( 2, - deltaTime / dampingFactor );\n\t\tconst stableDistance = Math.max( camera.near, cameraRadius, minDistance, inertiaTargetDistance );\n\t\tconst resolution = 2 * 1e3;\n\t\tconst pixelWidth = 2 / resolution;\n\t\tconst pixelThreshold = 0.25 * pixelWidth;\n\n\t\t// scale the residual rotation motion\n\t\tif ( rotationInertia.lengthSq() > 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _delta.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _delta );\n\t\t\t_delta.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// get implied angle\n\t\t\t_vec.sub( pivotPoint ).normalize();\n\t\t\t_delta.sub( pivotPoint ).normalize();\n\n\t\t\t// calculate the rotation threshold\n\t\t\tconst threshold = _vec.angleTo( _delta ) / deltaTime;\n\t\t\trotationInertia.multiplyScalar( factor );\n\t\t\tif ( rotationInertia.lengthSq() < threshold ** 2 || ! enableDamping ) {\n\n\t\t\t\trotationInertia.set( 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scale the residual translation motion\n\t\tif ( dragInertia.lengthSq() > 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _delta.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _delta );\n\t\t\t_delta.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// calculate movement threshold\n\t\t\tconst threshold = _vec.distanceTo( _delta ) / deltaTime;\n\t\t\tdragInertia.multiplyScalar( factor );\n\t\t\tif ( dragInertia.lengthSq() < threshold ** 2 || ! enableDamping ) {\n\n\t\t\t\tdragInertia.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply the inertia changes\n\t\tif ( rotationInertia.lengthSq() > 0 ) {\n\n\t\t\tthis._applyRotation( rotationInertia.x * deltaTime, rotationInertia.y * deltaTime, pivotPoint );\n\n\t\t}\n\n\t\tif ( dragInertia.lengthSq() > 0 ) {\n\n\t\t\tcamera.position.addScaledVector( dragInertia, deltaTime );\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\t_inertiaNeedsUpdate() {\n\n\t\tconst { rotationInertia, dragInertia } = this;\n\t\treturn rotationInertia.lengthSq() !== 0 || dragInertia.lengthSq() !== 0;\n\n\t}\n\n\t_updateZoom() {\n\n\t\tconst {\n\t\t\tzoomPoint,\n\t\t\tzoomDirection,\n\t\t\tcamera,\n\t\t\tminDistance,\n\t\t\tmaxDistance,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tminZoom,\n\t\t\tmaxZoom,\n\t\t\tzoomSpeed,\n\t\t\tstate,\n\t\t} = this;\n\n\t\tlet scale = this.zoomDelta;\n\t\tthis.zoomDelta = 0;\n\n\t\t// get the latest hover / touch point\n\t\tif ( ! pointerTracker.getLatestPoint( _pointer ) || ( scale === 0 && state !== ZOOM ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// reset momentum\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\t// update the zoom direction\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// zoom straight into the globe if we haven't hit anything\n\t\t\tconst zoomIntoPoint = this.zoomPointSet || this._updateZoomPoint();\n\n\t\t\t// get the mouse position before zoom\n\t\t\t_mouseBefore.unproject( camera );\n\n\t\t\t// zoom the camera\n\t\t\tconst normalizedDelta = Math.pow( 0.95, Math.abs( scale * 0.05 ) );\n\t\t\tlet scaleFactor = scale > 0 ? 1 / Math.abs( normalizedDelta ) : normalizedDelta;\n\t\t\tscaleFactor *= zoomSpeed;\n\n\t\t\tif ( scaleFactor > 1 ) {\n\n\t\t\t\tif ( maxZoom < camera.zoom * scaleFactor ) {\n\n\t\t\t\t\tscaleFactor = 1;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( minZoom > camera.zoom * scaleFactor ) {\n\n\t\t\t\t\tscaleFactor = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcamera.zoom *= scaleFactor;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t// adjust the surface point to be in the same position if the globe is hovered over\n\t\t\tif ( zoomIntoPoint ) {\n\n\t\t\t\t// get the mouse position after zoom\n\t\t\t\tadjustedPointerToCoords( _pointer, domElement, _mouseAfter );\n\t\t\t\t_mouseAfter.unproject( camera );\n\n\t\t\t\t// shift the camera on the near plane so the mouse is in the same spot\n\t\t\t\tcamera.position.sub( _mouseAfter ).add( _mouseBefore );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// initialize the zoom direction\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// track the zoom direction we're going to use\n\t\t\tconst finalZoomDirection = _vec.copy( zoomDirection );\n\n\t\t\tif ( this.zoomPointSet || this._updateZoomPoint() ) {\n\n\t\t\t\tconst dist = zoomPoint.distanceTo( camera.position );\n\n\t\t\t\t// scale the distance based on how far there is to move\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\tconst remainingDistance = Math.min( 0, dist - maxDistance );\n\t\t\t\t\tscale = scale * dist * zoomSpeed * 0.0025;\n\t\t\t\t\tscale = Math.max( scale, remainingDistance );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst remainingDistance = Math.max( 0, dist - minDistance );\n\t\t\t\t\tscale = scale * Math.max( dist - minDistance, 0 ) * zoomSpeed * 0.0025;\n\t\t\t\t\tscale = Math.min( scale, remainingDistance );\n\n\t\t\t\t}\n\n\t\t\t\tcamera.position.addScaledVector( zoomDirection, scale );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t} else {\n\n\t\t\t\t// if we're zooming into nothing then use the distance from the ground to scale movement\n\t\t\t\tconst hit = this._getPointBelowCamera();\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tconst dist = hit.distance;\n\t\t\t\t\tfinalZoomDirection.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\t\t\tcamera.position.addScaledVector( finalZoomDirection, scale * dist * 0.01 );\n\t\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateZoomDirection() {\n\n\t\tif ( this.zoomDirectionSet ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { domElement, raycaster, camera, zoomDirection, pointerTracker } = this;\n\t\tpointerTracker.getLatestPoint( _pointer );\n\t\tadjustedPointerToCoords( _pointer, domElement, _mouseBefore );\n\t\tsetRaycasterFromCamera( raycaster, _mouseBefore, camera );\n\t\tzoomDirection.copy( raycaster.ray.direction ).normalize();\n\t\tthis.zoomDirectionSet = true;\n\n\t}\n\n\t// update the point being zoomed in to based on the zoom direction\n\t_updateZoomPoint() {\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tzoomDirectionSet,\n\t\t\tzoomDirection,\n\t\t\traycaster,\n\t\t\tzoomPoint,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t} = this;\n\n\t\tthis._zoomPointWasSet = false;\n\n\t\tif ( ! zoomDirectionSet ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// If using an orthographic camera we have to account for the mouse position when picking the point\n\t\tif ( camera.isOrthographicCamera && pointerTracker.getLatestPoint( _zoomPointPointer ) ) {\n\n\t\t\tadjustedPointerToCoords( _zoomPointPointer, domElement, _zoomPointPointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _zoomPointPointer, camera );\n\n\t\t} else {\n\n\t\t\traycaster.ray.origin.copy( camera.position );\n\t\t\traycaster.ray.direction.copy( zoomDirection );\n\t\t\traycaster.near = 0;\n\t\t\traycaster.far = Infinity;\n\n\t\t}\n\n\t\t// get the hit point\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\tzoomPoint.copy( hit.point );\n\t\t\tthis.zoomPointSet = true;\n\t\t\tthis._zoomPointWasSet = true;\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// returns the point below the camera\n\t_getPointBelowCamera( point = this.camera.position, up = this.up ) {\n\n\t\tconst { raycaster } = this;\n\t\traycaster.ray.direction.copy( up ).multiplyScalar( - 1 );\n\t\traycaster.ray.origin.copy( point ).addScaledVector( up, 1e5 );\n\t\traycaster.near = 0;\n\t\traycaster.far = Infinity;\n\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\thit.distance -= 1e5;\n\n\t\t}\n\n\t\treturn hit;\n\n\t}\n\n\t// update the drag action\n\t_updatePosition( deltaTime ) {\n\n\t\tconst {\n\t\t\traycaster,\n\t\t\tcamera,\n\t\t\tpivotPoint,\n\t\t\tup,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tstate,\n\t\t\tdragInertia,\n\t\t} = this;\n\n\t\tif ( state === DRAG ) {\n\n\t\t\t// get the pointer and plane\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tadjustedPointerToCoords( _pointer, domElement, _pointer );\n\n\t\t\t_plane.setFromNormalAndCoplanarPoint( up, pivotPoint );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// prevent the drag distance from getting too severe by limiting the drag point\n\t\t\t// to a reasonable angle with the drag plane\n\t\t\tif ( Math.abs( raycaster.ray.direction.dot( up ) ) < DRAG_PLANE_THRESHOLD ) {\n\n\t\t\t\t// rotate the pointer direction down to the correct angle for horizontal dragging\n\t\t\t\tconst angle = Math.acos( DRAG_PLANE_THRESHOLD );\n\n\t\t\t\t_rotationAxis\n\t\t\t\t\t.crossVectors( raycaster.ray.direction, up )\n\t\t\t\t\t.normalize();\n\n\t\t\t\traycaster.ray.direction\n\t\t\t\t\t.copy( up )\n\t\t\t\t\t.applyAxisAngle( _rotationAxis, angle )\n\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\t// TODO: dragging causes the camera to rise because we're getting \"pushed\" up by lower resolution tiles and\n\t\t\t// don't lower back down. We should maintain a target height above tiles where possible\n\t\t\t// prevent the drag from inverting\n\n\t\t\t// if we drag to a point that's near the edge of the earth then we want to prevent it\n\t\t\t// from wrapping around and causing unexpected rotations\n\t\t\tthis.getUpDirection( pivotPoint, _localUp );\n\t\t\tif ( Math.abs( raycaster.ray.direction.dot( _localUp ) ) < DRAG_UP_THRESHOLD ) {\n\n\t\t\t\tconst angle = Math.acos( DRAG_UP_THRESHOLD );\n\n\t\t\t\t_rotationAxis\n\t\t\t\t\t.crossVectors( raycaster.ray.direction, _localUp )\n\t\t\t\t\t.normalize();\n\n\t\t\t\traycaster.ray.direction\n\t\t\t\t\t.copy( _localUp )\n\t\t\t\t\t.applyAxisAngle( _rotationAxis, angle )\n\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\t// find the point on the plane that we should drag to\n\t\t\tif ( raycaster.ray.intersectPlane( _plane, _vec ) ) {\n\n\t\t\t\t_delta.subVectors( pivotPoint, _vec );\n\t\t\t\tcamera.position.add( _delta );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t// update the drag inertia\n\t\t\t\t_delta.multiplyScalar( 1 / deltaTime );\n\t\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdragInertia.copy( _delta );\n\t\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateRotation( deltaTime ) {\n\n\t\tconst {\n\t\t\tpivotPoint,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tstate,\n\t\t\trotationInertia,\n\t\t} = this;\n\n\t\tif ( state === ROTATE ) {\n\n\t\t\t// get the rotation motion and divide out the container height to normalize for element size\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tpointerTracker.getPreviousCenterPoint( _prevPointer );\n\t\t\t_deltaPointer.subVectors( _pointer, _prevPointer ).multiplyScalar( 2 * Math.PI / domElement.clientHeight );\n\n\t\t\tthis._applyRotation( _deltaPointer.x, _deltaPointer.y, pivotPoint );\n\n\t\t\t// update rotation inertia\n\t\t\t_deltaPointer.multiplyScalar( 1 / deltaTime );\n\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t} else {\n\n\t\t\t\trotationInertia.copy( _deltaPointer );\n\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_applyRotation( x, y, pivotPoint ) {\n\n\t\tif ( x === 0 && y === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tminAltitude,\n\t\t\tmaxAltitude,\n\t\t\trotationSpeed,\n\t\t} = this;\n\n\t\tconst azimuth = - x * rotationSpeed;\n\t\tlet altitude = y * rotationSpeed;\n\n\t\t// calculate current angles and clamp\n\t\t_forward.set( 0, 0, 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\t\tthis.getUpDirection( pivotPoint, _localUp );\n\n\t\t// get the signed angle relative to the top down view\n\t\tlet angle;\n\t\tif ( _localUp.dot( _forward ) > 1 - 1e-10 ) {\n\n\t\t\tangle = 0;\n\n\t\t} else {\n\n\t\t\t_vec.crossVectors( _localUp, _forward ).normalize();\n\n\t\t\tconst sign = Math.sign( _vec.dot( _right ) );\n\t\t\tangle = sign * _localUp.angleTo( _forward );\n\n\t\t}\n\n\t\t// clamp the rotation to be within the provided limits\n\t\t// clamp to 0 here, as well, so we don't \"pop\" to the the value range\n\t\tif ( altitude > 0 ) {\n\n\t\t\taltitude = Math.min( angle - minAltitude, altitude );\n\t\t\taltitude = Math.max( 0, altitude );\n\n\t\t} else {\n\n\t\t\taltitude = Math.max( angle - maxAltitude, altitude );\n\t\t\taltitude = Math.min( 0, altitude );\n\n\t\t}\n\n\t\t// rotate around the up axis\n\t\t_quaternion.setFromAxisAngle( _localUp, azimuth );\n\t\tmakeRotateAroundPoint( pivotPoint, _quaternion, _rotMatrix );\n\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\n\t\t// get a rotation axis for altitude and rotate\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\t\t_quaternion.setFromAxisAngle( _right, - altitude );\n\t\tmakeRotateAroundPoint( pivotPoint, _quaternion, _rotMatrix );\n\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\n\t\t// update the transform members\n\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t}\n\n\t// sets the \"up\" axis for the current surface of the tileset\n\t_setFrame( newUp ) {\n\n\t\tconst {\n\t\t\tup,\n\t\t\tcamera,\n\t\t\tzoomPoint,\n\t\t\tzoomDirectionSet,\n\t\t\tzoomPointSet,\n\t\t\tscaleZoomOrientationAtEdges,\n\t\t} = this;\n\n\t\t// If we're zooming then reorient around the zoom point\n\t\tif ( zoomDirectionSet && ( zoomPointSet || this._updateZoomPoint() ) ) {\n\n\t\t\t// get the amount needed to rotate\n\t\t\t_quaternion.setFromUnitVectors( up, newUp );\n\n\t\t\tif ( scaleZoomOrientationAtEdges ) {\n\n\t\t\t\tthis.getUpDirection( zoomPoint, _vec );\n\n\t\t\t\tlet amt = Math.max( _vec.dot( up ) - 0.6, 0 ) / 0.4;\n\t\t\t\tamt = MathUtils.mapLinear( amt, 0, 0.5, 0, 1 );\n\t\t\t\tamt = Math.min( amt, 1 );\n\n\t\t\t\t// scale the value if we're using an orthographic camera so\n\t\t\t\t// GlobeControls works correctly\n\t\t\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\t\t\tamt *= 0.1;\n\n\t\t\t\t}\n\n\t\t\t\t_quaternion.slerp( _identityQuat, 1.0 - amt );\n\n\t\t\t}\n\n\t\t\t// rotates the camera position around the point being zoomed in to\n\t\t\tmakeRotateAroundPoint( zoomPoint, _quaternion, _rotMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t\t// recompute the zoom direction after updating rotation to align with frame\n\t\t\tthis.zoomDirectionSet = false;\n\t\t\tthis._updateZoomDirection();\n\n\t\t}\n\n\t\tup.copy( newUp );\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t_raycast( raycaster ) {\n\n\t\tconst { scene, useFallbackPlane, fallbackPlane } = this;\n\t\tconst result = raycaster.intersectObject( scene )[ 0 ] || null;\n\t\tif ( result ) {\n\n\t\t\treturn result;\n\n\t\t} else if ( useFallbackPlane ) {\n\n\t\t\t// if we don't hit any geometry then try to intersect the fallback\n\t\t\t// plane so the camera can still be manipulated\n\t\t\tconst plane = fallbackPlane;\n\t\t\tif ( raycaster.ray.intersectPlane( plane, _vec ) ) {\n\n\t\t\t\tconst planeHit = {\n\t\t\t\t\tpoint: _vec.clone(),\n\t\t\t\t\tdistance: raycaster.ray.origin.distanceTo( _vec ),\n\t\t\t\t};\n\n\t\t\t\treturn planeHit;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// tilt the camera to align with the provided \"up\" value\n\t_alignCameraUp( up, alpha = 1 ) {\n\n\t\tconst { camera, state, pivotPoint, zoomPoint, zoomPointSet } = this;\n\n\t\t// get the transform vectors\n\t\tcamera.updateMatrixWorld();\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( - 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\n\t\t// compute an alpha based on the camera direction so we don't try to update the up direction\n\t\t// when the camera is facing that way.\n\t\tlet multiplier = MathUtils.mapLinear( 1 - Math.abs( _forward.dot( up ) ), 0, 0.2, 0, 1 );\n\t\tmultiplier = MathUtils.clamp( multiplier, 0, 1 );\n\t\talpha *= multiplier;\n\n\t\t// calculate the target direction for the right-facing vector\n\t\t_targetRight.crossVectors( up, _forward );\n\t\t_targetRight.lerp( _right, 1 - alpha ).normalize();\n\n\t\t// adjust the camera transformation\n\t\t_quaternion.setFromUnitVectors( _right, _targetRight );\n\t\tcamera.quaternion.premultiply( _quaternion );\n\n\t\t// calculate the active point\n\t\tlet fixedPoint = null;\n\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\tfixedPoint = _pos.copy( pivotPoint );\n\n\t\t} else if ( zoomPointSet ) {\n\n\t\t\tfixedPoint = _pos.copy( zoomPoint );\n\n\t\t}\n\n\t\t// shift the camera in an effort to keep the fixed point in the same spot\n\t\tif ( fixedPoint ) {\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.copy( fixedPoint ).applyMatrix4( _invMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\t_center.subVectors( fixedPoint, _vec );\n\t\t\tcamera.position.add( _center );\n\n\t\t}\n\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t// clamp rotation to the given \"up\" vector\n\t_clampRotation( up ) {\n\n\t\tconst { camera, minAltitude, maxAltitude, state, pivotPoint, zoomPoint, zoomPointSet } = this;\n\n\t\tcamera.updateMatrixWorld();\n\n\t\t// calculate current angles and clamp\n\t\t_forward.set( 0, 0, 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\n\t\t// get the signed angle relative to the top down view\n\t\tlet angle;\n\t\tif ( up.dot( _forward ) > 1 - 1e-10 ) {\n\n\t\t\tangle = 0;\n\n\t\t} else {\n\n\t\t\t_vec.crossVectors( up, _forward );\n\n\t\t\tconst sign = Math.sign( _vec.dot( _right ) );\n\t\t\tangle = sign * up.angleTo( _forward );\n\n\t\t}\n\n\t\t// find the angle to target\n\t\tlet targetAngle;\n\t\tif ( angle > maxAltitude ) {\n\n\t\t\ttargetAngle = maxAltitude;\n\n\t\t} else if ( angle < minAltitude ) {\n\n\t\t\ttargetAngle = minAltitude;\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// construct a rotation basis\n\t\t_forward.copy( up );\n\t\t_quaternion.setFromAxisAngle( _right, targetAngle );\n\t\t_forward.applyQuaternion( _quaternion ).normalize();\n\t\t_vec.crossVectors( _forward, _right ).normalize();\n\n\t\t_rotMatrix.makeBasis( _right, _vec, _forward );\n\t\tcamera.quaternion.setFromRotationMatrix( _rotMatrix );\n\n\t\t// calculate the active point\n\t\tlet fixedPoint = null;\n\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\tfixedPoint = _pos.copy( pivotPoint );\n\n\t\t} else if ( zoomPointSet ) {\n\n\t\t\tfixedPoint = _pos.copy( zoomPoint );\n\n\t\t}\n\n\t\t// shift the camera in an effort to keep the fixed point in the same spot\n\t\tif ( fixedPoint ) {\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.copy( fixedPoint ).applyMatrix4( _invMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\t_center.subVectors( fixedPoint, _vec );\n\t\t\tcamera.position.add( _center );\n\n\t\t}\n\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n}\n","import {\n\tMatrix4,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tMathUtils,\n\tRay,\n\tGroup,\n} from 'three';\nimport { DRAG, ZOOM, EnvironmentControls, NONE } from './EnvironmentControls.js';\nimport { makeRotateAroundPoint, adjustedPointerToCoords, setRaycasterFromCamera } from './utils.js';\nimport { Ellipsoid } from '../math/Ellipsoid.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\n\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _rotMatrix = /* @__PURE__ */ new Matrix4();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _targetRight = /* @__PURE__ */ new Vector3();\nconst _globalUp = /* @__PURE__ */ new Vector3();\nconst _quaternion = /* @__PURE__ */ new Quaternion();\nconst _zoomPointUp = /* @__PURE__ */ new Vector3();\nconst _toCenter = /* @__PURE__ */ new Vector3();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _ellipsoid = /* @__PURE__ */ new Ellipsoid();\nconst _pointer = /* @__PURE__ */ new Vector2();\nconst _latLon = {};\n\n// hand picked minimum elevation to tune far plane near surface\nconst MIN_ELEVATION = 2550;\nexport class GlobeControls extends EnvironmentControls {\n\n\tget tilesGroup() {\n\n\t\tconsole.warn( 'GlobeControls: \"tilesGroup\" has been deprecated. Use \"ellipsoidGroup\", instead.' );\n\t\treturn this.ellipsoidFrame;\n\n\t}\n\n\tget ellipsoidFrame() {\n\n\t\treturn this.ellipsoidGroup.matrixWorld;\n\n\t}\n\n\tget ellipsoidFrameInverse() {\n\n\t\tconst { ellipsoidGroup, ellipsoidFrame, _ellipsoidFrameInverse } = this;\n\t\treturn ellipsoidGroup.matrixWorldInverse ?\n\t\t\tellipsoidGroup.matrixWorldInverse :\n\t\t\t_ellipsoidFrameInverse.copy( ellipsoidFrame ).invert();\n\n\t}\n\n\tconstructor( scene = null, camera = null, domElement = null, tilesRenderer = null ) {\n\n\t\t// store which mode the drag stats are in\n\t\tsuper( scene, camera, domElement );\n\n\t\tthis.isGlobeControls = true;\n\n\t\tthis._dragMode = 0;\n\t\tthis._rotationMode = 0;\n\t\tthis.maxZoom = 0.01;\n\t\tthis.nearMargin = 0.25;\n\t\tthis.farMargin = 0;\n\t\tthis.useFallbackPlane = false;\n\t\tthis.autoAdjustCameraRotation = false;\n\n\t\tthis.globeInertia = new Quaternion();\n\t\tthis.globeInertiaFactor = 0;\n\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.ellipsoidGroup = new Group();\n\t\tthis._ellipsoidFrameInverse = new Matrix4();\n\n\t\tif ( tilesRenderer !== null ) {\n\n\t\t\tthis.setTilesRenderer( tilesRenderer );\n\n\t\t}\n\n\t}\n\n\tsetTilesRenderer( tilesRenderer ) {\n\n\t\tsuper.setTilesRenderer( tilesRenderer );\n\t\tif ( tilesRenderer !== null ) {\n\n\t\t\tthis.setEllipsoid( tilesRenderer.ellipsoid, tilesRenderer.group );\n\n\t\t}\n\n\t}\n\n\tsetEllipsoid( ellipsoid, ellipsoidGroup ) {\n\n\t\tthis.ellipsoid = ellipsoid || WGS84_ELLIPSOID.clone();\n\t\tthis.ellipsoidGroup = ellipsoidGroup || new Group();\n\n\t}\n\n\tgetPivotPoint( target ) {\n\n\t\tconst { camera, ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\n\t\t// get camera values\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t// set a ray in the local ellipsoid frame\n\t\t_ray.origin.copy( camera.position );\n\t\t_ray.direction.copy( _forward );\n\t\t_ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t// get the estimated closest point\n\t\tellipsoid\n\t\t\t.closestPointToRayEstimate( _ray, _vec )\n\t\t\t.applyMatrix4( ellipsoidFrame );\n\n\t\t// use the closest point if no pivot was provided or it's closer\n\t\tif (\n\t\t\tsuper.getPivotPoint( target ) === null ||\n\t\t\t_pos.subVectors( target, _ray.origin ).dot( _ray.direction ) > _pos.subVectors( _vec, _ray.origin ).dot( _ray.direction )\n\t\t) {\n\n\t\t\ttarget.copy( _vec );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// get the vector to the center of the provided globe\n\tgetVectorToCenter( target ) {\n\n\t\tconst { ellipsoidFrame, camera } = this;\n\t\treturn target\n\t\t\t.setFromMatrixPosition( ellipsoidFrame )\n\t\t\t.sub( camera.position );\n\n\t}\n\n\t// get the distance to the center of the globe\n\tgetDistanceToCenter() {\n\n\t\treturn this\n\t\t\t.getVectorToCenter( _vec )\n\t\t\t.length();\n\n\t}\n\n\tgetUpDirection( point, target ) {\n\n\t\t// get the \"up\" direction based on the wgs84 ellipsoid\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\t\t_vec.copy( point ).applyMatrix4( ellipsoidFrameInverse );\n\n\t\tellipsoid.getPositionToNormal( _vec, target );\n\t\ttarget.transformDirection( ellipsoidFrame );\n\n\t}\n\n\tgetCameraUpDirection( target ) {\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid, camera } = this;\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\tthis._getVirtualOrthoCameraPosition( _vec );\n\n\t\t\t_vec.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\tellipsoid.getPositionToNormal( _vec, target );\n\t\t\ttarget.transformDirection( ellipsoidFrame );\n\n\t\t} else {\n\n\t\t\tthis.getUpDirection( camera.position, target );\n\n\t\t}\n\n\t}\n\n\tupdate( deltaTime = Math.min( this.clock.getDelta(), 64 / 1000 ) ) {\n\n\t\tif ( ! this.enabled || ! this.camera || deltaTime === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { camera, pivotMesh } = this;\n\n\t\t// if we're outside the transition threshold then we toggle some reorientation behavior\n\t\t// when adjusting the up frame while moving the camera\n\t\tif ( this._isNearControls() ) {\n\n\t\t\tthis.scaleZoomOrientationAtEdges = this.zoomDelta < 0;\n\n\t\t} else {\n\n\t\t\tif ( this.state !== NONE && this._dragMode !== 1 && this._rotationMode !== 1 ) {\n\n\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t}\n\n\t\t\tthis.scaleZoomOrientationAtEdges = false;\n\n\t\t}\n\n\t\tconst adjustCameraRotation = this.needsUpdate || this._inertiaNeedsUpdate();\n\n\t\t// fire basic controls update\n\t\tsuper.update( deltaTime );\n\n\t\t// update the camera planes and the ortho camera position\n\t\tthis.adjustCamera( camera );\n\n\t\t// align the camera up vector if the camera as updated\n\t\tif ( adjustCameraRotation && this._isNearControls() ) {\n\n\t\t\tthis.getCameraUpDirection( _globalUp );\n\t\t\tthis._alignCameraUp( _globalUp, 1 );\n\n\t\t\tthis.getCameraUpDirection( _globalUp );\n\t\t\tthis._clampRotation( _globalUp );\n\n\t\t}\n\n\t}\n\n\n\t// Updates the passed camera near and far clip planes to encapsulate the ellipsoid from the\n\t// current position in addition to adjusting the height.\n\tadjustCamera( camera ) {\n\n\t\tsuper.adjustCamera( camera );\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid, nearMargin, farMargin } = this;\n\t\tconst maxRadius = Math.max( ...ellipsoid.radius );\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t// adjust the clip planes\n\t\t\tconst distanceToCenter = _vec\n\t\t\t\t.setFromMatrixPosition( ellipsoidFrame )\n\t\t\t\t.sub( camera.position ).length();\n\n\t\t\t// update the projection matrix\n\t\t\t// interpolate from the 25% radius margin around the globe down to the surface\n\t\t\t// so we can avoid z fighting when near value is too far at a high altitude\n\t\t\tconst margin = nearMargin * maxRadius;\n\t\t\tconst alpha = MathUtils.clamp( ( distanceToCenter - maxRadius ) / margin, 0, 1 );\n\t\t\tconst minNear = MathUtils.lerp( 1, 1000, alpha );\n\t\t\tcamera.near = Math.max( minNear, distanceToCenter - maxRadius - margin );\n\n\t\t\t// update the far plane to the horizon distance\n\t\t\t_pos.copy( camera.position ).applyMatrix4( ellipsoidFrameInverse );\n\t\t\tellipsoid.getPositionToCartographic( _pos, _latLon );\n\n\t\t\t// use a minimum elevation for computing the horizon distance to avoid the far clip\n\t\t\t// plane approaching zero or clipping mountains over the horizon in the distance as\n\t\t\t// the camera goes to or below sea level.\n\t\t\tconst elevation = Math.max( ellipsoid.getPositionElevation( _pos ), MIN_ELEVATION );\n\t\t\tconst horizonDistance = ellipsoid.calculateHorizonDistance( _latLon.lat, elevation );\n\n\t\t\tcamera.far = horizonDistance + 0.1 + maxRadius * farMargin;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t} else {\n\n\t\t\tthis._getVirtualOrthoCameraPosition( camera.position, camera );\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.setFromMatrixPosition( ellipsoidFrame ).applyMatrix4( _invMatrix );\n\n\t\t\tconst distanceToCenter = - _vec.z;\n\t\t\tcamera.near = distanceToCenter - maxRadius * ( 1 + nearMargin );\n\t\t\tcamera.far = distanceToCenter + 0.1 + maxRadius * farMargin;\n\n\t\t\t// adjust the position of the ortho camera such that the near value is 0\n\t\t\tcamera.position.addScaledVector( _forward, camera.near );\n\t\t\tcamera.far -= camera.near;\n\t\t\tcamera.near = 0;\n\n\t\t\tcamera.updateProjectionMatrix();\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\t// resets the \"stuck\" drag modes\n\tsetState( ...args ) {\n\n\t\tsuper.setState( ...args );\n\t\tthis._dragMode = 0;\n\t\tthis._rotationMode = 0;\n\n\t}\n\n\t_updateInertia( deltaTime ) {\n\n\t\tsuper._updateInertia( deltaTime );\n\n\t\tconst {\n\t\t\tglobeInertia,\n\t\t\tenableDamping,\n\t\t\tdampingFactor,\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tminDistance,\n\t\t\tinertiaTargetDistance,\n\t\t\tellipsoidFrame,\n\t\t} = this;\n\n\t\tif ( ! this.enableDamping || this.inertiaStableFrames > 1 ) {\n\n\t\t\tthis.globeInertiaFactor = 0;\n\t\t\tthis.globeInertia.identity();\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst factor = Math.pow( 2, - deltaTime / dampingFactor );\n\t\tconst stableDistance = Math.max( camera.near, cameraRadius, minDistance, inertiaTargetDistance );\n\t\tconst resolution = 2 * 1e3;\n\t\tconst pixelWidth = 2 / resolution;\n\t\tconst pixelThreshold = 0.25 * pixelWidth;\n\n\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\n\t\tif ( this.globeInertiaFactor !== 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _pos.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _pos );\n\t\t\t_pos.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// get implied angle\n\t\t\t_vec.sub( _center ).normalize();\n\t\t\t_pos.sub( _center ).normalize();\n\n\t\t\tthis.globeInertiaFactor *= factor;\n\t\t\tconst threshold = _vec.angleTo( _pos ) / deltaTime;\n\t\t\tconst globeAngle = 2 * Math.acos( globeInertia.w ) * this.globeInertiaFactor;\n\t\t\tif ( globeAngle < threshold || ! enableDamping ) {\n\n\t\t\t\tthis.globeInertiaFactor = 0;\n\t\t\t\tglobeInertia.identity();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.globeInertiaFactor !== 0 ) {\n\n\t\t\t// ensure our w component is non-one if the xyz values are\n\t\t\t// non zero to ensure we can animate\n\t\t\tif (\n\t\t\t\tglobeInertia.w === 1 && (\n\t\t\t\t\tglobeInertia.x !== 0 ||\n\t\t\t\t\tglobeInertia.y !== 0 ||\n\t\t\t\t\tglobeInertia.z !== 0\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tglobeInertia.w = Math.min( globeInertia.w, 1 - 1e-9 );\n\n\t\t\t}\n\n\t\t\t// construct the rotation matrix\n\t\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\t\t\t_quaternion.identity().slerp( globeInertia, this.globeInertiaFactor * deltaTime );\n\t\t\tmakeRotateAroundPoint( _center, _quaternion, _rotMatrix );\n\n\t\t\t// apply the rotation\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t}\n\n\t}\n\n\t_inertiaNeedsUpdate() {\n\n\t\treturn super._inertiaNeedsUpdate() || this.globeInertiaFactor !== 0;\n\n\t}\n\n\t_updatePosition( deltaTime ) {\n\n\t\tif ( this.state === DRAG ) {\n\n\t\t\t// save the drag mode state so we can update the pivot mesh visuals in \"update\"\n\t\t\tif ( this._dragMode === 0 ) {\n\n\t\t\t\tthis._dragMode = this._isNearControls() ? 1 : - 1;\n\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\traycaster,\n\t\t\t\tcamera,\n\t\t\t\tpivotPoint,\n\t\t\t\tpointerTracker,\n\t\t\t\tdomElement,\n\t\t\t\tellipsoidFrame,\n\t\t\t\tellipsoidFrameInverse,\n\t\t\t} = this;\n\n\t\t\t// reuse cache variables\n\t\t\tconst pivotDir = _pos;\n\t\t\tconst newPivotDir = _targetRight;\n\n\t\t\t// get the pointer and ray\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tadjustedPointerToCoords( _pointer, domElement, _pointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// transform to ellipsoid frame\n\t\t\traycaster.ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\t// construct an ellipsoid that matches a sphere with the radius of the globe so\n\t\t\t// the drag position matches where the initial click was\n\t\t\tconst pivotRadius = _vec.copy( pivotPoint ).applyMatrix4( ellipsoidFrameInverse ).length();\n\t\t\t_ellipsoid.radius.setScalar( pivotRadius );\n\n\t\t\t// if we drag off the sphere then end the operation and follow through on the inertia\n\t\t\tif ( ! _ellipsoid.intersectRay( raycaster.ray, _vec ) ) {\n\n\t\t\t\tthis.resetState();\n\t\t\t\tthis._updateInertia( deltaTime );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_vec.applyMatrix4( ellipsoidFrame );\n\n\t\t\t// get the point directions\n\t\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\t\t\tpivotDir.subVectors( pivotPoint, _center ).normalize();\n\t\t\tnewPivotDir.subVectors( _vec, _center ).normalize();\n\n\t\t\t// construct the rotation\n\t\t\t_quaternion.setFromUnitVectors( newPivotDir, pivotDir );\n\t\t\tmakeRotateAroundPoint( _center, _quaternion, _rotMatrix );\n\n\t\t\t// apply the rotation\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t} else {\n\n\t\t\t\tthis.globeInertia.copy( _quaternion );\n\t\t\t\tthis.globeInertiaFactor = 1 / deltaTime;\n\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// disable rotation once we're outside the control transition\n\t_updateRotation( ...args ) {\n\n\t\tif ( this._rotationMode === 1 || this._isNearControls() ) {\n\n\t\t\tthis._rotationMode = 1;\n\t\t\tsuper._updateRotation( ...args );\n\n\t\t} else {\n\n\t\t\tthis.pivotMesh.visible = false;\n\t\t\tthis._rotationMode = - 1;\n\n\t\t}\n\n\n\t}\n\n\t_updateZoom() {\n\n\t\tconst { zoomDelta, ellipsoid, zoomSpeed, zoomPoint, camera, maxZoom, state } = this;\n\n\t\tif ( state !== ZOOM && zoomDelta === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// reset momentum\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\tthis.globeInertia.identity();\n\t\tthis.globeInertiaFactor = 0;\n\n\t\t// used to scale the tilt transitions based on zoom intensity\n\t\tconst deltaAlpha = MathUtils.clamp( MathUtils.mapLinear( Math.abs( zoomDelta ), 0, 20, 0, 1 ), 0, 1 );\n\t\tif ( this._isNearControls() || zoomDelta > 0 ) {\n\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// When zooming try to tilt the camera towards the center of the planet to avoid the globe\n\t\t\t// spinning as you zoom out from the horizon\n\t\t\tif ( zoomDelta < 0 && ( this.zoomPointSet || this._updateZoomPoint() ) ) {\n\n\t\t\t\t// get the forward vector and vector toward the center of the ellipsoid\n\t\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).normalize();\n\t\t\t\t_toCenter.copy( this.up ).multiplyScalar( - 1 );\n\n\t\t\t\t// Calculate alpha values to use to scale the amount of tilt that occurs as the camera moves.\n\t\t\t\t// Scales based on mouse position near the horizon and current tilt.\n\t\t\t\tthis.getUpDirection( zoomPoint, _zoomPointUp );\n\t\t\t\tconst upAlpha = MathUtils.clamp( MathUtils.mapLinear( - _zoomPointUp.dot( _toCenter ), 1, 0.95, 0, 1 ), 0, 1 );\n\t\t\t\tconst forwardAlpha = 1 - _forward.dot( _toCenter );\n\t\t\t\tconst cameraAlpha = camera.isOrthographicCamera ? 0.05 : 1;\n\t\t\t\tconst adjustedDeltaAlpha = MathUtils.clamp( deltaAlpha * 3, 0, 1 );\n\n\t\t\t\t// apply scale\n\t\t\t\tconst alpha = Math.min( upAlpha * forwardAlpha * cameraAlpha * adjustedDeltaAlpha, 0.1 );\n\t\t\t\t_toCenter.lerpVectors( _forward, _toCenter, alpha ).normalize();\n\n\t\t\t\t// perform rotation\n\t\t\t\t_quaternion.setFromUnitVectors( _forward, _toCenter );\n\t\t\t\tmakeRotateAroundPoint( zoomPoint, _quaternion, _rotMatrix );\n\t\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _toCenter );\n\n\t\t\t\t// update zoom direction\n\t\t\t\tthis.zoomDirection.subVectors( zoomPoint, camera.position ).normalize();\n\n\t\t\t}\n\n\t\t\tsuper._updateZoom();\n\n\t\t} else if ( camera.isPerspectiveCamera ) {\n\n\t\t\t// orient the camera to focus on the earth during the zoom\n\t\t\tconst transitionDistance = this._getPerspectiveTransitionDistance();\n\t\t\tconst maxDistance = this._getMaxPerspectiveDistance();\n\t\t\tconst distanceAlpha = MathUtils.mapLinear( this.getDistanceToCenter(), transitionDistance, maxDistance, 0, 1 );\n\t\t\tthis._tiltTowardsCenter( MathUtils.lerp( 0, 0.4, distanceAlpha * deltaAlpha ) );\n\t\t\tthis._alignCameraUpToNorth( MathUtils.lerp( 0, 0.2, distanceAlpha * deltaAlpha ) );\n\n\t\t\t// calculate zoom in a similar way to environment controls so\n\t\t\t// the zoom speeds are comparable\n\t\t\tconst dist = this.getDistanceToCenter() - ellipsoid.radius.x;\n\t\t\tconst scale = zoomDelta * dist * zoomSpeed * 0.0025;\n\t\t\tconst clampedScale = Math.max( scale, Math.min( this.getDistanceToCenter() - maxDistance, 0 ) );\n\n\t\t\t// zoom out directly from the globe center\n\t\t\tthis.getVectorToCenter( _vec ).normalize();\n\t\t\tthis.camera.position.addScaledVector( _vec, clampedScale );\n\t\t\tthis.camera.updateMatrixWorld();\n\n\t\t\tthis.zoomDelta = 0;\n\n\t\t} else {\n\n\t\t\tconst transitionZoom = this._getOrthographicTransitionZoom();\n\t\t\tconst minZoom = this._getMinOrthographicZoom();\n\t\t\tconst distanceAlpha = MathUtils.mapLinear( camera.zoom, transitionZoom, minZoom, 0, 1 );\n\t\t\tthis._tiltTowardsCenter( MathUtils.lerp( 0, 0.4, distanceAlpha * deltaAlpha ) );\n\t\t\tthis._alignCameraUpToNorth( MathUtils.lerp( 0, 0.2, distanceAlpha * deltaAlpha ) );\n\n\t\t\tconst scale = this.zoomDelta;\n\t\t\tconst normalizedDelta = Math.pow( 0.95, Math.abs( scale * 0.05 ) );\n\t\t\tconst scaleFactor = scale > 0 ? 1 / Math.abs( normalizedDelta ) : normalizedDelta;\n\n\t\t\tconst maxScaleFactor = minZoom / camera.zoom;\n\t\t\tconst clampedScaleFactor = Math.max( scaleFactor * zoomSpeed, Math.min( maxScaleFactor, 1 ) );\n\n\t\t\tcamera.zoom = Math.min( maxZoom, camera.zoom * clampedScaleFactor );\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\tthis.zoomDelta = 0;\n\t\t\tthis.zoomDirectionSet = false;\n\n\t\t}\n\n\t}\n\n\t// tilt the camera to align with north\n\t_alignCameraUpToNorth( alpha ) {\n\n\t\tconst { ellipsoidFrame } = this;\n\t\t_globalUp.set( 0, 0, 1 ).transformDirection( ellipsoidFrame );\n\t\tthis._alignCameraUp( _globalUp, alpha );\n\n\t}\n\n\t// tilt the camera to look at the center of the globe\n\t_tiltTowardsCenter( alpha ) {\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tellipsoidFrame,\n\t\t} = this;\n\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).normalize();\n\t\t_vec.setFromMatrixPosition( ellipsoidFrame ).sub( camera.position ).normalize();\n\t\t_vec.lerp( _forward, 1 - alpha ).normalize();\n\n\t\t_quaternion.setFromUnitVectors( _forward, _vec );\n\t\tcamera.quaternion.premultiply( _quaternion );\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t// returns the perspective camera transition distance can move to based on globe size and fov\n\t_getPerspectiveTransitionDistance() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isPerspectiveCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// When the smallest fov spans 65% of the ellipsoid then we use the near controls\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst fovHoriz = 2 * Math.atan( Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 ) * camera.aspect );\n\t\tconst distVert = ellipsoidRadius / Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 );\n\t\tconst distHoriz = ellipsoidRadius / Math.tan( fovHoriz * 0.5 );\n\t\tconst dist = Math.max( distVert, distHoriz );\n\n\t\treturn dist;\n\n\t}\n\n\t// returns the max distance the perspective camera can move to based on globe size and fov\n\t_getMaxPerspectiveDistance() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isPerspectiveCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// allow for zooming out such that the ellipsoid is half the size of the largest fov\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst fovHoriz = 2 * Math.atan( Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 ) * camera.aspect );\n\t\tconst distVert = ellipsoidRadius / Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 );\n\t\tconst distHoriz = ellipsoidRadius / Math.tan( fovHoriz * 0.5 );\n\t\tconst dist = 2 * Math.max( distVert, distHoriz );\n\n\t\treturn dist;\n\n\t}\n\n\t// returns the transition threshold for orthographic zoom based on the globe size and camera settings\n\t_getOrthographicTransitionZoom() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.max( orthoHeight, orthoWidth );\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst ellipsoidDiameter = 2 * ellipsoidRadius;\n\t\treturn 2 * orthoSize / ellipsoidDiameter;\n\n\t}\n\n\t// returns the minimum allowed orthographic zoom based on the globe size and camera settings\n\t_getMinOrthographicZoom() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.min( orthoHeight, orthoWidth );\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst ellipsoidDiameter = 2 * ellipsoidRadius;\n\t\treturn 0.7 * orthoSize / ellipsoidDiameter;\n\n\t}\n\n\t// returns the \"virtual position\" of the orthographic based on where it is and\n\t// where it's looking primarily so we can reasonably position the camera object\n\t// in space and derive a reasonable \"up\" value.\n\t_getVirtualOrthoCameraPosition( target, camera = this.camera ) {\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// get ray in globe coordinate frame\n\t\t_ray.origin.copy( camera.position );\n\t\t_ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t_ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t// get the closest point to the ray on the globe in the global coordinate frame\n\t\tellipsoid\n\t\t\t.closestPointToRayEstimate( _ray, _pos )\n\t\t\t.applyMatrix4( ellipsoidFrame );\n\n\t\t// get ortho camera info\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.max( orthoHeight, orthoWidth ) / camera.zoom;\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t// ensure we move the camera exactly along the forward vector to avoid shifting\n\t\t// the camera in other directions due to floating point error\n\t\tconst dist = _pos.sub( camera.position ).dot( _forward );\n\t\ttarget.copy( camera.position ).addScaledVector( _forward, dist - orthoSize * 4 );\n\n\t}\n\n\t_isNearControls() {\n\n\t\tconst { camera } = this;\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\treturn this.getDistanceToCenter() < this._getPerspectiveTransitionDistance();\n\n\t\t} else {\n\n\t\t\treturn camera.zoom > this._getOrthographicTransitionZoom();\n\n\t\t}\n\n\t}\n\n\t_raycast( raycaster ) {\n\n\t\tconst result = super._raycast( raycaster );\n\t\tif ( result === null ) {\n\n\t\t\t// if there was no hit then fallback to intersecting the ellipsoid.\n\t\t\tconst { ellipsoid, ellipsoidFrame, ellipsoidFrameInverse } = this;\n\t\t\t_ray.copy( raycaster.ray ).applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\tconst point = ellipsoid.intersectRay( _ray, _vec );\n\t\t\tif ( point !== null ) {\n\n\t\t\t\tpoint.applyMatrix4( ellipsoidFrame );\n\t\t\t\treturn {\n\t\t\t\t\tpoint: point.clone(),\n\t\t\t\t\tdistance: point.distanceTo( raycaster.ray.origin ),\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n}\n","import { Clock, EventDispatcher, MathUtils, OrthographicCamera, PerspectiveCamera, Quaternion, Vector3 } from 'three';\n\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _orthographicCamera = /* @__PURE__ */ new OrthographicCamera();\nconst _targetOffset = /* @__PURE__ */ new Vector3();\nconst _perspOffset = /* @__PURE__ */ new Vector3();\nconst _orthoOffset = /* @__PURE__ */ new Vector3();\nconst _quat = /* @__PURE__ */ new Quaternion();\nconst _targetQuat = /* @__PURE__ */ new Quaternion();\n\nexport class CameraTransitionManager extends EventDispatcher {\n\n\tget animating() {\n\n\t\treturn this._alpha !== 0 && this._alpha !== 1;\n\n\t}\n\n\tget alpha() {\n\n\t\t// the transition alpha towards the target camera\n\t\treturn this._target === 0 ? 1 - this._alpha : this._alpha;\n\n\t}\n\n\tget camera() {\n\n\t\tif ( this._alpha === 0 ) return this.perspectiveCamera;\n\t\tif ( this._alpha === 1 ) return this.orthographicCamera;\n\t\treturn this.transitionCamera;\n\n\t}\n\n\tget mode() {\n\n\t\treturn this._target === 0 ? 'perspective' : 'orthographic';\n\n\t}\n\n\tset mode( v ) {\n\n\t\tif ( v === this.mode ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst prevCamera = this.camera;\n\t\tif ( v === 'perspective' ) {\n\n\t\t\tthis._target = 0;\n\t\t\tthis._alpha = 0;\n\n\t\t} else {\n\n\t\t\tthis._target = 1;\n\t\t\tthis._alpha = 1;\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'camera-change', camera: this.camera, prevCamera: prevCamera } );\n\n\t}\n\n\tconstructor( perspectiveCamera = new PerspectiveCamera(), orthographicCamera = new OrthographicCamera() ) {\n\n\t\tsuper();\n\n\t\tthis.perspectiveCamera = perspectiveCamera;\n\t\tthis.orthographicCamera = orthographicCamera;\n\t\tthis.transitionCamera = new PerspectiveCamera();\n\n\t\t// settings\n\t\tthis.orthographicPositionalZoom = true;\n\t\tthis.orthographicOffset = 50;\n\t\tthis.fixedPoint = new Vector3();\n\t\tthis.duration = 200;\n\t\tthis.autoSync = true;\n\t\tthis.easeFunction = x => x;\n\n\t\tthis._target = 0;\n\t\tthis._alpha = 0;\n\t\tthis._clock = new Clock();\n\n\t}\n\n\ttoggle() {\n\n\t\t// reset the clock for cases where we're not calling \"update\" every frame\n\t\tthis._target = this._target === 1 ? 0 : 1;\n\t\tthis._clock.getDelta();\n\n\t\tthis.dispatchEvent( { type: 'toggle' } );\n\n\t}\n\n\tupdate( deltaTime = Math.min( this._clock.getDelta(), 64 / 1000 ) ) {\n\n\t\t// update transforms\n\t\tif ( this.autoSync ) {\n\n\t\t\tthis.syncCameras();\n\n\t\t}\n\n\t\t// perform transition\n\t\tconst { perspectiveCamera, orthographicCamera, transitionCamera, camera } = this;\n\t\tconst delta = deltaTime * 1e3;\n\n\t\tif ( this._alpha !== this._target ) {\n\n\t\t\tconst direction = Math.sign( this._target - this._alpha );\n\t\t\tconst step = direction * delta / this.duration;\n\t\t\tthis._alpha = MathUtils.clamp( this._alpha + step, 0, 1 );\n\n\t\t\tthis.dispatchEvent( { type: 'change', alpha: this.alpha } );\n\n\t\t}\n\n\t\t// find the new camera\n\t\tconst prevCamera = camera;\n\t\tlet newCamera = null;\n\t\tif ( this._alpha === 0 ) {\n\n\t\t\tnewCamera = perspectiveCamera;\n\n\t\t} else if ( this._alpha === 1 ) {\n\n\t\t\tnewCamera = orthographicCamera;\n\n\t\t} else {\n\n\t\t\tnewCamera = transitionCamera;\n\t\t\tthis._updateTransitionCamera();\n\n\t\t}\n\n\t\tif ( prevCamera !== newCamera ) {\n\n\t\t\tif ( newCamera === transitionCamera ) {\n\n\t\t\t\tthis.dispatchEvent( { type: 'transition-start' } );\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( { type: 'camera-change', camera: newCamera, prevCamera: prevCamera } );\n\n\t\t\tif ( prevCamera === transitionCamera ) {\n\n\t\t\t\tthis.dispatchEvent( { type: 'transition-end' } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsyncCameras() {\n\n\t\tconst fromCamera = this._getFromCamera();\n\t\tconst { perspectiveCamera, orthographicCamera, transitionCamera, fixedPoint } = this;\n\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( fromCamera.matrixWorld ).normalize();\n\n\t\tif ( fromCamera.isPerspectiveCamera ) {\n\n\t\t\t// offset the orthographic camera backwards based on user setting to avoid cases where the ortho\n\t\t\t// camera position will clip into terrain when once transitioned\n\t\t\tif ( this.orthographicPositionalZoom ) {\n\n\t\t\t\torthographicCamera.position.copy( perspectiveCamera.position ).addScaledVector( _forward, - this.orthographicOffset );\n\t\t\t\torthographicCamera.rotation.copy( perspectiveCamera.rotation );\n\t\t\t\torthographicCamera.updateMatrixWorld();\n\n\t\t\t} else {\n\n\t\t\t\tconst orthoDist = _vec.subVectors( fixedPoint, orthographicCamera.position ).dot( _forward );\n\t\t\t\tconst perspDist = _vec.subVectors( fixedPoint, perspectiveCamera.position ).dot( _forward );\n\n\t\t\t\t_vec.copy( perspectiveCamera.position ).addScaledVector( _forward, perspDist );\n\t\t\t\torthographicCamera.rotation.copy( perspectiveCamera.rotation );\n\t\t\t\torthographicCamera.position.copy( _vec ).addScaledVector( _forward, - orthoDist );\n\t\t\t\torthographicCamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\t// calculate the necessary orthographic zoom based on the current perspective camera position\n\t\t\tconst distToPoint = Math.abs( _vec.subVectors( perspectiveCamera.position, fixedPoint ).dot( _forward ) );\n\t\t\tconst projectionHeight = 2 * Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov * 0.5 ) * distToPoint;\n\t\t\tconst orthoHeight = orthographicCamera.top - orthographicCamera.bottom;\n\t\t\torthographicCamera.zoom = orthoHeight / projectionHeight;\n\t\t\torthographicCamera.updateProjectionMatrix();\n\n\t\t} else {\n\n\t\t\t// calculate the target distance from the point\n\t\t\tconst distToPoint = Math.abs( _vec.subVectors( orthographicCamera.position, fixedPoint ).dot( _forward ) );\n\t\t\tconst orthoHeight = ( orthographicCamera.top - orthographicCamera.bottom ) / orthographicCamera.zoom;\n\t\t\tconst targetDist = orthoHeight * 0.5 / Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov * 0.5 );\n\n\t\t\t// set the final camera position so the pivot point is stable\n\t\t\tperspectiveCamera.rotation.copy( orthographicCamera.rotation );\n\t\t\tperspectiveCamera.position.copy( orthographicCamera.position )\n\t\t\t\t.addScaledVector( _forward, distToPoint )\n\t\t\t\t.addScaledVector( _forward, - targetDist );\n\n\t\t\tperspectiveCamera.updateMatrixWorld();\n\n\t\t\t// shift the orthographic camera position so it aligns with the perspective cameras position as\n\t\t\t// calculated by the FoV. This ensures a consistent orthographic position on transition.\n\t\t\tif ( this.orthographicPositionalZoom ) {\n\n\t\t\t\torthographicCamera.position.copy( perspectiveCamera.position ).addScaledVector( _forward, - this.orthographicOffset );\n\t\t\t\torthographicCamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t}\n\n\t\ttransitionCamera.position.copy( perspectiveCamera.position );\n\t\ttransitionCamera.rotation.copy( perspectiveCamera.rotation );\n\n\t}\n\n\t_getTransitionDirection() {\n\n\t\treturn Math.sign( this._target - this._alpha );\n\n\t}\n\n\t_getToCamera() {\n\n\t\tconst dir = this._getTransitionDirection();\n\t\tif ( dir === 0 ) {\n\n\t\t\treturn this._target === 0 ? this.perspectiveCamera : this.orthographicCamera;\n\n\t\t} else if ( dir > 0 ) {\n\n\t\t\treturn this.orthographicCamera;\n\n\t\t} else {\n\n\t\t\treturn this.perspectiveCamera;\n\n\t\t}\n\n\t}\n\n\t_getFromCamera() {\n\n\t\tconst dir = this._getTransitionDirection();\n\t\tif ( dir === 0 ) {\n\n\t\t\treturn this._target === 0 ? this.perspectiveCamera : this.orthographicCamera;\n\n\t\t} else if ( dir > 0 ) {\n\n\t\t\treturn this.perspectiveCamera;\n\n\t\t} else {\n\n\t\t\treturn this.orthographicCamera;\n\n\t\t}\n\n\t}\n\n\t_updateTransitionCamera() {\n\n\t\t// Perform transition interpolation between the orthographic and perspective camera\n\t\t// alpha === 0 : perspective\n\t\t// alpha === 1 : orthographic\n\n\t\tconst { perspectiveCamera, orthographicCamera, transitionCamera, fixedPoint } = this;\n\t\tconst alpha = this.easeFunction( this._alpha );\n\n\t\t// get the forward vector\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( orthographicCamera.matrixWorld ).normalize();\n\n\t\t_orthographicCamera.copy( orthographicCamera );\n\t\t_orthographicCamera.position.addScaledVector( _forward, orthographicCamera.near );\n\t\torthographicCamera.far -= orthographicCamera.near;\n\t\torthographicCamera.near = 0;\n\n\t\t// compute the projection height based on the perspective camera\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( perspectiveCamera.matrixWorld ).normalize();\n\t\tconst distToPoint = Math.abs( _vec.subVectors( perspectiveCamera.position, fixedPoint ).dot( _forward ) );\n\t\tconst projectionHeight = 2 * Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov * 0.5 ) * distToPoint;\n\n\t\t// calculate the orientation to transition to\n\t\tconst targetQuat = _targetQuat.slerpQuaternions( perspectiveCamera.quaternion, _orthographicCamera.quaternion, alpha );\n\n\t\t// calculate the target distance and fov to position the camera at\n\t\tconst targetFov = MathUtils.lerp( perspectiveCamera.fov, 1, alpha );\n\t\tconst targetDistance = projectionHeight * 0.5 / Math.tan( MathUtils.DEG2RAD * targetFov * 0.5 );\n\n\t\t// calculate the offset from the fixed point\n\t\tconst orthoOffset = _orthoOffset.copy( _orthographicCamera.position ).sub( fixedPoint ).applyQuaternion( _quat.copy( _orthographicCamera.quaternion ).invert() );\n\t\tconst perspOffset = _perspOffset.copy( perspectiveCamera.position ).sub( fixedPoint ).applyQuaternion( _quat.copy( perspectiveCamera.quaternion ).invert() );\n\t\tconst targetOffset = _targetOffset.lerpVectors( perspOffset, orthoOffset, alpha );\n\t\ttargetOffset.z -= Math.abs( targetOffset.z ) - targetDistance;\n\n\t\t// calculate distances to the target point so the offset can be accounted for in near plane calculations\n\t\tconst distToPersp = - ( perspOffset.z - targetOffset.z );\n\t\tconst distToOrtho = - ( orthoOffset.z - targetOffset.z );\n\n\t\t// calculate the near and far plane positions\n\t\tconst targetNearPlane = MathUtils.lerp( distToPersp + perspectiveCamera.near, distToOrtho + _orthographicCamera.near, alpha );\n\t\tconst targetFarPlane = MathUtils.lerp( distToPersp + perspectiveCamera.far, distToOrtho + _orthographicCamera.far, alpha );\n\t\tconst planeDelta = Math.max( targetFarPlane, 0 ) - Math.max( targetNearPlane, 0 );\n\n\t\t// NOTE: The \"planeDelta * 1e-5\" can wind up being larger than either of the camera near planes, resulting\n\t\t// in some clipping during the transition phase.\n\n\t\t// update the camera state\n\t\ttransitionCamera.aspect = perspectiveCamera.aspect;\n\t\ttransitionCamera.fov = targetFov;\n\t\ttransitionCamera.near = Math.max( targetNearPlane, planeDelta * 1e-5 );\n\t\ttransitionCamera.far = targetFarPlane;\n\t\ttransitionCamera.position.copy( targetOffset ).applyQuaternion( targetQuat ).add( fixedPoint );\n\t\ttransitionCamera.quaternion.copy( targetQuat );\n\t\ttransitionCamera.updateProjectionMatrix();\n\t\ttransitionCamera.updateMatrixWorld();\n\n\t}\n\n}\n"],"names":["B3DMLoader","B3DMLoaderBase","manager","DefaultLoadingManager","Matrix4","buffer","b3dm","gltfBuffer","resolve","reject","fetchOptions","loader","GLTFLoader","workingPath","adjustmentTransform","model","batchTable","featureTable","scene","rtcCenter","rgb565torgb","rgb565","red5","green6","blue5","red8","green8","blue8","f","Vector2","decodeOctNormal","x","y","target","Vector3","t","MathUtils","DRACO_ATTRIBUTE_MAP","PNTSLoader","PNTSLoaderBase","result","material","PointsMaterial","extensions","translationOffset","geometry","byteOffset","byteLength","properties","dracoLoader","attributeIDs","key","mappedKey","taskConfig","POINTS_LENGTH","POSITION","NORMAL","NORMAL_OCT16P","RGB","RGBA","RGB565","CONSTANT_RGBA","POSITION_QUANTIZED","QUANTIZED_VOLUME_SCALE","QUANTIZED_VOLUME_OFFSET","BufferGeometry","decodedPositions","i","j","index","BufferAttribute","decodedNormals","n","normal","color","rgbColor","Color","opacity","object","Points","tempFwd","tempUp","tempRight","tempPos","tempQuat","Quaternion","tempSca","tempMat","tempMat2","tempGlobePos","tempEnuFrame","tempLocalQuat","tempLatLon","octDecodeInRange","rangeMax","oldX","I3DMLoader","I3DMLoaderBase","WGS84_ELLIPSOID","url","i3dm","INSTANCES_LENGTH","NORMAL_UP","NORMAL_RIGHT","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P","SCALE_NON_UNIFORM","SCALE","RTC_CENTER","EAST_NORTH_UP","averageVector","instances","meshes","child","instancedMesh","InstancedMesh","l","instance","mesh","CMPTLoader","CMPTLoaderBase","ellipsoid","promises","type","slicedBuffer","promise","results","group","Group","TilesGroup","tilesRenderer","raycaster","intersects","force","elA","elB","isDifferent","itemA","itemB","children","updateParents","updateChildren","_localRay","Ray","_vec","_hitArray","distanceSort","a","b","intersectTileScene","tile","renderer","plugin","intersectTileSceneFirstHist","hit","isTileInitialized","raycastTraverseFirstHit","localRay","activeTiles","array","bestHit","bestHitDistSq","data","boundingVolumeDistSq","hitDistSq","raycastTraverse","boundingVolume","_vecX","_vecY","_vecZ","_sphereVec","_obbVec","TileBoundingVolume","ray","sphere","obb","sphereDistSq","obbDistSq","furthestDist","point","sphereDistance","obbDistance","frustum","otherSphere","otherObb","targetBox","targetMatrix","transform","OBB","scaleX","scaleY","scaleZ","z","radius","Sphere","west","south","east","north","minHeight","maxHeight","region","EllipsoidRegion","_mat3","Matrix3","findIntersectionPoint","plane1","plane2","plane3","A","ExtendedFrustum","Frustum","m","coordinateSystem","planes","points","_mat","_euler","Euler","INITIAL_FRUSTUM_CULLED","tempVector","tempVector2","X_AXIS","Y_AXIS","updateFrustumCulled","toInitialValue","c","TilesRenderer","TilesRendererBase","value","v","args","LoadingManager","listener","EventDispatcher","e","callback","camera","cameras","cameraMap","xOrVec","width","height","cameraVec","root","asset","ext","cameraInfo","info","position","resolution","projection","w","h","found","tilesetDir","parentTile","transformArr","transformInverse","extension","uri","abortSignal","engineData","LoaderUtils.getWorkingPath","tileTransform","upRotationMatrix","fileType","LoaderUtils.readMagicBytes","res","resourcePath","metadata","materials","textures","texture","parent","visible","bytesUsed","estimateBytesUsed","inView","inViewError","inViewDistance","maxCameraError","minCameraDistance","error","distance","pixelSize","sseDenominator","lat","lon","PivotPointMesh","Mesh","PlaneGeometry","PivotMaterial","uniforms","ShaderMaterial","_vec2","PointerTracker","previousPositions","pointerPositions","id","rect","pointerOrder","id0","id1","p0","p1","_matrix","makeRotateAroundPoint","quat","adjustedPointerToCoords","pointer","element","setRaycasterFromCamera","coords","origin","direction","NONE","DRAG","ROTATE","ZOOM","WAITING","DRAG_PLANE_THRESHOLD","DRAG_UP_THRESHOLD","_rotMatrix","_invMatrix","_delta","_pos","_center","_forward","_right","_targetRight","_rotationAxis","_quaternion","_plane","Plane","_localUp","_mouseBefore","_mouseAfter","_identityQuat","_ray","_zoomPointPointer","_pointer","_prevPointer","_deltaPointer","_centerPoint","_startCenterPoint","_changeEvent","_startEvent","_endEvent","EnvironmentControls","domElement","Raycaster","Clock","contextMenuCallback","pointerdownCallback","up","pivotMesh","pointerTracker","pivotPoint","enabled","dot","_pointerMoveQueued","pointermoveCallback","startDist","pointerDist","separateDelta","dragThreshold","parallelDelta","previousDist","pointerupCallback","wheelCallback","delta","deltaSign","normalizedDelta","pointerleaveCallback","document","state","fireEvent","deltaTime","cameraRadius","adjustHeight","autoAdjustCameraRotation","inertiaNeedsUpdate","adjustCameraRotation","zoomDelta","actionHeightOffset","dist","rotationInertia","dragInertia","enableDamping","dampingFactor","minDistance","inertiaTargetDistance","factor","stableDistance","pixelThreshold","threshold","zoomPoint","zoomDirection","maxDistance","minZoom","maxZoom","zoomSpeed","scale","zoomIntoPoint","scaleFactor","finalZoomDirection","remainingDistance","zoomDirectionSet","angle","minAltitude","maxAltitude","rotationSpeed","azimuth","altitude","newUp","zoomPointSet","scaleZoomOrientationAtEdges","amt","useFallbackPlane","fallbackPlane","plane","alpha","multiplier","fixedPoint","targetAngle","_globalUp","_zoomPointUp","_toCenter","_ellipsoid","Ellipsoid","_latLon","MIN_ELEVATION","GlobeControls","ellipsoidGroup","ellipsoidFrame","_ellipsoidFrameInverse","ellipsoidFrameInverse","nearMargin","farMargin","maxRadius","distanceToCenter","margin","minNear","elevation","horizonDistance","globeInertia","pivotDir","newPivotDir","pivotRadius","deltaAlpha","upAlpha","forwardAlpha","cameraAlpha","adjustedDeltaAlpha","transitionDistance","distanceAlpha","clampedScale","transitionZoom","maxScaleFactor","clampedScaleFactor","ellipsoidRadius","fovHoriz","distVert","distHoriz","orthoHeight","orthoWidth","orthoSize","ellipsoidDiameter","_orthographicCamera","OrthographicCamera","_targetOffset","_perspOffset","_orthoOffset","_quat","_targetQuat","CameraTransitionManager","prevCamera","perspectiveCamera","PerspectiveCamera","orthographicCamera","transitionCamera","step","newCamera","fromCamera","orthoDist","perspDist","distToPoint","projectionHeight","targetDist","dir","targetQuat","targetFov","targetDistance","orthoOffset","perspOffset","targetOffset","distToPersp","distToOrtho","targetNearPlane","targetFarPlane","planeDelta"],"mappings":"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"}