{"version":3,"file":"B3DMLoaderBase-DNBgoDXu.js","sources":["../src/core/renderer/utilities/urlExtension.js","../src/core/renderer/tiles/optimizedTraverseFunctions.js","../src/core/renderer/tiles/traverseFunctions.js","../src/core/renderer/utilities/throttle.js","../src/core/renderer/tiles/TilesRendererBase.js","../src/core/renderer/utilities/FeatureTable.js","../src/core/renderer/utilities/BatchTableHierarchyExtension.js","../src/core/renderer/utilities/BatchTable.js","../src/core/renderer/loaders/B3DMLoaderBase.js"],"sourcesContent":["/**\n * Returns the file extension of the path component of a URL\n * @param {string} url\n * @returns {string} null if no extension found\n */\nexport function getUrlExtension( url ) {\n\n\tif ( ! url ) {\n\n\t\treturn null;\n\n\t}\n\n\t// Find the last occurrence of '?' and '#' to handle query params and fragments\n\tlet endIndex = url.length;\n\tconst queryIndex = url.indexOf( '?' );\n\tconst fragmentIndex = url.indexOf( '#' );\n\tif ( queryIndex !== - 1 ) {\n\n\t\tendIndex = Math.min( endIndex, queryIndex );\n\n\t}\n\n\tif ( fragmentIndex !== - 1 ) {\n\n\t\tendIndex = Math.min( endIndex, fragmentIndex );\n\n\t}\n\n\t// Check if the string is just a hostname or whether the path does not end in an extension\n\tconst lastPeriodIndex = url.lastIndexOf( '.', endIndex );\n\tconst lastSlashIndex = url.lastIndexOf( '/', endIndex );\n\tconst protocolIndex = url.indexOf( '://' );\n\tconst isHostOnly = protocolIndex !== - 1 && protocolIndex + 2 === lastSlashIndex;\n\tif ( isHostOnly || lastPeriodIndex === - 1 || lastPeriodIndex < lastSlashIndex ) {\n\n\t\treturn null;\n\n\t}\n\n\treturn url.substring( lastPeriodIndex + 1, endIndex ) || null;\n\n}\n","import { LOADED, FAILED } from '../constants.js';\n\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n\tdistanceFromCamera: Infinity,\n};\n\nfunction isDownloadFinished( value ) {\n\n\treturn value === LOADED || value === FAILED;\n\n}\n\n// Checks whether this tile was last used on the given frame.\nfunction isUsedThisFrame( tile, frameCount ) {\n\n\treturn isProcessed( tile ) && tile.traversal.lastFrameVisited === frameCount && tile.traversal.used;\n\n}\n\nfunction isProcessed( tile ) {\n\n\treturn Boolean( tile.traversal );\n\n}\n\n// Checks whether all children have been processed and are ready to traverse\nfunction areChildrenProcessed( tile ) {\n\n\t// all children are processed at once\n\tconst childrenReady = tile.children.length === 0 || Boolean( tile.children[ 0 ].internal );\n\tconst contentReady = ! tile.internal.hasUnrenderableContent || isDownloadFinished( tile.internal.loadingState );\n\treturn childrenReady && contentReady;\n\n}\n\n// Checks whether we can stop at this tile for rendering or not\nfunction canUnconditionallyRefine( tile ) {\n\n\treturn tile.internal.hasUnrenderableContent || ( tile.parent && tile.parent.geometricError < tile.geometricError );\n\n}\n\n// Resets the frame information for the given tile\nfunction resetFrameState( tile, renderer ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tif ( tile.traversal.lastFrameVisited !== renderer.frameCount ) {\n\n\t\ttile.traversal.lastFrameVisited = renderer.frameCount;\n\t\ttile.traversal.used = false;\n\t\ttile.traversal.inFrustum = false;\n\t\ttile.traversal.isLeaf = false;\n\t\ttile.traversal.visible = false;\n\t\ttile.traversal.active = false;\n\t\ttile.traversal.error = Infinity;\n\t\ttile.traversal.distanceFromCamera = Infinity;\n\t\ttile.traversal.allChildrenReady = false;\n\t\ttile.traversal.kicked = false;\n\t\ttile.traversal.allUsedChildrenProcessed = false;\n\n\t\t// update tile frustum and error state\n\t\trenderer.calculateTileViewErrorWithPlugin( tile, viewErrorTarget );\n\t\ttile.traversal.inFrustum = viewErrorTarget.inView;\n\t\ttile.traversal.error = viewErrorTarget.error;\n\t\ttile.traversal.distanceFromCamera = viewErrorTarget.distanceFromCamera;\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next layer, skipping external tilesets\nfunction recursivelyMarkUsed( tile, renderer, cacheOnly = false ) {\n\n\tresetFrameState( tile, renderer );\n\tif ( cacheOnly ) {\n\n\t\trenderer.markTileUsed( tile );\n\n\t} else {\n\n\t\tmarkUsed( tile );\n\n\t}\n\n\t// don't traverse if the children have not been processed, yet but tileset content\n\t// should be considered to be \"replaced\" by the loaded children so await that here.\n\tif ( canUnconditionallyRefine( tile ) && areChildrenProcessed( tile ) ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, cacheOnly );\n\n\t\t}\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next layer, skipping external tilesets\nfunction recursivelyMarkPreviouslyUsed( tile, renderer ) {\n\n\tresetFrameState( tile, renderer );\n\n\tif ( tile.traversal.usedLastFrame ) {\n\n\t\tmarkUsed( tile, renderer );\n\n\t\tif ( tile.traversal.wasSetActive ) {\n\n\t\t\ttile.traversal.active = true;\n\n\t\t}\n\n\t\tif ( ! tile.traversal.active || canUnconditionallyRefine( tile ) ) {\n\n\t\t\t// don't traverse if the children have not been processed, yet but tileset content\n\t\t\t// should be considered to be \"replaced\" by the loaded children so await that here.\n\t\t\tif ( areChildrenProcessed( tile ) ) {\n\n\t\t\t\tconst children = tile.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\trecursivelyMarkPreviouslyUsed( children[ i ], renderer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Mark a tile as being used by current view\nfunction markUsed( tile ) {\n\n\ttile.traversal.used = true;\n\n}\n\n// Returns whether the tile can be traversed to the next layer of children by checking the tile metrics\nfunction canTraverse( tile, renderer ) {\n\n\t// If we've met the error requirements then don't load further - if an external tileset is encountered,\n\t// though, then continue to refine.\n\tif ( tile.traversal.error <= renderer.errorTarget && ! canUnconditionallyRefine( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if we've reached the maximum allowed depth.\n\tif ( renderer.maxDepth > 0 && tile.internal.depth + 1 >= renderer.maxDepth ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if the children haven't been processed, yet\n\tif ( ! areChildrenProcessed( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n\n// Marks \"active\" children as \"kicked\" so they are still loaded but not rendered yet\nfunction kickActiveChildren( tile, renderer ) {\n\n\tconst { frameCount } = renderer;\n\tconst { children } = tile;\n\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tif ( isUsedThisFrame( c, frameCount ) ) {\n\n\t\t\tif ( c.traversal.active ) {\n\n\t\t\t\tc.traversal.kicked = true;\n\t\t\t\tc.traversal.active = false;\n\n\t\t\t}\n\n\t\t\tkickActiveChildren( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Checks whether this tile is ready to be stopped at for rendering\nfunction isChildReady( tile ) {\n\n\treturn ! canUnconditionallyRefine( tile ) && ( ! tile.internal.hasContent || isDownloadFinished( tile.internal.loadingState ) );\n\n}\n\n// Determine which tiles are used by the renderer given the current camera configuration\nfunction markUsedTiles( tile, renderer ) {\n\n\t// determine frustum set is run first so we can ensure the preprocessing of all the necessary\n\t// child tiles has happened here.\n\tresetFrameState( tile, renderer );\n\n\tif ( ! tile.traversal.inFrustum ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! canTraverse( tile, renderer ) ) {\n\n\t\tmarkUsed( tile );\n\t\treturn;\n\n\t}\n\n\t// Traverse children and see if any children are in view.\n\tlet anyChildrenUsed = false;\n\tlet anyChildrenInFrustum = false;\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tmarkUsedTiles( c, renderer );\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, renderer.frameCount );\n\t\tanyChildrenInFrustum = anyChildrenInFrustum || c.traversal.inFrustum;\n\n\t}\n\n\t// If none of the children are visible in the frustum then there should be no reason to display this tile. We still mark\n\t// this tile and all children as \"used\" only in the cache (but not loaded) so they are not disposed, causing an oscillation\n\t// / flicker in the content.\n\tif ( tile.refine === 'REPLACE' && ! anyChildrenInFrustum && children.length !== 0 ) {\n\n\t\ttile.traversal.inFrustum = false;\n\n\t\trenderer.markTileUsed( tile );\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, true );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t// wait until after the above condition to mark the traversed tile as used or not\n\t// and then mark any of the sibling child tiles as used\n\tmarkUsed( tile );\n\n\tif ( tile.refine === 'REPLACE' && anyChildrenUsed && renderer.loadSiblings ) {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverse and mark the tiles that are at the leaf nodes of the \"used\" tree.\nfunction markUsedSetLeaves( tile, renderer ) {\n\n\tconst frameCount = renderer.frameCount;\n\tif ( ! isUsedThisFrame( tile, frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// This tile is a leaf if none of the children had been used.\n\tconst children = tile.children;\n\tlet anyChildrenUsed = false;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, frameCount );\n\n\t}\n\n\t// Traversal\n\tif ( ! anyChildrenUsed ) {\n\n\t\ttile.traversal.isLeaf = true;\n\n\t} else {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tmarkUsedSetLeaves( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n\t// save whether any children are processed\n\tlet allUsedChildrenProcessed = true;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tif ( isUsedThisFrame( c, renderer.frameCount ) && ! c.traversal.allUsedChildrenProcessed ) {\n\n\t\t\tallUsedChildrenProcessed = false;\n\n\t\t}\n\n\t}\n\n\ttile.traversal.allUsedChildrenProcessed = allUsedChildrenProcessed && areChildrenProcessed( tile );\n\n}\n\n// TODO: revisit implementation\n// Skip past tiles we consider unrenderable because they are outside the error threshold.\nfunction markVisibleTiles( tile, renderer ) {\n\n\tif ( ! isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\tconst hasContent = tile.internal.hasContent;\n\tconst loadedContent = isDownloadFinished( tile.internal.loadingState ) && hasContent;\n\tconst children = tile.children;\n\tif ( tile.traversal.isLeaf ) {\n\n\t\t// if we're allowed to stop at this tile then mark it as active and allow any previously active tiles to\n\t\t// continue to be displayed\n\t\tif ( ! canUnconditionallyRefine( tile ) ) {\n\n\t\t\ttile.traversal.active = true;\n\n\t\t\tif ( areChildrenProcessed( tile ) && ( ! tile.internal.hasContent || ! isDownloadFinished( tile.internal.loadingState ) ) ) {\n\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\trecursivelyMarkPreviouslyUsed( children[ i ], renderer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t// Don't wait for all children tiles to load if this tileset has empty tiles at the root in order\n\t// to match Cesium's behavior\n\tlet allChildrenReady = children.length > 0;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tmarkVisibleTiles( c, renderer );\n\n\t\tif ( isUsedThisFrame( c, renderer.frameCount ) ) {\n\n\t\t\tconst childIsReady = c.traversal.active && isChildReady( c );\n\t\t\tif ( ! childIsReady && ! c.traversal.allChildrenReady ) {\n\n\t\t\t\tallChildrenReady = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttile.traversal.allChildrenReady = allChildrenReady;\n\n\t// If we find that the subsequent children are not ready such that this tile gap can be filled then\n\t// mark all lower tiles as non active and prepare this one to be displayed if possible\n\tconst thisTileIsVisible = tile.traversal.active && isChildReady( tile );\n\tif ( ! canUnconditionallyRefine( tile ) && ! allChildrenReady && ! thisTileIsVisible ) {\n\n\t\tif ( tile.traversal.wasSetActive && ( loadedContent || ! tile.internal.hasContent ) ) {\n\n\t\t\ttile.traversal.active = true;\n\t\t\tkickActiveChildren( tile, renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Final traverse to toggle tile visibility.\nfunction toggleTiles( tile, renderer ) {\n\n\tconst isUsed = isUsedThisFrame( tile, renderer.frameCount );\n\tif ( isUsed ) {\n\n\t\t// any internal tileset and additive tile must be marked as active and loaded\n\t\tif ( tile.internal.hasUnrenderableContent || tile.internal.hasRenderableContent && tile.refine === 'ADD' ) {\n\n\t\t\ttile.traversal.active = true;\n\n\t\t}\n\n\t\t// queue any tiles to load that we need to, and unmark any unloaded or non visible tiles as \"active\"\n\t\t// TODO: it may be more simple to track a separate variable than \"active\" here\n\t\tif ( ( tile.traversal.active || tile.traversal.kicked ) && tile.internal.hasContent ) {\n\n\t\t\trenderer.markTileUsed( tile );\n\n\t\t\tif ( tile.internal.hasUnrenderableContent || tile.traversal.allUsedChildrenProcessed ) {\n\n\t\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t\t}\n\n\t\t\tif ( tile.internal.loadingState !== LOADED ) {\n\n\t\t\t\ttile.traversal.active = false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttile.traversal.active = false;\n\n\t\t}\n\n\t\t// if the tile is loaded and in frustum we can mark it as visible\n\t\ttile.traversal.visible = tile.internal.hasRenderableContent && tile.traversal.active && tile.traversal.inFrustum && tile.internal.loadingState === LOADED;\n\t\trenderer.stats.used ++;\n\n\t\tif ( tile.traversal.inFrustum ) {\n\n\t\t\trenderer.stats.inFrustum ++;\n\n\t\t}\n\n\t}\n\n\tif ( isUsed || isProcessed( tile ) && tile.traversal?.usedLastFrame ) {\n\n\t\tlet setActive = false;\n\t\tlet setVisible = false;\n\t\tif ( isUsed ) {\n\n\t\t\t// enable visibility if active due to shadows\n\t\t\tsetActive = tile.traversal.active;\n\t\t\tif ( renderer.displayActiveTiles ) {\n\n\t\t\t\tsetVisible = tile.traversal.active || tile.traversal.visible;\n\n\t\t\t} else {\n\n\t\t\t\tsetVisible = tile.traversal.visible;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if the tile was used last frame but not this one then there's potential for the tile\n\t\t\t// to not have been visited during the traversal, meaning it hasn't been reset and has\n\t\t\t// stale values. This ensures the values are not stale.\n\t\t\tresetFrameState( tile, renderer );\n\n\t\t}\n\n\t\t// If the active or visible state changed then call the functions.\n\t\tif ( tile.internal.hasRenderableContent && tile.internal.loadingState === LOADED ) {\n\n\t\t\tif ( tile.traversal.wasSetActive !== setActive ) {\n\n\t\t\t\trenderer.stats.active += setActive ? 1 : - 1;\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, setActive ) );\n\n\t\t\t}\n\n\t\t\tif ( tile.traversal.wasSetVisible !== setVisible ) {\n\n\t\t\t\trenderer.stats.visible += setVisible ? 1 : - 1;\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, setVisible ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.traversal.wasSetActive = setActive;\n\t\ttile.traversal.wasSetVisible = setVisible;\n\t\ttile.traversal.usedLastFrame = isUsed;\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\ttoggleTiles( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n\nexport function runTraversal( tile, renderer ) {\n\n\tmarkUsedTiles( tile, renderer );\n\tmarkUsedSetLeaves( tile, renderer );\n\tmarkVisibleTiles( tile, renderer );\n\ttoggleTiles( tile, renderer );\n\n}\n","import { LOADED, FAILED } from '../constants.js';\n\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n\tdistanceFromCamera: Infinity,\n};\n\n// flag guiding the behavior of the traversal to load the siblings at the root of the\n// tileset or not. The spec seems to indicate \"true\" when using REPLACE define but\n// Cesium's behavior is \"false\".\n// See CesiumGS/3d-tiles#776\nconst LOAD_ROOT_SIBLINGS = true;\n\nfunction isDownloadFinished( value ) {\n\n\treturn value === LOADED || value === FAILED;\n\n}\n\n// Checks whether this tile was last used on the given frame.\nfunction isUsedThisFrame( tile, frameCount ) {\n\n\treturn isProcessed( tile ) && tile.traversal.lastFrameVisited === frameCount && tile.traversal.used;\n\n}\n\nfunction isProcessed( tile ) {\n\n\treturn Boolean( tile.traversal );\n\n}\n\nfunction areChildrenProcessed( tile ) {\n\n\t// all children are processed at once\n\treturn tile.children.length === 0 || Boolean( tile.children[ 0 ].internal );\n\n}\n\nfunction canUnconditionallyRefine( tile ) {\n\n\treturn tile.internal.hasUnrenderableContent || ( tile.parent && tile.parent.geometricError < tile.geometricError );\n\n}\n\n// Resets the frame information for the given tile\nfunction resetFrameState( tile, renderer ) {\n\n\tif ( tile.traversal.lastFrameVisited !== renderer.frameCount ) {\n\n\t\ttile.traversal.lastFrameVisited = renderer.frameCount;\n\t\ttile.traversal.used = false;\n\t\ttile.traversal.inFrustum = false;\n\t\ttile.traversal.isLeaf = false;\n\t\ttile.traversal.visible = false;\n\t\ttile.traversal.active = false;\n\t\ttile.traversal.error = Infinity;\n\t\ttile.traversal.distanceFromCamera = Infinity;\n\t\ttile.traversal.allChildrenReady = false;\n\n\t\t// update tile frustum and error state\n\t\trenderer.calculateTileViewErrorWithPlugin( tile, viewErrorTarget );\n\t\ttile.traversal.inFrustum = viewErrorTarget.inView;\n\t\ttile.traversal.error = viewErrorTarget.error;\n\t\ttile.traversal.distanceFromCamera = viewErrorTarget.distanceFromCamera;\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next layer, skipping external tilesets\nfunction recursivelyMarkUsed( tile, renderer, cacheOnly = false ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\tmarkUsed( tile, renderer, cacheOnly );\n\n\t// don't traverse if the children have not been processed, yet but tileset content\n\t// should be considered to be \"replaced\" by the loaded children so await that here.\n\tif ( canUnconditionallyRefine( tile ) && areChildrenProcessed( tile ) ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, cacheOnly );\n\n\t\t}\n\n\t}\n\n}\n\n// Recursively traverses to the next tiles with unloaded renderable content to load them\nfunction recursivelyLoadNextRenderableTiles( tile, renderer ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\t// exit the recursion if the tile hasn't been used this frame\n\tif ( isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\t// queue this tile to download content\n\t\tif ( tile.internal.hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\tif ( areChildrenProcessed( tile ) ) {\n\n\t\t\t// queue any used child tiles\n\t\t\tconst children = tile.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( children[ i ], renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Mark a tile as being used by current view\nfunction markUsed( tile, renderer, cacheOnly = false ) {\n\n\tif ( tile.traversal.used ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! cacheOnly ) {\n\n\t\ttile.traversal.used = true;\n\t\trenderer.stats.used ++;\n\n\t}\n\n\trenderer.markTileUsed( tile );\n\n\tif ( tile.traversal.inFrustum === true ) {\n\n\t\trenderer.stats.inFrustum ++;\n\n\t}\n\n}\n\n// Returns whether the tile can be traversed to the next layer of children by checking the tile metrics\nfunction canTraverse( tile, renderer ) {\n\n\t// If we've met the error requirements then don't load further - if an external tileset is encountered,\n\t// though, then continue to refine.\n\tif ( tile.traversal.error <= renderer.errorTarget && ! canUnconditionallyRefine( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if we've reached the maximum allowed depth.\n\tif ( renderer.maxDepth > 0 && tile.internal.depth + 1 >= renderer.maxDepth ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if the children haven't been processed, yet\n\tif ( ! areChildrenProcessed( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n\n// Determine which tiles are used by the renderer given the current camera configuration\nfunction markUsedTiles( tile, renderer ) {\n\n\t// determine frustum set is run first so we can ensure the preprocessing of all the necessary\n\t// child tiles has happened here.\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\n\tif ( ! tile.traversal.inFrustum ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! canTraverse( tile, renderer ) ) {\n\n\t\tmarkUsed( tile, renderer );\n\t\treturn;\n\n\t}\n\n\t// Traverse children and see if any children are in view.\n\tlet anyChildrenUsed = false;\n\tlet anyChildrenInFrustum = false;\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tmarkUsedTiles( c, renderer );\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, renderer.frameCount );\n\t\tanyChildrenInFrustum = anyChildrenInFrustum || c.traversal.inFrustum;\n\n\t}\n\n\t// If none of the children are visible in the frustum then there should be no reason to display this tile. We still mark\n\t// this tile and all children as \"used\" only in the cache (but not loaded) so they are not disposed, causing an oscillation\n\t// / flicker in the content.\n\tif ( tile.refine === 'REPLACE' && ! anyChildrenInFrustum && children.length !== 0 ) {\n\n\t\ttile.traversal.inFrustum = false;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer, true );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t// wait until after the above condition to mark the traversed tile as used or not\n\tmarkUsed( tile, renderer );\n\n\t// If this is a tile that needs children loaded to refine then recursively load child\n\t// tiles until error is met\n\tif ( tile.refine === 'REPLACE' && ( anyChildrenUsed && tile.internal.depth !== 0 || LOAD_ROOT_SIBLINGS ) ) {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverse and mark the tiles that are at the leaf nodes of the \"used\" tree.\nfunction markUsedSetLeaves( tile, renderer ) {\n\n\tconst frameCount = renderer.frameCount;\n\tif ( ! isUsedThisFrame( tile, frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// This tile is a leaf if none of the children had been used.\n\tconst children = tile.children;\n\tlet anyChildrenUsed = false;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, frameCount );\n\n\t}\n\n\tif ( ! anyChildrenUsed ) {\n\n\t\ttile.traversal.isLeaf = true;\n\n\t} else {\n\n\t\tlet allChildrenReady = true;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tmarkUsedSetLeaves( c, renderer );\n\n\t\t\tif ( isUsedThisFrame( c, frameCount ) ) {\n\n\t\t\t\t// Compute whether this child is _allowed_ to display by checking the geometric error relative to the parent tile to avoid holes.\n\t\t\t\t// If the child's geometric error is less than or equal to the parent's (or it has unrenderable content), we should NOT display the child to avoid holes.\n\t\t\t\t// Only display the child if its geometric error is greater than the parent's and it has renderable content.\n\t\t\t\t// Note that this behavior is undocumented in the 3d tiles specification and tilesets designed to take advantage of it may not work as expected\n\t\t\t\t// in other rendering systems.\n\t\t\t\t// See issue NASA-AMMOS/3DTilesRendererJS#1304\n\t\t\t\tconst childCanDisplay = ! canUnconditionallyRefine( c );\n\n\t\t\t\t// Consider a child to be ready to be displayed if\n\t\t\t\t// - the children's children have been loaded\n\t\t\t\t// - the tile content has loaded\n\t\t\t\t// - the tile is completely empty - ie has no children and no content\n\t\t\t\t// - the child tileset has tried to load but failed\n\t\t\t\tlet isChildReady =\n\t\t\t\t\t! c.internal.hasContent ||\n\t\t\t\t\t( c.internal.hasRenderableContent && isDownloadFinished( c.internal.loadingState ) ) ||\n\t\t\t\t\t( c.internal.hasUnrenderableContent && c.internal.loadingState === FAILED );\n\n\t\t\t\t// Consider this child ready if it can be displayed and is ready for display or all of it's children ready to be displayed\n\t\t\t\tisChildReady = ( childCanDisplay && isChildReady ) || c.traversal.allChildrenReady;\n\n\t\t\t\tallChildrenReady = allChildrenReady && isChildReady;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.traversal.allChildrenReady = allChildrenReady;\n\n\t}\n\n}\n\n// TODO: revisit implementation\n// Skip past tiles we consider unrenderable because they are outside the error threshold.\nfunction markVisibleTiles( tile, renderer ) {\n\n\tconst stats = renderer.stats;\n\tif ( ! isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// Request the tile contents or mark it as visible if we've found a leaf.\n\tif ( tile.traversal.isLeaf ) {\n\n\t\tif ( tile.internal.loadingState === LOADED ) {\n\n\t\t\tif ( tile.traversal.inFrustum ) {\n\n\t\t\t\ttile.traversal.visible = true;\n\t\t\t\tstats.visible ++;\n\n\t\t\t}\n\n\t\t\ttile.traversal.active = true;\n\t\t\tstats.active ++;\n\n\t\t} else if ( tile.internal.hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\tconst children = tile.children;\n\tconst hasContent = tile.internal.hasContent;\n\tconst loadedContent = isDownloadFinished( tile.internal.loadingState ) && hasContent;\n\tconst errorRequirement = ( renderer.errorTarget + 1 ) * renderer.errorThreshold;\n\tconst meetsSSE = tile.traversal.error <= errorRequirement;\n\tconst isAdditiveRefine = tile.refine === 'ADD';\n\n\t// TODO: the \"meetsSSE\" field can be removed when the \"errorThreshold\" field has been removed\n\n\t// Don't wait for all children tiles to load if this tileset has empty tiles at the root in order\n\t// to match Cesium's behavior\n\tconst allChildrenReady = tile.traversal.allChildrenReady || ( tile.internal.depth === 0 && ! LOAD_ROOT_SIBLINGS );\n\n\t// If we've met the SSE requirements and we can load content then fire a fetch.\n\tif ( hasContent && ( meetsSSE || isAdditiveRefine ) ) {\n\n\t\trenderer.queueTileForDownload( tile );\n\n\t}\n\n\t// By this time only tiles that meet the screen space error requirements will be traversed. Only mark this\n\t// as visible if it's been loaded and not all children have loaded yet or it's an additive tile, meaning it needs\n\t// to display in addition to the children.\n\n\t// Skip the tile entirely if there's no content to load\n\tif ( meetsSSE && loadedContent && ! allChildrenReady || loadedContent && isAdditiveRefine ) {\n\n\t\tif ( tile.traversal.inFrustum ) {\n\n\t\t\ttile.traversal.visible = true;\n\t\t\tstats.visible ++;\n\n\t\t}\n\n\t\ttile.traversal.active = true;\n\t\tstats.active ++;\n\n\t}\n\n\t// If we're additive then don't stop the traversal here because it doesn't matter whether the children load in\n\t// at the same rate.\n\tif ( ! isAdditiveRefine && meetsSSE && ! allChildrenReady ) {\n\n\t\t// load the child content if we've found that we've been loaded so we can move down to the next tile\n\t\t// layer when the data has loaded.\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tif ( isUsedThisFrame( c, renderer.frameCount ) ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( c, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tmarkVisibleTiles( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Final traverse to toggle tile visibility.\nfunction toggleTiles( tile, renderer ) {\n\n\tconst isUsed = isUsedThisFrame( tile, renderer.frameCount );\n\tif ( isUsed || isProcessed( tile ) && tile.traversal.usedLastFrame ) {\n\n\t\tlet setActive = false;\n\t\tlet setVisible = false;\n\t\tif ( isUsed ) {\n\n\t\t\t// enable visibility if active due to shadows\n\t\t\tsetActive = tile.traversal.active;\n\t\t\tif ( renderer.displayActiveTiles ) {\n\n\t\t\t\tsetVisible = tile.traversal.active || tile.traversal.visible;\n\n\t\t\t} else {\n\n\t\t\t\tsetVisible = tile.traversal.visible;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if the tile was used last frame but not this one then there's potential for the tile\n\t\t\t// to not have been visited during the traversal, meaning it hasn't been reset and has\n\t\t\t// stale values. This ensures the values are not stale.\n\t\t\tresetFrameState( tile, renderer );\n\n\t\t}\n\n\t\t// If the active or visible state changed then call the functions.\n\t\tif ( tile.internal.hasRenderableContent && tile.internal.loadingState === LOADED ) {\n\n\t\t\tif ( tile.traversal.wasSetActive !== setActive ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, setActive ) );\n\n\t\t\t}\n\n\t\t\tif ( tile.traversal.wasSetVisible !== setVisible ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, setVisible ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.traversal.wasSetActive = setActive;\n\t\ttile.traversal.wasSetVisible = setVisible;\n\t\ttile.traversal.usedLastFrame = isUsed;\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\ttoggleTiles( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n\nexport function runTraversal( tile, renderer ) {\n\n\tmarkUsedTiles( tile, renderer );\n\tmarkUsedSetLeaves( tile, renderer );\n\tmarkVisibleTiles( tile, renderer );\n\ttoggleTiles( tile, renderer );\n\n}\n\n","// function that rate limits the amount of time a function can be called to once\n// per frame, initially queuing a new call for the next frame.\nexport function throttle( callback ) {\n\n\tlet handle = null;\n\treturn () => {\n\n\t\tif ( handle === null ) {\n\n\t\t\thandle = requestAnimationFrame( () => {\n\n\t\t\t\thandle = null;\n\t\t\t\tcallback();\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n}\n","import { getUrlExtension } from '../utilities/urlExtension.js';\nimport { LRUCache } from '../utilities/LRUCache.js';\nimport { PriorityQueue } from '../utilities/PriorityQueue.js';\nimport { runTraversal as optimizedRunTraversal } from './optimizedTraverseFunctions.js';\nimport { runTraversal } from './traverseFunctions.js';\nimport { UNLOADED, QUEUED, LOADING, PARSING, LOADED, FAILED } from '../constants.js';\nimport { throttle } from '../utilities/throttle.js';\nimport { traverseSet } from '../utilities/TraversalUtils.js';\n\nconst PLUGIN_REGISTERED = Symbol( 'PLUGIN_REGISTERED' );\nconst regionErrorTarget = {\n\tinView: true,\n\terror: 0,\n\tdistance: Infinity,\n};\n\n// priority queue sort function that takes two tiles to compare. Returning 1 means\n// \"tile a\" is loaded first.\nconst defaultPriorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( ! a.traversal || ! b.traversal ) {\n\n\t\treturn 0;\n\n\t} else if ( a.traversal.used !== b.traversal.used ) {\n\n\t\t// load tiles that have been used\n\t\treturn a.traversal.used ? 1 : - 1;\n\n\t} else if ( a.traversal.error !== b.traversal.error ) {\n\n\t\t// load the tile with the higher error\n\t\treturn a.traversal.error > b.traversal.error ? 1 : - 1;\n\n\t} else if ( a.traversal.distanceFromCamera !== b.traversal.distanceFromCamera ) {\n\n\t\t// and finally visible tiles which have equal error (ex: if geometricError === 0)\n\t\t// should prioritize based on distance.\n\t\treturn a.traversal.distanceFromCamera > b.traversal.distanceFromCamera ? - 1 : 1;\n\n\t} else if ( a.internal.depthFromRenderedParent !== b.internal.depthFromRenderedParent ) {\n\n\t\treturn a.internal.depthFromRenderedParent > b.internal.depthFromRenderedParent ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\n// Optimized priority callback - prioritizes distance over error for better user experience\nconst optimizedPriorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( ! a.traversal || ! b.traversal ) {\n\n\t\treturn 0;\n\n\t} else if ( a.traversal.used !== b.traversal.used ) {\n\n\t\t// load tiles that have been used\n\t\treturn a.traversal.used ? 1 : - 1;\n\n\t} else if ( a.traversal.inFrustum !== b.traversal.inFrustum ) {\n\n\t\t// load tiles that have are in the frustum\n\t\treturn a.traversal.inFrustum ? 1 : - 1;\n\n\t} else if ( a.internal.hasUnrenderableContent !== b.internal.hasUnrenderableContent ) {\n\n\t\t// load internal tile sets first\n\t\treturn a.internal.hasUnrenderableContent ? 1 : - 1;\n\n\t} else if ( a.traversal.distanceFromCamera !== b.traversal.distanceFromCamera ) {\n\n\t\t// load closer tiles first\n\t\treturn a.traversal.distanceFromCamera > b.traversal.distanceFromCamera ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\n// lru cache unload callback that takes two tiles to compare. Returning 1 means \"tile a\"\n// is unloaded first.\nconst lruPriorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( ! a.traversal || ! b.traversal ) {\n\n\t\treturn 0;\n\n\t} else if ( a.traversal.lastFrameVisited !== b.traversal.lastFrameVisited ) {\n\n\t\t// dispose of least recent tiles first\n\t\treturn a.traversal.lastFrameVisited > b.traversal.lastFrameVisited ? - 1 : 1;\n\n\t} else if ( a.internal.depthFromRenderedParent !== b.internal.depthFromRenderedParent ) {\n\n\t\t// dispose of deeper tiles first so parents are not disposed before children\n\t\treturn a.internal.depthFromRenderedParent > b.internal.depthFromRenderedParent ? 1 : - 1;\n\n\t} else if ( a.internal.loadingState !== b.internal.loadingState ) {\n\n\t\t// dispose of tiles that are earlier along in the loading process first\n\t\treturn a.internal.loadingState > b.internal.loadingState ? - 1 : 1;\n\n\t} else if ( a.internal.hasUnrenderableContent !== b.internal.hasUnrenderableContent ) {\n\n\t\t// dispose of external tilesets last\n\t\treturn a.internal.hasUnrenderableContent ? - 1 : 1;\n\n\t} else if ( a.traversal.error !== b.traversal.error ) {\n\n\t\t// unload the tile with lower error\n\t\treturn a.traversal.error > b.traversal.error ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\nexport class TilesRendererBase {\n\n\tget root() {\n\n\t\tconst tileset = this.rootTileset;\n\t\treturn tileset ? tileset.root : null;\n\n\t}\n\n\tget rootTileSet() {\n\n\t\tconsole.warn( 'TilesRenderer: \"rootTileSet\" has been deprecated. Use \"rootTileset\" instead.' );\n\t\treturn this.rootTileset;\n\n\t}\n\n\tget loadProgress() {\n\n\t\tconst { stats, isLoading } = this;\n\t\tconst loading = stats.queued + stats.downloading + stats.parsing;\n\t\tconst total = stats.inCacheSinceLoad + ( isLoading ? 1 : 0 );\n\t\treturn total === 0 ? 1.0 : 1.0 - loading / total;\n\n\t}\n\n\tget errorThreshold() {\n\n\t\treturn this._errorThreshold;\n\n\t}\n\n\tset errorThreshold( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"errorThreshold\" option has been deprecated.' );\n\t\tthis._errorThreshold = v;\n\n\t}\n\n\tconstructor( url = null, cachedRootJson = null ) {\n\n\t\t// state\n\t\tthis.rootLoadingState = UNLOADED;\n\t\tthis.rootTileset = null;\n\t\tthis.rootURL = url;\n\t\tthis.cachedRootJson = cachedRootJson;\n\t\tthis.fetchOptions = {};\n\t\tthis.plugins = [];\n\t\tthis.queuedTiles = [];\n\t\tthis.cachedSinceLoadComplete = new Set();\n\t\tthis.isLoading = false;\n\n\t\tconst lruCache = new LRUCache();\n\t\tlruCache.unloadPriorityCallback = lruPriorityCallback;\n\n\t\tconst downloadQueue = new PriorityQueue();\n\t\tdownloadQueue.maxJobs = 25;\n\t\tdownloadQueue.priorityCallback = defaultPriorityCallback;\n\n\t\tconst parseQueue = new PriorityQueue();\n\t\tparseQueue.maxJobs = 5;\n\t\tparseQueue.priorityCallback = defaultPriorityCallback;\n\n\t\tconst processNodeQueue = new PriorityQueue();\n\t\tprocessNodeQueue.maxJobs = 25;\n\t\tprocessNodeQueue.priorityCallback = ( a, b ) => {\n\n\t\t\tconst aParent = a.parent;\n\t\t\tconst bParent = b.parent;\n\t\t\tif ( aParent === bParent ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t} else if ( ! aParent ) {\n\n\t\t\t\treturn 1;\n\n\t\t\t} else if ( ! bParent ) {\n\n\t\t\t\treturn - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// fall back to the priority used for tile loads and parsing\n\t\t\t\treturn downloadQueue.priorityCallback( aParent, bParent );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.processedTiles = new WeakSet();\n\t\tthis.visibleTiles = new Set();\n\t\tthis.activeTiles = new Set();\n\t\tthis.usedSet = new Set();\n\t\tthis.loadingTiles = new Set();\n\t\tthis.lruCache = lruCache;\n\t\tthis.downloadQueue = downloadQueue;\n\t\tthis.parseQueue = parseQueue;\n\t\tthis.processNodeQueue = processNodeQueue;\n\t\tthis.stats = {\n\t\t\tinCacheSinceLoad: 0,\n\t\t\tinCache: 0,\n\n\t\t\tqueued: 0,\n\t\t\tdownloading: 0,\n\t\t\tparsing: 0,\n\t\t\tloaded: 0,\n\t\t\tfailed: 0,\n\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\n\t\t\ttilesProcessed: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t\t// callbacks\n\t\tthis._dispatchNeedsUpdateEvent = throttle( () => {\n\n\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\n\t\t} );\n\n\t\t// options\n\t\tthis.errorTarget = 16.0;\n\t\tthis._errorThreshold = Infinity;\n\t\tthis.displayActiveTiles = false;\n\t\tthis.maxDepth = Infinity;\n\t\tthis.optimizedLoadStrategy = false;\n\t\tthis.loadSiblings = true;\n\t\tthis.maxTilesProcessed = 250;\n\n\t}\n\n\t// Plugins\n\tregisterPlugin( plugin ) {\n\n\t\tif ( plugin[ PLUGIN_REGISTERED ] === true ) {\n\n\t\t\tthrow new Error( 'TilesRendererBase: A plugin can only be registered to a single tileset' );\n\n\t\t}\n\n\t\t// warn if plugin implements deprecated loadRootTileSet method\n\t\tif ( plugin.loadRootTileSet && ! plugin.loadRootTileset ) {\n\n\t\t\tconsole.warn( 'TilesRendererBase: Plugin implements deprecated \"loadRootTileSet\" method. Please rename to \"loadRootTileset\".' );\n\t\t\tplugin.loadRootTileset = plugin.loadRootTileSet;\n\n\t\t}\n\n\t\tif ( plugin.preprocessTileSet && ! plugin.preprocessTileset ) {\n\n\t\t\tconsole.warn( 'TilesRendererBase: Plugin implements deprecated \"preprocessTileSet\" method. Please rename to \"preprocessTileset\".' );\n\t\t\tplugin.preprocessTileset = plugin.preprocessTileSet;\n\n\t\t}\n\n\t\t// insert the plugin based on the priority registered on the plugin\n\t\tconst plugins = this.plugins;\n\t\tconst priority = plugin.priority || 0;\n\t\tlet insertionPoint = plugins.length;\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst otherPriority = plugins[ i ].priority || 0;\n\t\t\tif ( otherPriority > priority ) {\n\n\t\t\t\tinsertionPoint = i;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tplugins.splice( insertionPoint, 0, plugin );\n\t\tplugin[ PLUGIN_REGISTERED ] = true;\n\t\tif ( plugin.init ) {\n\n\t\t\tplugin.init( this );\n\n\t\t}\n\n\t}\n\n\tunregisterPlugin( plugin ) {\n\n\t\tconst plugins = this.plugins;\n\t\tif ( typeof plugin === 'string' ) {\n\n\t\t\tplugin = this.getPluginByName( plugin );\n\n\t\t}\n\n\t\tif ( plugins.includes( plugin ) ) {\n\n\t\t\tconst index = plugins.indexOf( plugin );\n\t\t\tplugins.splice( index, 1 );\n\t\t\tif ( plugin.dispose ) {\n\n\t\t\t\tplugin.dispose();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetPluginByName( name ) {\n\n\t\treturn this.plugins.find( p => p.name === name ) || null;\n\n\t}\n\n\tinvokeOnePlugin( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tinvokeAllPlugins( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tconst pending = [];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\tpending.push( result );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn pending.length === 0 ? null : Promise.all( pending );\n\n\t}\n\n\t// Public API\n\ttraverse( beforecb, aftercb, ensureFullyProcessed = true ) {\n\n\t\tif ( ! this.root ) return;\n\n\t\ttraverseSet( this.root, ( tile, ...args ) => {\n\n\t\t\tif ( ensureFullyProcessed ) {\n\n\t\t\t\tthis.ensureChildrenArePreprocessed( tile, true );\n\n\t\t\t}\n\n\t\t\treturn beforecb ? beforecb( tile, ...args ) : false;\n\n\t\t}, aftercb );\n\n\t}\n\n\tgetAttributions( target = [] ) {\n\n\t\tthis.invokeAllPlugins( plugin => plugin !== this && plugin.getAttributions && plugin.getAttributions( target ) );\n\t\treturn target;\n\n\t}\n\n\tupdate() {\n\n\t\t// load root\n\t\tconst { lruCache, usedSet, stats, root, downloadQueue, parseQueue, processNodeQueue, optimizedLoadStrategy } = this;\n\t\tif ( this.rootLoadingState === UNLOADED ) {\n\n\t\t\tthis.rootLoadingState = LOADING;\n\t\t\tthis.invokeOnePlugin( plugin => plugin.loadRootTileset && plugin.loadRootTileset() )\n\t\t\t\t.then( root => {\n\n\t\t\t\t\tlet processedUrl = this.rootURL;\n\t\t\t\t\tif ( processedUrl !== null ) {\n\n\t\t\t\t\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.rootLoadingState = LOADED;\n\t\t\t\t\tthis.rootTileset = root;\n\t\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tileset',\n\t\t\t\t\t\ttileset: root,\n\t\t\t\t\t\turl: processedUrl,\n\t\t\t\t\t} );\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-root-tileset',\n\t\t\t\t\t\ttileset: root,\n\t\t\t\t\t\turl: processedUrl,\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.catch( error => {\n\n\t\t\t\t\tthis.rootLoadingState = FAILED;\n\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\tthis.rootTileset = null;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile: null,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: this.rootURL,\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tif ( ! root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if the plugins that can block the tile updates require it\n\t\tlet needsUpdate = null;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.doTilesNeedUpdate ) {\n\n\t\t\t\tconst res = plugin.doTilesNeedUpdate();\n\t\t\t\tif ( needsUpdate === null ) {\n\n\t\t\t\t\tneedsUpdate = res;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tneedsUpdate = Boolean( needsUpdate || res );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( needsUpdate === false ) {\n\n\t\t\tthis.dispatchEvent( { type: 'update-before' } );\n\t\t\tthis.dispatchEvent( { type: 'update-after' } );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// follow through with the update\n\t\tthis.dispatchEvent( { type: 'update-before' } );\n\n\t\t//\n\n\t\tstats.inFrustum = 0;\n\t\tstats.used = 0;\n\t\tstats.active = 0;\n\t\tstats.visible = 0;\n\t\tstats.tilesProcessed = 0;\n\t\tthis.frameCount ++;\n\n\t\tusedSet.forEach( tile => lruCache.markUnused( tile ) );\n\t\tusedSet.clear();\n\n\t\t// assign the correct callbacks\n\t\tconst priorityCallback = optimizedLoadStrategy ? optimizedPriorityCallback : defaultPriorityCallback;\n\t\tdownloadQueue.priorityCallback = priorityCallback;\n\t\tparseQueue.priorityCallback = priorityCallback;\n\n\t\t// prepare for traversal\n\t\tthis.prepareForTraversal();\n\n\t\t// run traversal\n\t\tif ( optimizedLoadStrategy ) {\n\n\t\t\toptimizedRunTraversal( root, this );\n\n\t\t} else {\n\n\t\t\trunTraversal( root, this );\n\n\t\t}\n\n\t\t// remove any tiles that are loading but no longer used\n\t\tthis.removeUnusedPendingTiles();\n\n\t\t// TODO: This will only sort for one tileset. We may want to store this queue on the\n\t\t// LRUCache so multiple tilesets can use it at once\n\t\t// start the downloads of the tiles as needed\n\t\tconst queuedTiles = this.queuedTiles;\n\t\tqueuedTiles.sort( lruCache.unloadPriorityCallback );\n\t\tfor ( let i = 0, l = queuedTiles.length; i < l && ! lruCache.isFull(); i ++ ) {\n\n\t\t\tthis.requestTileContents( queuedTiles[ i ] );\n\n\t\t}\n\n\t\tqueuedTiles.length = 0;\n\n\t\t// start the downloads\n\t\tlruCache.scheduleUnload();\n\n\t\t// if all tasks have finished and we've been marked as actively loading then fire the completion event\n\t\tconst runningTasks = downloadQueue.running || parseQueue.running || processNodeQueue.running;\n\t\tif ( runningTasks === false && this.isLoading === true ) {\n\n\t\t\tthis.cachedSinceLoadComplete.clear();\n\t\t\tstats.inCacheSinceLoad = 0;\n\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-end' } );\n\t\t\tthis.isLoading = false;\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'update-after' } );\n\n\t}\n\n\tresetFailedTiles() {\n\n\t\t// reset the root tile if it's finished but never loaded\n\t\tif ( this.rootLoadingState === FAILED ) {\n\n\t\t\tthis.rootLoadingState = UNLOADED;\n\n\t\t}\n\n\t\tconst stats = this.stats;\n\t\tif ( stats.failed === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.traverse( tile => {\n\n\t\t\tif ( tile.internal.loadingState === FAILED ) {\n\n\t\t\t\ttile.internal.loadingState = UNLOADED;\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t\tstats.failed = 0;\n\n\t}\n\n\tcalculateTileViewErrorWithPlugin( tile, target ) {\n\n\t\t// calculate camera view error\n\t\tthis.calculateTileViewError( tile, target );\n\n\t\t// TODO: this logic is extremely complex. It may be more simple to have the plugin\n\t\t// return a \"should mask\" field that indicates its \"false\" values should be respected\n\t\t// rather than the function returning a \"no-op\" boolean.\n\t\t// check the plugin visibility - each plugin will mask between themselves\n\t\tlet inRegion = null;\n\t\tlet inRegionError = 0;\n\t\tlet inRegionDistance = Infinity;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin !== this && plugin.calculateTileViewError ) {\n\n\t\t\t\t// if function returns false it means \"no operation\"\n\t\t\t\tregionErrorTarget.inView = true;\n\t\t\t\tregionErrorTarget.error = 0;\n\t\t\t\tregionErrorTarget.distance = Infinity;\n\t\t\t\tif ( plugin.calculateTileViewError( tile, regionErrorTarget ) ) {\n\n\t\t\t\t\tif ( inRegion === null ) {\n\n\t\t\t\t\t\tinRegion = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Plugins can set \"inView\" to false in order to mask the visible tiles\n\t\t\t\t\tinRegion = inRegion && regionErrorTarget.inView;\n\t\t\t\t\tif ( regionErrorTarget.inView ) {\n\n\t\t\t\t\t\tinRegionDistance = Math.min( inRegionDistance, regionErrorTarget.distance );\n\t\t\t\t\t\tinRegionError = Math.max( inRegionError, regionErrorTarget.error );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( target.inView && inRegion !== false ) {\n\n\t\t\t// if the tile is in camera view and we haven't encountered a region (null) or\n\t\t\t// the region is in view (true). regionInView === false means the tile is masked out.\n\t\t\ttarget.error = Math.max( target.error, inRegionError );\n\t\t\ttarget.distanceFromCamera = Math.min( target.distanceFromCamera, inRegionDistance );\n\n\t\t} else if ( inRegion ) {\n\n\t\t\t// if the tile is in a region then display it\n\t\t\ttarget.inView = true;\n\t\t\ttarget.error = inRegionError;\n\t\t\ttarget.distanceFromCamera = inRegionDistance;\n\n\t\t} else {\n\n\t\t\t// otherwise write variables for load priority\n\t\t\ttarget.inView = false;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\t// dispose of all the plugins\n\t\tconst plugins = [ ...this.plugins ];\n\t\tplugins.forEach( plugin => {\n\n\t\t\tthis.unregisterPlugin( plugin );\n\n\t\t} );\n\n\t\tconst lruCache = this.lruCache;\n\n\t\t// Make sure we've collected all children before disposing of the internal tilesets to avoid\n\t\t// dangling children that we inadvertantly skip when deleting the nested tileset.\n\t\tconst toRemove = [];\n\t\tthis.traverse( t => {\n\n\t\t\ttoRemove.push( t );\n\t\t\treturn false;\n\n\t\t}, null, false );\n\t\tfor ( let i = 0, l = toRemove.length; i < l; i ++ ) {\n\n\t\t\tlruCache.remove( toRemove[ i ] );\n\n\t\t}\n\n\t\tthis.stats = {\n\t\t\tqueued: 0,\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\ttraversed: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\t\tthis.loadingTiles.clear();\n\n\t}\n\n\t// Overrideable\n\tcalculateBytesUsed( scene, tile ) {\n\n\t\treturn 0;\n\n\t}\n\n\tdispatchEvent( e ) {}\n\n\taddEventListener( name, callback ) {}\n\n\tremoveEventListener( name, callback ) {}\n\n\tparseTile( buffer, tile, extension ) {\n\n\t\treturn null;\n\n\t}\n\n\tprepareForTraversal() {}\n\n\tdisposeTile( tile ) {\n\n\t\t// TODO: are these necessary? Are we disposing tiles when they are currently visible?\n\t\tif ( tile.traversal.visible ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, false ) );\n\t\t\ttile.traversal.visible = false;\n\n\t\t}\n\n\t\tif ( tile.traversal.active ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, false ) );\n\t\t\ttile.traversal.active = false;\n\n\t\t}\n\n\t\tconst { scene } = tile.engineData;\n\t\tif ( scene ) {\n\n\t\t\tthis.dispatchEvent( {\n\t\t\t\ttype: 'dispose-model',\n\t\t\t\tscene,\n\t\t\t\ttile,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tilesetDir, parentTile = null ) {\n\n\t\tthis.processedTiles.add( tile );\n\t\tthis.stats.tilesProcessed ++;\n\n\t\tif ( tile.content ) {\n\n\t\t\t// Fix old file formats\n\t\t\tif ( ! ( 'uri' in tile.content ) && 'url' in tile.content ) {\n\n\t\t\t\ttile.content.uri = tile.content.url;\n\t\t\t\tdelete tile.content.url;\n\n\t\t\t}\n\n\t\t\t// NOTE: fix for some cases where tilesets provide the bounding volume\n\t\t\t// but volumes are not present.\n\t\t\tif (\n\t\t\t\ttile.content.boundingVolume &&\n\t\t\t\t! (\n\t\t\t\t\t'box' in tile.content.boundingVolume ||\n\t\t\t\t\t'sphere' in tile.content.boundingVolume ||\n\t\t\t\t\t'region' in tile.content.boundingVolume\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tdelete tile.content.boundingVolume;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.parent = parentTile;\n\t\ttile.children = tile.children || [];\n\n\t\t// Initialize internal data\n\t\ttile.internal = {\n\t\t\thasContent: false,\n\t\t\thasRenderableContent: false,\n\t\t\thasUnrenderableContent: false,\n\t\t\tloadingState: UNLOADED,\n\t\t\tbasePath: tilesetDir,\n\t\t\tdepth: - 1,\n\t\t\tdepthFromRenderedParent: - 1,\n\t\t};\n\n\t\tif ( tile.content?.uri ) {\n\n\t\t\t// \"content\" should only indicate loadable meshes, not external tilesets\n\t\t\tconst extension = getUrlExtension( tile.content.uri );\n\t\t\tconst hasUnrenderableContent = Boolean( extension && /json$/.test( extension ) );\n\t\t\ttile.internal.hasContent = true;\n\t\t\ttile.internal.hasUnrenderableContent = hasUnrenderableContent;\n\t\t\ttile.internal.hasRenderableContent = ! hasUnrenderableContent;\n\n\t\t} else {\n\n\t\t\ttile.internal.hasContent = false;\n\t\t\ttile.internal.hasUnrenderableContent = false;\n\t\t\ttile.internal.hasRenderableContent = false;\n\n\t\t}\n\n\t\t// Increment parent's children processed counter\n\t\tif ( parentTile ) {\n\n\t\t\ttile.internal.depth = parentTile.internal.depth + 1;\n\t\t\ttile.internal.depthFromRenderedParent = parentTile.internal.depthFromRenderedParent + ( tile.internal.hasRenderableContent ? 1 : 0 );\n\n\t\t} else {\n\n\t\t\ttile.internal.depth = 0;\n\t\t\ttile.internal.depthFromRenderedParent = tile.internal.hasRenderableContent ? 1 : 0;\n\n\t\t}\n\n\t\t// Initialize traversal data\n\t\ttile.traversal = {\n\t\t\tdistanceFromCamera: Infinity,\n\t\t\terror: Infinity,\n\t\t\tinFrustum: false,\n\t\t\tisLeaf: false,\n\t\t\tused: false,\n\t\t\tusedLastFrame: false,\n\t\t\tvisible: false,\n\t\t\twasSetVisible: false,\n\t\t\tactive: false,\n\t\t\twasSetActive: false,\n\t\t\tallChildrenReady: false,\n\t\t\tkicked: false,\n\t\t\tallUsedChildrenProcessed: false,\n\t\t\tlastFrameVisited: - 1,\n\t\t};\n\n\t\tif ( parentTile === null ) {\n\n\t\t\ttile.refine = tile.refine || 'REPLACE';\n\n\t\t} else {\n\n\t\t\ttile.refine = tile.refine || parentTile.refine;\n\n\t\t}\n\n\t\t// Initialize engineData data structure with engine-agnostic fields\n\t\ttile.engineData = {\n\t\t\tscene: null,\n\t\t\tmetadata: null,\n\t\t\tboundingVolume: null,\n\t\t};\n\n\t\t// Backwards compatibility: cached is an alias for engineData\n\t\tObject.defineProperty( tile, 'cached', {\n\t\t\tget() {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: \"tile.cached\" field has been renamed to \"tile.engineData\".' );\n\t\t\t\treturn this.engineData;\n\n\t\t\t},\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t} );\n\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tplugin !== this && plugin.preprocessNode && plugin.preprocessNode( tile, tilesetDir, parentTile );\n\n\t\t} );\n\n\t}\n\n\tsetTileActive( tile, active ) {\n\n\t\tactive ? this.activeTiles.add( tile ) : this.activeTiles.delete( tile );\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tvisible ? this.visibleTiles.add( tile ) : this.visibleTiles.delete( tile );\n\n\t\tthis.dispatchEvent( {\n\t\t\ttype: 'tile-visibility-change',\n\t\t\tscene: tile.engineData.scene,\n\t\t\ttile,\n\t\t\tvisible,\n\t\t} );\n\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\t// retrieve whether the tile is visible, screen space error, and distance to camera\n\t\t// set \"inView\", \"error\", \"distance\"\n\n\t}\n\n\tremoveUnusedPendingTiles() {\n\n\t\tconst { lruCache, loadingTiles } = this;\n\n\t\t// cannot delete items while iterating over a set\n\t\tconst toRemove = [];\n\t\tfor ( const tile of loadingTiles ) {\n\n\t\t\t// we only remove tiles that are QUEUED to avoid cancelling tiles that may already be nearly downloaded\n\t\t\t// as the camera moves\n\t\t\tif ( ! lruCache.isUsed( tile ) && tile.internal.loadingState === QUEUED ) {\n\n\t\t\t\ttoRemove.push( tile );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < toRemove.length; i ++ ) {\n\n\t\t\tlruCache.remove( toRemove[ i ] );\n\n\t\t}\n\n\t}\n\n\t// Private Functions\n\tqueueTileForDownload( tile ) {\n\n\t\tif ( tile.internal.loadingState !== UNLOADED || this.lruCache.isFull() ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.queuedTiles.push( tile );\n\n\t}\n\n\tmarkTileUsed( tile ) {\n\n\t\t// save the tile in a separate \"used set\" so we can mark it as unused\n\t\t// before the next tileset traversal\n\t\tthis.usedSet.add( tile );\n\t\tthis.lruCache.markUsed( tile );\n\n\t}\n\n\tfetchData( url, options ) {\n\n\t\treturn fetch( url, options );\n\n\t}\n\n\tensureChildrenArePreprocessed( tile, forceImmediate = this.stats.tilesProcessed < this.maxTilesProcessed ) {\n\n\t\tconst children = tile.children;\n\t\tif ( children.length === 0 || children[ 0 ].internal ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst processChildren = children => {\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tthis.preprocessNode( children[ i ], tile.internal.basePath, tile );\n\n\n\t\t\t}\n\n\t\t};\n\n\t\t// process children immediately up to a max number of tiles during traversal\n\t\tif ( forceImmediate ) {\n\n\t\t\tthis.processNodeQueue.remove( tile );\n\t\t\tprocessChildren( children );\n\n\t\t} else {\n\n\n\t\t\tif ( ! this.processNodeQueue.has( tile ) ) {\n\n\t\t\t\tthis.processNodeQueue.add( tile, tile => {\n\n\t\t\t\t\tprocessChildren( tile.children );\n\t\t\t\t\tthis._dispatchNeedsUpdateEvent();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t// returns the total bytes used for by the given tile as reported by all plugins\n\tgetBytesUsed( tile ) {\n\n\t\tlet bytes = 0;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.calculateBytesUsed ) {\n\n\t\t\t\tbytes += plugin.calculateBytesUsed( tile, tile.engineData.scene ) || 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bytes;\n\n\t}\n\n\t// force a recalculation of the tile or all tiles if no tile is provided\n\trecalculateBytesUsed( tile = null ) {\n\n\t\tconst { lruCache, processedTiles } = this;\n\t\tif ( tile === null ) {\n\n\t\t\tlruCache.itemSet.forEach( item => {\n\n\t\t\t\tif ( processedTiles.has( item ) ) {\n\n\t\t\t\t\tlruCache.setMemoryUsage( item, this.getBytesUsed( item ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\n\t\t}\n\n\t}\n\n\tpreprocessTileset( json, url, parent = null ) {\n\n\t\t// check for deprecated function usage\n\t\tconst proto = Object.getPrototypeOf( this );\n\t\tif ( Object.hasOwn( proto, 'preprocessTileSet' ) ) {\n\n\t\t\tconsole.warn( `${ proto.constructor.name }: Class overrides deprecated \"preprocessTileSet\" method. Please rename to \"preprocessTileset\".` );\n\n\t\t}\n\n\t\tconst version = json.asset.version;\n\t\tconst [ major, minor ] = version.split( '.' ).map( v => parseInt( v ) );\n\t\tconsole.assert(\n\t\t\tmajor <= 1,\n\t\t\t'TilesRenderer: asset.version is expected to be a 1.x or a compatible version.',\n\t\t);\n\n\t\tif ( major === 1 && minor > 0 ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.' );\n\n\t\t}\n\n\t\t// remove the last file path path-segment from the URL including the trailing slash\n\t\tlet basePath = url.replace( /\\/[^/]*$/, '' );\n\t\tbasePath = new URL( basePath, window.location.href ).toString();\n\t\tthis.preprocessNode( json.root, basePath, parent );\n\n\t}\n\n\tpreprocessTileSet( ...args ) {\n\n\t\tconsole.warn( 'TilesRenderer: \"preprocessTileSet\" has been deprecated. Use \"preprocessTileset\" instead.' );\n\t\treturn this.preprocessTileset( ...args );\n\n\t}\n\n\tloadRootTileset() {\n\n\t\t// check for deprecated function usage\n\t\tconst proto = Object.getPrototypeOf( this );\n\t\tif ( Object.hasOwn( proto, 'loadRootTileSet' ) ) {\n\n\t\t\tconsole.warn( `${ proto.constructor.name }: Class overrides deprecated \"loadRootTileSet\" method. Please rename to \"loadRootTileset\".` );\n\n\t\t}\n\n\t\t// transform the url\n\t\tlet processedUrl = this.rootURL;\n\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\tif ( this.cachedRootJson ) {\n\n\t\t\treturn Promise.resolve( this.cachedRootJson )\n\t\t\t\t.then( root => {\n\n\t\t\t\t\tthis.preprocessTileset( root, processedUrl );\n\t\t\t\t\treturn root;\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\t// load the tileset root\n\t\tconst pr = this\n\t\t\t.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( processedUrl, this.fetchOptions ) )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn res.json();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `TilesRenderer: Failed to load tileset \"${ processedUrl }\" with status ${ res.status } : ${ res.statusText }` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( root => {\n\n\t\t\t\tthis.preprocessTileset( root, processedUrl );\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t\treturn pr;\n\n\t}\n\n\tloadRootTileSet( ...args ) {\n\n\t\tconsole.warn( 'TilesRenderer: \"loadRootTileSet\" has been deprecated. Use \"loadRootTileset\" instead.' );\n\t\treturn this.loadRootTileSet( ...args );\n\n\t}\n\n\trequestTileContents( tile ) {\n\n\t\t// If the tile is already being loaded then don't\n\t\t// start it again.\n\t\tif ( tile.internal.loadingState !== UNLOADED ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet isExternalTileset = false;\n\t\tlet externalTileset = null;\n\t\tlet uri = new URL( tile.content.uri, tile.internal.basePath + '/' ).toString();\n\t\tthis.invokeAllPlugins( plugin => uri = plugin.preprocessURL ? plugin.preprocessURL( uri, tile ) : uri );\n\n\t\tconst stats = this.stats;\n\t\tconst lruCache = this.lruCache;\n\t\tconst downloadQueue = this.downloadQueue;\n\t\tconst parseQueue = this.parseQueue;\n\t\tconst loadingTiles = this.loadingTiles;\n\t\tconst extension = getUrlExtension( uri );\n\n\t\t// track an abort controller and pass-through the below conditions if aborted\n\t\tconst controller = new AbortController();\n\t\tconst signal = controller.signal;\n\t\tconst addedSuccessfully = lruCache.add( tile, t => {\n\n\t\t\t// Stop the load if it's started\n\t\t\tcontroller.abort();\n\n\t\t\t// Clear out all tile content\n\t\t\tif ( isExternalTileset ) {\n\n\t\t\t\tt.children.length = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\t\t\tplugin.disposeTile && plugin.disposeTile( t );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// Decrement stats\n\t\t\tstats.inCache --;\n\t\t\tif ( this.cachedSinceLoadComplete.has( tile ) ) {\n\n\t\t\t\tthis.cachedSinceLoadComplete.delete( tile );\n\t\t\t\tstats.inCacheSinceLoad --;\n\n\t\t\t}\n\n\t\t\tif ( t.internal.loadingState === QUEUED ) {\n\n\t\t\t\tstats.queued --;\n\n\t\t\t} else if ( t.internal.loadingState === LOADING ) {\n\n\t\t\t\tstats.downloading --;\n\n\t\t\t} else if ( t.internal.loadingState === PARSING ) {\n\n\t\t\t\tstats.parsing --;\n\n\t\t\t} else if ( t.internal.loadingState === LOADED ) {\n\n\t\t\t\tstats.loaded --;\n\n\t\t\t}\n\n\t\t\tt.internal.loadingState = UNLOADED;\n\n\t\t\tparseQueue.remove( t );\n\t\t\tdownloadQueue.remove( t );\n\t\t\tloadingTiles.delete( t );\n\n\t\t} );\n\n\t\t// if we couldn't add the tile to the lru cache because it's full then skip\n\t\tif ( ! addedSuccessfully ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if this is the beginning of a new set of tiles to load and dispatch and event\n\t\tif ( ! this.isLoading ) {\n\n\t\t\tthis.isLoading = true;\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-start' } );\n\n\t\t}\n\n\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\t\tthis.cachedSinceLoadComplete.add( tile );\n\t\tstats.inCacheSinceLoad ++;\n\t\tstats.inCache ++;\n\t\tstats.queued ++;\n\t\ttile.internal.loadingState = QUEUED;\n\t\tloadingTiles.add( tile );\n\n\t\t// queue the download and parse\n\t\treturn downloadQueue.add( tile, downloadTile => {\n\n\t\t\tif ( signal.aborted ) {\n\n\t\t\t\treturn Promise.resolve();\n\n\t\t\t}\n\n\t\t\ttile.internal.loadingState = LOADING;\n\t\t\tstats.downloading ++;\n\t\t\tstats.queued --;\n\n\t\t\tconst res = this.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( uri, { ...this.fetchOptions, signal } ) );\n\t\t\tthis.dispatchEvent( { type: 'tile-download-start', tile, uri } );\n\t\t\treturn res;\n\n\t\t} )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn extension === 'json' ? res.json() : res.arrayBuffer();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `Failed to load model with error code ${res.status}` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( content => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.downloading --;\n\t\t\t\tstats.parsing ++;\n\t\t\t\ttile.internal.loadingState = PARSING;\n\n\t\t\t\treturn parseQueue.add( tile, parseTile => {\n\n\t\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( extension === 'json' && content.root ) {\n\n\t\t\t\t\t\tthis.preprocessTileset( content, uri, tile );\n\t\t\t\t\t\ttile.children.push( content.root );\n\t\t\t\t\t\texternalTileset = content;\n\t\t\t\t\t\tisExternalTileset = true;\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn this.invokeOnePlugin( plugin => plugin.parseTile && plugin.parseTile( content, parseTile, extension, uri, signal ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( () => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.parsing --;\n\t\t\t\tstats.loaded ++;\n\t\t\t\ttile.internal.loadingState = LOADED;\n\t\t\t\tloadingTiles.delete( tile );\n\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t// If the memory of the item hasn't been registered yet then that means the memory usage hasn't\n\t\t\t\t// been accounted for by the cache yet so we need to check if it fits or if we should remove it.\n\t\t\t\tconst bytesUsed = this.getBytesUsed( tile );\n\t\t\t\tif ( lruCache.getMemoryUsage( tile ) === 0 && bytesUsed > 0 && lruCache.isFull() ) {\n\n\t\t\t\t\t// And if the cache is full due to newly loaded memory then lets discard this tile - it will\n\t\t\t\t\t// be loaded again later from the disk cache if needed.\n\t\t\t\t\tlruCache.remove( tile );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// update memory\n\t\t\t\tlruCache.setMemoryUsage( tile, bytesUsed );\n\n\t\t\t\t// dispatch an event indicating that this model has completed and that a new\n\t\t\t\t// call to \"update\" is needed.\n\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\tif ( isExternalTileset ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tileset',\n\t\t\t\t\t\ttileset: externalTileset,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tile.engineData.scene ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-model',\n\t\t\t\t\t\tscene: tile.engineData.scene,\n\t\t\t\t\t\ttile,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( error => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( error.name !== 'AbortError' ) {\n\n\t\t\t\t\tparseQueue.remove( tile );\n\t\t\t\t\tdownloadQueue.remove( tile );\n\n\t\t\t\t\tif ( tile.internal.loadingState === QUEUED ) {\n\n\t\t\t\t\t\tstats.queued --;\n\n\t\t\t\t\t} else if ( tile.internal.loadingState === LOADING ) {\n\n\t\t\t\t\t\tstats.downloading --;\n\n\t\t\t\t\t} else if ( tile.internal.loadingState === PARSING ) {\n\n\t\t\t\t\t\tstats.parsing --;\n\n\t\t\t\t\t} else if ( tile.internal.loadingState === LOADED ) {\n\n\t\t\t\t\t\tstats.loaded --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstats.failed ++;\n\n\t\t\t\t\tconsole.error( `TilesRenderer : Failed to load tile at url \"${ tile.content.uri }\".` );\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\ttile.internal.loadingState = FAILED;\n\t\t\t\t\tloadingTiles.delete( tile );\n\t\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlruCache.remove( tile );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t}\n\n}\n","import { arrayToString } from './LoaderUtils.js';\n\nexport function parseBinArray( buffer, arrayStart, count, type, componentType, propertyName ) {\n\n\tlet stride;\n\tswitch ( type ) {\n\n\t\tcase 'SCALAR':\n\t\t\tstride = 1;\n\t\t\tbreak;\n\n\t\tcase 'VEC2':\n\t\t\tstride = 2;\n\t\t\tbreak;\n\n\t\tcase 'VEC3':\n\t\t\tstride = 3;\n\t\t\tbreak;\n\n\t\tcase 'VEC4':\n\t\t\tstride = 4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error( `FeatureTable : Feature type not provided for \"${ propertyName }\".` );\n\n\t}\n\n\tlet data;\n\tconst arrayLength = count * stride;\n\n\tswitch ( componentType ) {\n\n\t\tcase 'BYTE':\n\t\t\tdata = new Int8Array( buffer, arrayStart, arrayLength );\n\t\t\tbreak;\n\n\t\tcase 'UNSIGNED_BYTE':\n\t\t\tdata = new Uint8Array( buffer, arrayStart, arrayLength );\n\t\t\tbreak;\n\n\t\tcase 'SHORT':\n\t\t\tdata = new Int16Array( buffer, arrayStart, arrayLength );\n\t\t\tbreak;\n\n\t\tcase 'UNSIGNED_SHORT':\n\t\t\tdata = new Uint16Array( buffer, arrayStart, arrayLength );\n\t\t\tbreak;\n\n\t\tcase 'INT':\n\t\t\tdata = new Int32Array( buffer, arrayStart, arrayLength );\n\t\t\tbreak;\n\n\t\tcase 'UNSIGNED_INT':\n\t\t\tdata = new Uint32Array( buffer, arrayStart, arrayLength );\n\t\t\tbreak;\n\n\t\tcase 'FLOAT':\n\t\t\tdata = new Float32Array( buffer, arrayStart, arrayLength );\n\t\t\tbreak;\n\n\t\tcase 'DOUBLE':\n\t\t\tdata = new Float64Array( buffer, arrayStart, arrayLength );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error( `FeatureTable : Feature component type not provided for \"${ propertyName }\".` );\n\n\t}\n\n\treturn data;\n\n}\n\nexport class FeatureTable {\n\n\tconstructor( buffer, start, headerLength, binLength ) {\n\n\t\tthis.buffer = buffer;\n\t\tthis.binOffset = start + headerLength;\n\t\tthis.binLength = binLength;\n\n\t\tlet header = null;\n\t\tif ( headerLength !== 0 ) {\n\n\t\t\tconst headerData = new Uint8Array( buffer, start, headerLength );\n\t\t\theader = JSON.parse( arrayToString( headerData ) );\n\n\t\t} else {\n\n\t\t\theader = {};\n\n\t\t}\n\n\t\tthis.header = header;\n\n\t}\n\n\tgetKeys() {\n\n\t\treturn Object.keys( this.header ).filter( key => key !== 'extensions' );\n\n\t}\n\n\tgetData( key, count, defaultComponentType = null, defaultType = null ) {\n\n\t\tconst header = this.header;\n\n\t\tif ( ! ( key in header ) ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst feature = header[ key ];\n\t\tif ( ! ( feature instanceof Object ) ) {\n\n\t\t\treturn feature;\n\n\t\t} else if ( Array.isArray( feature ) ) {\n\n\t\t\treturn feature;\n\n\t\t} else {\n\n\t\t\tconst { buffer, binOffset, binLength } = this;\n\t\t\tconst byteOffset = feature.byteOffset || 0;\n\t\t\tconst featureType = feature.type || defaultType;\n\t\t\tconst featureComponentType = feature.componentType || defaultComponentType;\n\n\t\t\tif ( 'type' in feature && defaultType && feature.type !== defaultType ) {\n\n\t\t\t\tthrow new Error( 'FeatureTable: Specified type does not match expected type.' );\n\n\t\t\t}\n\n\t\t\tconst arrayStart = binOffset + byteOffset;\n\t\t\tconst data = parseBinArray( buffer, arrayStart, count, featureType, featureComponentType, key );\n\n\t\t\tconst dataEnd = arrayStart + data.byteLength;\n\t\t\tif ( dataEnd > binOffset + binLength ) {\n\n\t\t\t\tthrow new Error( 'FeatureTable: Feature data read outside binary body length.' );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t}\n\n\tgetBuffer( byteOffset, byteLength ) {\n\n\t\tconst { buffer, binOffset } = this;\n\t\treturn buffer.slice( binOffset + byteOffset, binOffset + byteOffset + byteLength );\n\n\t}\n\n}\n","import { parseBinArray } from './FeatureTable.js';\n\nexport class BatchTableHierarchyExtension {\n\n\tconstructor( batchTable ) {\n\n\t\tthis.batchTable = batchTable;\n\n\t\tconst extensionHeader = batchTable.header.extensions[ '3DTILES_batch_table_hierarchy' ];\n\n\t\tthis.classes = extensionHeader.classes;\n\t\tfor ( const classDef of this.classes ) {\n\n\t\t\tconst instances = classDef.instances;\n\t\t\tfor ( const property in instances ) {\n\n\t\t\t\tclassDef.instances[ property ] = this._parseProperty( instances[ property ], classDef.length, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.instancesLength = extensionHeader.instancesLength;\n\n\t\tthis.classIds = this._parseProperty( extensionHeader.classIds, this.instancesLength, 'classIds' );\n\n\t\tif ( extensionHeader.parentCounts ) {\n\n\t\t\tthis.parentCounts = this._parseProperty( extensionHeader.parentCounts, this.instancesLength, 'parentCounts' );\n\n\t\t} else {\n\n\t\t\tthis.parentCounts = new Array( this.instancesLength ).fill( 1 );\n\n\t\t}\n\n\t\tif ( extensionHeader.parentIds ) {\n\n\t\t\tconst parentIdsLength = this.parentCounts.reduce( ( a, b ) => a + b, 0 );\n\t\t\tthis.parentIds = this._parseProperty( extensionHeader.parentIds, parentIdsLength, 'parentIds' );\n\n\t\t} else {\n\n\t\t\tthis.parentIds = null;\n\n\t\t}\n\n\t\tthis.instancesIds = [];\n\t\tconst classCounter = {};\n\t\tfor ( const classId of this.classIds ) {\n\n\t\t\tclassCounter[ classId ] = classCounter[ classId ] ?? 0;\n\t\t\tthis.instancesIds.push( classCounter[ classId ] );\n\t\t\tclassCounter[ classId ] ++;\n\n\t\t}\n\n\t}\n\n\t_parseProperty( property, propertyLength, propertyName ) {\n\n\t\tif ( Array.isArray( property ) ) {\n\n\t\t\treturn property;\n\n\t\t} else {\n\n\t\t\tconst { buffer, binOffset } = this.batchTable;\n\n\t\t\tconst byteOffset = property.byteOffset;\n\t\t\tconst componentType = property.componentType || 'UNSIGNED_SHORT';\n\n\t\t\tconst arrayStart = binOffset + byteOffset;\n\n\t\t\treturn parseBinArray( buffer, arrayStart, propertyLength, 'SCALAR', componentType, propertyName );\n\n\t\t}\n\n\t}\n\n\tgetDataFromId( id, target = {} ) {\n\n\t\t// Get properties inherited from parents\n\n\t\tconst parentCount = this.parentCounts[ id ];\n\n\t\tif ( this.parentIds && parentCount > 0 ) {\n\n\t\t\tlet parentIdsOffset = 0;\n\t\t\tfor ( let i = 0; i < id; i ++ ) {\n\n\t\t\t\tparentIdsOffset += this.parentCounts[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < parentCount; i ++ ) {\n\n\t\t\t\tconst parentId = this.parentIds[ parentIdsOffset + i ];\n\t\t\t\tif ( parentId !== id ) {\n\n\t\t\t\t\tthis.getDataFromId( parentId, target );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Get properties proper to this instance\n\n\t\tconst classId = this.classIds[ id ];\n\t\tconst instances = this.classes[ classId ].instances;\n\t\tconst className = this.classes[ classId ].name;\n\t\tconst instanceId = this.instancesIds[ id ];\n\n\t\tfor ( const key in instances ) {\n\n\t\t\ttarget[ className ] = target[ className ] || {};\n\t\t\ttarget[ className ][ key ] = instances[ key ][ instanceId ];\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n}\n","import { BatchTableHierarchyExtension } from './BatchTableHierarchyExtension.js';\nimport { FeatureTable } from './FeatureTable.js';\n\nexport class BatchTable extends FeatureTable {\n\n\tget batchSize() {\n\n\t\tconsole.warn( 'BatchTable.batchSize has been deprecated and replaced with BatchTable.count.' );\n\t\treturn this.count;\n\n\t}\n\n\tconstructor( buffer, count, start, headerLength, binLength ) {\n\n\t\tsuper( buffer, start, headerLength, binLength );\n\t\tthis.count = count;\n\n\t\tthis.extensions = {};\n\t\tconst extensions = this.header.extensions;\n\t\tif ( extensions ) {\n\n\t\t\tif ( extensions[ '3DTILES_batch_table_hierarchy' ] ) {\n\n\t\t\t\tthis.extensions[ '3DTILES_batch_table_hierarchy' ] = new BatchTableHierarchyExtension( this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetData( key, componentType = null, type = null ) {\n\n\t\tconsole.warn( 'BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId to get all' +\n\t\t\t'properties for an id or BatchTable.getPropertyArray for getting an array of value for a property.' );\n\t\treturn super.getData( key, this.count, componentType, type );\n\n\t}\n\n\tgetDataFromId( id, target = {} ) {\n\n\t\tif ( id < 0 || id >= this.count ) {\n\n\t\t\tthrow new Error( `BatchTable: id value \"${ id }\" out of bounds for \"${ this.count }\" features number.` );\n\n\t\t}\n\n\t\tfor ( const key of this.getKeys() ) {\n\n\t\t\ttarget[ key ] = super.getData( key, this.count )[ id ];\n\n\t\t}\n\n\t\tfor ( const extensionName in this.extensions ) {\n\n\t\t\tconst extension = this.extensions[ extensionName ];\n\n\t\t\tif ( extension.getDataFromId instanceof Function ) {\n\n\t\t\t\ttarget[ extensionName ] = target[ extensionName ] || {};\n\t\t\t\textension.getDataFromId( id, target[ extensionName ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetPropertyArray( key ) {\n\n\t\treturn super.getData( key, this.count );\n\n\t}\n\n\n}\n","// B3DM File Format\n// https://github.com/CesiumGS/3d-tiles/blob/master/specification/TileFormats/Batched3DModel/README.md\n\nimport { BatchTable } from '../utilities/BatchTable.js';\nimport { FeatureTable } from '../utilities/FeatureTable.js';\nimport { LoaderBase } from './LoaderBase.js';\nimport { readMagicBytes } from '../utilities/LoaderUtils.js';\n\nexport class B3DMLoaderBase extends LoaderBase {\n\n\tparse( buffer ) {\n\n\t\t// TODO: this should be able to take a uint8array with an offset and length\n\t\tconst dataView = new DataView( buffer );\n\n\t\t// 28-byte header\n\n\t\t// 4 bytes\n\t\tconst magic = readMagicBytes( dataView );\n\n\t\tconsole.assert( magic === 'b3dm' );\n\n\t\t// 4 bytes\n\t\tconst version = dataView.getUint32( 4, true );\n\n\t\tconsole.assert( version === 1 );\n\n\t\t// 4 bytes\n\t\tconst byteLength = dataView.getUint32( 8, true );\n\n\t\tconsole.assert( byteLength === buffer.byteLength );\n\n\t\t// 4 bytes\n\t\tconst featureTableJSONByteLength = dataView.getUint32( 12, true );\n\n\t\t// 4 bytes\n\t\tconst featureTableBinaryByteLength = dataView.getUint32( 16, true );\n\n\t\t// 4 bytes\n\t\tconst batchTableJSONByteLength = dataView.getUint32( 20, true );\n\n\t\t// 4 bytes\n\t\tconst batchTableBinaryByteLength = dataView.getUint32( 24, true );\n\n\t\t// Feature Table\n\t\tconst featureTableStart = 28;\n\t\tconst featureTableBuffer = buffer.slice(\n\t\t\tfeatureTableStart,\n\t\t\tfeatureTableStart + featureTableJSONByteLength + featureTableBinaryByteLength,\n\t\t);\n\t\tconst featureTable = new FeatureTable(\n\t\t\tfeatureTableBuffer,\n\t\t\t0,\n\t\t\tfeatureTableJSONByteLength,\n\t\t\tfeatureTableBinaryByteLength,\n\t\t);\n\n\t\t// Batch Table\n\t\tconst batchTableStart = featureTableStart + featureTableJSONByteLength + featureTableBinaryByteLength;\n\t\tconst batchTableBuffer = buffer.slice(\n\t\t\tbatchTableStart,\n\t\t\tbatchTableStart + batchTableJSONByteLength + batchTableBinaryByteLength,\n\t\t);\n\t\tconst batchTable = new BatchTable(\n\t\t\tbatchTableBuffer,\n\t\t\tfeatureTable.getData( 'BATCH_LENGTH' ),\n\t\t\t0,\n\t\t\tbatchTableJSONByteLength,\n\t\t\tbatchTableBinaryByteLength,\n\t\t);\n\n\t\tconst glbStart = batchTableStart + batchTableJSONByteLength + batchTableBinaryByteLength;\n\t\tconst glbBytes = new Uint8Array( buffer, glbStart, byteLength - glbStart );\n\n\t\treturn {\n\t\t\tversion,\n\t\t\tfeatureTable,\n\t\t\tbatchTable,\n\t\t\tglbBytes,\n\t\t};\n\n\t}\n\n}\n\n"],"names":["getUrlExtension","url","endIndex","queryIndex","fragmentIndex","lastPeriodIndex","lastSlashIndex","protocolIndex","viewErrorTarget","isDownloadFinished","value","LOADED","FAILED","isUsedThisFrame","tile","frameCount","isProcessed","areChildrenProcessed","childrenReady","contentReady","canUnconditionallyRefine","resetFrameState","renderer","recursivelyMarkUsed","cacheOnly","markUsed","children","i","l","recursivelyMarkPreviouslyUsed","canTraverse","kickActiveChildren","c","isChildReady","markUsedTiles","anyChildrenUsed","anyChildrenInFrustum","markUsedSetLeaves","allUsedChildrenProcessed","markVisibleTiles","hasContent","loadedContent","allChildrenReady","thisTileIsVisible","toggleTiles","isUsed","_a","setActive","setVisible","plugin","runTraversal","LOAD_ROOT_SIBLINGS","recursivelyLoadNextRenderableTiles","childCanDisplay","stats","errorRequirement","meetsSSE","isAdditiveRefine","throttle","callback","handle","PLUGIN_REGISTERED","regionErrorTarget","defaultPriorityCallback","a","b","aPriority","bPriority","optimizedPriorityCallback","lruPriorityCallback","TilesRendererBase","tileset","isLoading","loading","total","v","cachedRootJson","UNLOADED","lruCache","LRUCache","downloadQueue","PriorityQueue","parseQueue","processNodeQueue","aParent","bParent","plugins","priority","insertionPoint","index","name","p","func","result","pending","beforecb","aftercb","ensureFullyProcessed","traverseSet","args","target","usedSet","root","optimizedLoadStrategy","LOADING","processedUrl","error","needsUpdate","res","priorityCallback","optimizedRunTraversal","queuedTiles","inRegion","inRegionError","inRegionDistance","toRemove","t","scene","buffer","extension","tilesetDir","parentTile","hasUnrenderableContent","active","visible","loadingTiles","QUEUED","options","forceImmediate","processChildren","bytes","processedTiles","item","json","parent","proto","version","major","minor","basePath","isExternalTileset","externalTileset","uri","controller","signal","PARSING","downloadTile","content","parseTile","bytesUsed","parseBinArray","arrayStart","count","type","componentType","propertyName","stride","data","arrayLength","FeatureTable","start","headerLength","binLength","header","headerData","arrayToString","key","defaultComponentType","defaultType","feature","binOffset","byteOffset","featureType","featureComponentType","byteLength","BatchTableHierarchyExtension","batchTable","extensionHeader","classDef","instances","property","parentIdsLength","classCounter","classId","propertyLength","id","parentCount","parentIdsOffset","parentId","className","instanceId","BatchTable","extensions","extensionName","B3DMLoaderBase","LoaderBase","dataView","magic","readMagicBytes","featureTableJSONByteLength","featureTableBinaryByteLength","batchTableJSONByteLength","batchTableBinaryByteLength","featureTableStart","featureTableBuffer","featureTable","batchTableStart","batchTableBuffer","glbStart","glbBytes"],"mappings":"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"}