{"version":3,"file":"MemoryUtils-BEiOVCnL.js","sources":["../src/three/renderer/math/GeoUtils.js","../src/three/renderer/math/Ellipsoid.js","../src/three/renderer/math/GeoConstants.js","../src/three/renderer/math/OBB.js","../src/three/renderer/math/EllipsoidRegion.js","../src/three/renderer/utils/MemoryUtils.js"],"sourcesContent":["import { Spherical, Vector3, MathUtils } from 'three';\n\nconst _spherical = /* @__PURE__ */ new Spherical();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _geoResults = {};\n\n// Cesium / 3D tiles Spheroid:\n// - Up is Z at 90 degrees latitude\n// - 0, 0 latitude, longitude is X axis\n//      Z\n//      |\n//      |\n//      .----- Y\n//     /\n//   X\n\n\n// Three.js Spherical Coordinates\n// - Up is Y at 90 degrees latitude\n// - 0, 0 latitude, longitude is Z\n//       Y\n//      |\n//      |\n//      .----- X\n//     /\n//   Z\n\nexport function swapToGeoFrame( target ) {\n\n\tconst { x, y, z } = target;\n\ttarget.x = z;\n\ttarget.y = x;\n\ttarget.z = y;\n\n}\n\nexport function swapToThreeFrame( target ) {\n\n\tconst { x, y, z } = target;\n\ttarget.z = x;\n\ttarget.x = y;\n\ttarget.y = z;\n\n}\n\nexport function sphericalPhiToLatitude( phi ) {\n\n\treturn - ( phi - Math.PI / 2 );\n\n}\n\nexport function latitudeToSphericalPhi( latitude ) {\n\n\treturn - latitude + Math.PI / 2;\n\n}\n\nfunction correctGeoCoordWrap( lat, lon, target = {} ) {\n\n\t_spherical.theta = lon;\n\t_spherical.phi = latitudeToSphericalPhi( lat );\n\t_vec.setFromSpherical( _spherical );\n\n\t_spherical.setFromVector3( _vec );\n\ttarget.lat = sphericalPhiToLatitude( _spherical.phi );\n\ttarget.lon = _spherical.theta;\n\treturn target;\n\n}\n\nfunction toHoursMinutesSecondsString( value, pos = 'E', neg = 'W' ) {\n\n\tconst direction = value < 0 ? neg : pos;\n\tvalue = Math.abs( value );\n\n\tconst hours = ~ ~ value;\n\n\tconst minDec = ( value - hours ) * 60;\n\tconst minutes = ~ ~ minDec;\n\n\tconst secDec = ( minDec - minutes ) * 60;\n\tconst seconds = ~ ~ secDec;\n\n\treturn `${ hours }° ${ minutes }' ${ seconds }\" ${ direction }`;\n\n}\n\nexport function toLatLonString( lat, lon, decimalFormat = false ) {\n\n\tconst result = correctGeoCoordWrap( lat, lon, _geoResults );\n\tlet latString, lonString;\n\tif ( decimalFormat ) {\n\n\t\tlatString = `${ ( MathUtils.RAD2DEG * result.lat ).toFixed( 4 ) }°`;\n\t\tlonString = `${ ( MathUtils.RAD2DEG * result.lon ).toFixed( 4 ) }°`;\n\n\t} else {\n\n\t\tlatString = toHoursMinutesSecondsString( MathUtils.RAD2DEG * result.lat, 'N', 'S' );\n\t\tlonString = toHoursMinutesSecondsString( MathUtils.RAD2DEG * result.lon, 'E', 'W' );\n\n\t}\n\n\treturn `${ latString } ${ lonString }`;\n\n}\n","import { Vector3, Spherical, MathUtils, Ray, Matrix4, Sphere, Euler } from 'three';\nimport { swapToGeoFrame, latitudeToSphericalPhi } from './GeoUtils.js';\n\nconst _spherical = /* @__PURE__ */ new Spherical();\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _vec2 = /* @__PURE__ */ new Vector3();\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _matrix2 = /* @__PURE__ */ new Matrix4();\nconst _matrix3 = /* @__PURE__ */ new Matrix4();\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst _euler = /* @__PURE__ */ new Euler();\n\nconst _vecX = /* @__PURE__ */ new Vector3();\nconst _vecY = /* @__PURE__ */ new Vector3();\nconst _vecZ = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\n\nconst _ray = /* @__PURE__ */ new Ray();\n\nconst EPSILON12 = 1e-12;\nconst CENTER_EPS = 0.1;\n\nexport const ENU_FRAME = 0;\nexport const CAMERA_FRAME = 1;\nexport const OBJECT_FRAME = 2;\n\nexport class Ellipsoid {\n\n\tconstructor( x = 1, y = 1, z = 1 ) {\n\n\t\tthis.name = '';\n\t\tthis.radius = new Vector3( x, y, z );\n\n\t}\n\n\tintersectRay( ray, target ) {\n\n\t\t_matrix.makeScale( ...this.radius ).invert();\n\t\t_sphere.center.set( 0, 0, 0 );\n\t\t_sphere.radius = 1;\n\n\t\t_ray.copy( ray ).applyMatrix4( _matrix );\n\t\tif ( _ray.intersectSphere( _sphere, target ) ) {\n\n\t\t\t_matrix.makeScale( ...this.radius );\n\t\t\ttarget.applyMatrix4( _matrix );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// returns a frame with Z indicating altitude, Y pointing north, X pointing east\n\tgetEastNorthUpFrame( lat, lon, height, target ) {\n\n\t\tif ( height.isMatrix4 ) {\n\n\t\t\ttarget = height;\n\t\t\theight = 0;\n\n\t\t\tconsole.warn( 'Ellipsoid: The signature for \"getEastNorthUpFrame\" has changed.' );\n\n\t\t}\n\n\t\tthis.getEastNorthUpAxes( lat, lon, _vecX, _vecY, _vecZ );\n\t\tthis.getCartographicToPosition( lat, lon, height, _pos );\n\t\treturn target.makeBasis( _vecX, _vecY, _vecZ ).setPosition( _pos );\n\n\t}\n\n\t// returns a frame with z indicating altitude and az, el, roll rotation within that frame\n\t// - azimuth: measured off of true north, increasing towards \"east\" (z-axis)\n\t// - elevation: measured off of the horizon, increasing towards sky (x-axis)\n\t// - roll: rotation around northern axis (y-axis)\n\tgetOrientedEastNorthUpFrame( lat, lon, height, az, el, roll, target ) {\n\n\t\treturn this.getObjectFrame( lat, lon, height, az, el, roll, target, ENU_FRAME );\n\n\t}\n\n\t// returns a frame similar to the ENU frame but rotated to match three.js object and camera conventions\n\t// OBJECT_FRAME: oriented such that \"+Y\" is up and \"+Z\" is forward.\n\t// CAMERA_FRAME: oriented such that \"+Y\" is up and \"-Z\" is forward.\n\tgetObjectFrame( lat, lon, height, az, el, roll, target, frame = OBJECT_FRAME ) {\n\n\t\tthis.getEastNorthUpFrame( lat, lon, height, _matrix );\n\t\t_euler.set( el, roll, - az, 'ZXY' );\n\n\t\ttarget\n\t\t\t.makeRotationFromEuler( _euler )\n\t\t\t.premultiply( _matrix );\n\n\t\t// Add in the orientation adjustment for objects and cameras so \"forward\" and \"up\" are oriented\n\t\t// correctly\n\t\tif ( frame === CAMERA_FRAME ) {\n\n\t\t\t_euler.set( Math.PI / 2, 0, 0, 'XYZ' );\n\t\t\t_matrix2.makeRotationFromEuler( _euler );\n\t\t\ttarget.multiply( _matrix2 );\n\n\t\t} else if ( frame === OBJECT_FRAME ) {\n\n\t\t\t_euler.set( - Math.PI / 2, 0, Math.PI, 'XYZ' );\n\t\t\t_matrix2.makeRotationFromEuler( _euler );\n\t\t\ttarget.multiply( _matrix2 );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetCartographicFromObjectFrame( matrix, target, frame = OBJECT_FRAME ) {\n\n\t\t// if working with a frame that is not the ENU_FRAME then multiply in the\n\t\t// offset for a camera or object so \"forward\" and \"up\" are oriented correct\n\t\tif ( frame === CAMERA_FRAME ) {\n\n\t\t\t_euler.set( - Math.PI / 2, 0, 0, 'XYZ' );\n\t\t\t_matrix2.makeRotationFromEuler( _euler ).premultiply( matrix );\n\n\t\t} else if ( frame === OBJECT_FRAME ) {\n\n\t\t\t_euler.set( - Math.PI / 2, 0, Math.PI, 'XYZ' );\n\t\t\t_matrix2.makeRotationFromEuler( _euler ).premultiply( matrix );\n\n\t\t} else {\n\n\t\t\t_matrix2.copy( matrix );\n\n\t\t}\n\n\t\t// get the cartographic position of the frame\n\t\t_pos.setFromMatrixPosition( _matrix2 );\n\t\tthis.getPositionToCartographic( _pos, target );\n\n\t\t// get the relative rotation\n\t\tthis.getEastNorthUpFrame( target.lat, target.lon, 0, _matrix ).invert();\n\t\t_matrix2.premultiply( _matrix );\n\t\t_euler.setFromRotationMatrix( _matrix2, 'ZXY' );\n\n\t\ttarget.azimuth = - _euler.z;\n\t\ttarget.elevation = _euler.x;\n\t\ttarget.roll = _euler.y;\n\t\treturn target;\n\n\t}\n\n\tgetEastNorthUpAxes( lat, lon, vecEast, vecNorth, vecUp, point = _pos ) {\n\n\t\tthis.getCartographicToPosition( lat, lon, 0, point );\n\t\tthis.getCartographicToNormal( lat, lon, vecUp );\t\t// up\n\t\tvecEast.set( - point.y, point.x, 0 ).normalize();\t\t// east\n\t\tvecNorth.crossVectors( vecUp, vecEast ).normalize();\t// north\n\n\t}\n\n\t// azimuth: measured off of true north, increasing towards \"east\"\n\t// elevation: measured off of the horizon, increasing towards sky\n\t// roll: rotation around northern axis\n\tgetAzElRollFromRotationMatrix( lat, lon, rotationMatrix, target, frame = ENU_FRAME ) {\n\n\t\tconsole.warn( 'Ellipsoid: \"getAzElRollFromRotationMatrix\" is deprecated. Use \"getCartographicFromObjectFrame\", instead.' );\n\t\tthis.getCartographicToPosition( lat, lon, 0, _pos );\n\t\t_matrix3.copy( rotationMatrix ).setPosition( _pos );\n\n\t\tthis.getCartographicFromObjectFrame( _matrix3, target, frame );\n\t\tdelete target.height;\n\t\tdelete target.lat;\n\t\tdelete target.lon;\n\n\t\treturn target;\n\n\n\t}\n\n\tgetRotationMatrixFromAzElRoll( lat, lon, az, el, roll, target, frame = ENU_FRAME ) {\n\n\t\tconsole.warn( 'Ellipsoid: \"getRotationMatrixFromAzElRoll\" function has been deprecated. Use \"getObjectFrame\", instead.' );\n\n\t\tthis.getObjectFrame( lat, lon, 0, az, el, roll, target, frame );\n\t\ttarget.setPosition( 0, 0, 0 );\n\t\treturn target;\n\n\t}\n\n\tgetFrame( lat, lon, az, el, roll, height, target, frame = ENU_FRAME ) {\n\n\t\tconsole.warn( 'Ellipsoid: \"getFrame\" function has been deprecated. Use \"getObjectFrame\", instead.' );\n\t\treturn this.getObjectFrame( lat, lon, height, az, el, roll, target, frame );\n\n\t}\n\n\tgetCartographicToPosition( lat, lon, height, target ) {\n\n\t\t// From Cesium function Ellipsoid.cartographicToCartesian\n\t\t// https://github.com/CesiumGS/cesium/blob/665ec32e813d5d6fe906ec3e87187f6c38ed5e49/packages/engine/Source/core/renderer/Ellipsoid.js#L396\n\t\tthis.getCartographicToNormal( lat, lon, _norm );\n\n\t\tconst radius = this.radius;\n\t\t_vec.copy( _norm );\n\t\t_vec.x *= radius.x ** 2;\n\t\t_vec.y *= radius.y ** 2;\n\t\t_vec.z *= radius.z ** 2;\n\n\t\tconst gamma = Math.sqrt( _norm.dot( _vec ) );\n\t\t_vec.divideScalar( gamma );\n\n\t\treturn target.copy( _vec ).addScaledVector( _norm, height );\n\n\t}\n\n\tgetPositionToCartographic( pos, target ) {\n\n\t\t// From Cesium function Ellipsoid.cartesianToCartographic\n\t\t// https://github.com/CesiumGS/cesium/blob/665ec32e813d5d6fe906ec3e87187f6c38ed5e49/packages/engine/Source/core/renderer/Ellipsoid.js#L463\n\t\tthis.getPositionToSurfacePoint( pos, _vec );\n\t\tthis.getPositionToNormal( pos, _norm );\n\n\t\tconst heightDelta = _vec2.subVectors( pos, _vec );\n\n\t\ttarget.lon = Math.atan2( _norm.y, _norm.x );\n\t\ttarget.lat = Math.asin( _norm.z );\n\t\ttarget.height = Math.sign( heightDelta.dot( pos ) ) * heightDelta.length();\n\t\treturn target;\n\n\t}\n\n\tgetCartographicToNormal( lat, lon, target ) {\n\n\t\t_spherical.set( 1, latitudeToSphericalPhi( lat ), lon );\n\t\ttarget.setFromSpherical( _spherical ).normalize();\n\n\t\t// swap frame from the three.js frame to the geo coord frame\n\t\tswapToGeoFrame( target );\n\t\treturn target;\n\n\t}\n\n\tgetPositionToNormal( pos, target ) {\n\n\t\tconst radius = this.radius;\n\t\ttarget.copy( pos );\n\t\ttarget.x /= radius.x ** 2;\n\t\ttarget.y /= radius.y ** 2;\n\t\ttarget.z /= radius.z ** 2;\n\t\ttarget.normalize();\n\n\t\treturn target;\n\n\t}\n\n\tgetPositionToSurfacePoint( pos, target ) {\n\n\t\t// From Cesium function Ellipsoid.scaleToGeodeticSurface\n\t\t// https://github.com/CesiumGS/cesium/blob/d11b746e5809ac115fcff65b7b0c6bdfe81dcf1c/packages/engine/Source/core/renderer/scaleToGeodeticSurface.js#L25\n\t\tconst radius = this.radius;\n\t\tconst invRadiusSqX = 1 / ( radius.x ** 2 );\n\t\tconst invRadiusSqY = 1 / ( radius.y ** 2 );\n\t\tconst invRadiusSqZ = 1 / ( radius.z ** 2 );\n\n\t\tconst x2 = pos.x * pos.x * invRadiusSqX;\n\t\tconst y2 = pos.y * pos.y * invRadiusSqY;\n\t\tconst z2 = pos.z * pos.z * invRadiusSqZ;\n\n\t\t// Compute the squared ellipsoid norm.\n\t\tconst squaredNorm = x2 + y2 + z2;\n\t\tconst ratio = Math.sqrt( 1.0 / squaredNorm );\n\n\t\t// As an initial approximation, assume that the radial intersection is the projection point.\n\t\tconst intersection = _vec.copy( pos ).multiplyScalar( ratio );\n\t\tif ( squaredNorm < CENTER_EPS ) {\n\n\t\t\treturn ! isFinite( ratio ) ? null : target.copy( intersection );\n\n\t\t}\n\n\t\t// Use the gradient at the intersection point in place of the true unit normal.\n\t\t// The difference in magnitude will be absorbed in the multiplier.\n\t\tconst gradient = _vec2.set(\n\t\t\tintersection.x * invRadiusSqX * 2.0,\n\t\t\tintersection.y * invRadiusSqY * 2.0,\n\t\t\tintersection.z * invRadiusSqZ * 2.0\n\t\t);\n\n\t\t// Compute the initial guess at the normal vector multiplier, lambda.\n\t\tlet lambda = ( 1.0 - ratio ) * pos.length() / ( 0.5 * gradient.length() );\n\t\tlet correction = 0.0;\n\n\t\tlet func, denominator;\n\t\tlet xMultiplier, yMultiplier, zMultiplier;\n\t\tlet xMultiplier2, yMultiplier2, zMultiplier2;\n\t\tlet xMultiplier3, yMultiplier3, zMultiplier3;\n\n\t\tdo {\n\n\t\t\tlambda -= correction;\n\n\t\t\txMultiplier = 1.0 / ( 1.0 + lambda * invRadiusSqX );\n\t\t\tyMultiplier = 1.0 / ( 1.0 + lambda * invRadiusSqY );\n\t\t\tzMultiplier = 1.0 / ( 1.0 + lambda * invRadiusSqZ );\n\n\t\t\txMultiplier2 = xMultiplier * xMultiplier;\n\t\t\tyMultiplier2 = yMultiplier * yMultiplier;\n\t\t\tzMultiplier2 = zMultiplier * zMultiplier;\n\n\t\t\txMultiplier3 = xMultiplier2 * xMultiplier;\n\t\t\tyMultiplier3 = yMultiplier2 * yMultiplier;\n\t\t\tzMultiplier3 = zMultiplier2 * zMultiplier;\n\n\t\t\tfunc = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n\t\t\t// \"denominator\" here refers to the use of this expression in the velocity and acceleration\n\t\t\t// computations in the sections to follow.\n\t\t\tdenominator =\n\t\t\t\tx2 * xMultiplier3 * invRadiusSqX +\n\t\t\t\ty2 * yMultiplier3 * invRadiusSqY +\n\t\t\t\tz2 * zMultiplier3 * invRadiusSqZ;\n\n\t\t\tconst derivative = - 2.0 * denominator;\n\t\t\tcorrection = func / derivative;\n\n\t\t} while ( Math.abs( func ) > EPSILON12 );\n\n\t\treturn target.set(\n\t\t\tpos.x * xMultiplier,\n\t\t\tpos.y * yMultiplier,\n\t\t\tpos.z * zMultiplier\n\t\t);\n\n\t}\n\n\tcalculateHorizonDistance( latitude, elevation ) {\n\n\t\t// from https://aty.sdsu.edu/explain/atmos_refr/horizon.html\n\t\t// OG = sqrt ( 2 R h + h2 ) .\n\t\tconst effectiveRadius = this.calculateEffectiveRadius( latitude );\n\t\treturn Math.sqrt( 2 * effectiveRadius * elevation + elevation ** 2 );\n\n\t}\n\n\tcalculateEffectiveRadius( latitude ) {\n\n\t\t// This radius represents the distance from the center of the ellipsoid to the surface along the normal at the given latitude.\n\t\t// from https://en.wikipedia.org/wiki/Earth_radius#Prime_vertical\n\t\t// N = a / sqrt(1 - e^2 * sin^2(phi))\n\t\tconst semiMajorAxis = this.radius.x;\n\t\tconst semiMinorAxis = this.radius.z;\n\t\tconst eSquared = 1 - ( semiMinorAxis ** 2 / semiMajorAxis ** 2 );\n\t\tconst phi = latitude * MathUtils.DEG2RAD;\n\n\t\tconst sinPhiSquared = Math.sin( phi ) ** 2;\n\t\tconst N = semiMajorAxis / Math.sqrt( 1 - eSquared * sinPhiSquared );\n\t\treturn N;\n\n\t}\n\n\tgetPositionElevation( pos ) {\n\n\t\t// logic from \"getPositionToCartographic\"\n\t\tthis.getPositionToSurfacePoint( pos, _vec );\n\n\t\tconst heightDelta = _vec2.subVectors( pos, _vec );\n\t\treturn Math.sign( heightDelta.dot( pos ) ) * heightDelta.length();\n\n\t}\n\n\t// Returns an estimate of the closest point on the ellipsoid to the ray. Returns\n\t// the surface intersection if they collide.\n\tclosestPointToRayEstimate( ray, target ) {\n\n\t\tif ( this.intersectRay( ray, target ) ) {\n\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\t_matrix.makeScale( ...this.radius ).invert();\n\t\t\t_ray.copy( ray ).applyMatrix4( _matrix );\n\n\t\t\t_vec.set( 0, 0, 0 );\n\t\t\t_ray.closestPointToPoint( _vec, target ).normalize();\n\n\t\t\t_matrix.makeScale( ...this.radius );\n\t\t\treturn target.applyMatrix4( _matrix );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.radius.copy( source.radius );\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n","import { WGS84_RADIUS, WGS84_HEIGHT } from '3d-tiles-renderer/core';\nimport { Ellipsoid } from './Ellipsoid.js';\n\nexport const WGS84_ELLIPSOID = new Ellipsoid( WGS84_RADIUS, WGS84_RADIUS, WGS84_HEIGHT );\nWGS84_ELLIPSOID.name = 'WGS84 Earth';\n","import { Matrix4, Box3, Vector3, Plane, Ray } from 'three';\n\nconst _worldMin = /* @__PURE__ */ new Vector3();\nconst _worldMax = /* @__PURE__ */ new Vector3();\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _ray = /* @__PURE__ */ new Ray();\n\nexport class OBB {\n\n\tconstructor( box = new Box3(), transform = new Matrix4() ) {\n\n\t\tthis.box = box.clone();\n\t\tthis.transform = transform.clone();\n\t\tthis.inverseTransform = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.planes = new Array( 6 ).fill().map( () => new Plane() );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.box.copy( source.box );\n\t\tthis.transform.copy( source.transform );\n\t\tthis.update();\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this OBB\n\t * @param {Vector3} point\n\t * @param {Vector3} result\n\t * @returns {Vector3}\n\t */\n\tclampPoint( point, result ) {\n\n\t\treturn result.copy( point )\n\t\t\t.applyMatrix4( this.inverseTransform )\n\t\t\t.clamp( this.box.min, this.box.max )\n\t\t\t.applyMatrix4( this.transform );\n\n\t}\n\n\t/**\n\t * Returns the distance from any edge of this OBB to the specified point.\n\t * If the point lies inside of this box, the distance will be 0.\n\t * @param {Vector3} point\n\t * @returns {number}\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _norm ).distanceTo( point );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\t_norm.copy( point ).applyMatrix4( this.inverseTransform );\n\t\treturn this.box.containsPoint( _norm );\n\n\t}\n\n\t// returns boolean indicating whether the ray has intersected the obb\n\tintersectsRay( ray ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\treturn _ray.intersectsBox( this.box );\n\n\t}\n\n\t// Sets \"target\" equal to the intersection point.\n\t// Returns \"null\" if no intersection found.\n\tintersectRay( ray, target ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\tif ( _ray.intersectBox( this.box, target ) ) {\n\n\t\t\ttarget.applyMatrix4( this.transform );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst { points, inverseTransform, transform, box } = this;\n\t\tinverseTransform.copy( transform ).invert();\n\n\t\tconst { min, max } = box;\n\t\tlet index = 0;\n\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\tpoints[ index ].set(\n\t\t\t\t\t\tx < 0 ? min.x : max.x,\n\t\t\t\t\t\ty < 0 ? min.y : max.y,\n\t\t\t\t\t\tz < 0 ? min.z : max.z,\n\t\t\t\t\t).applyMatrix4( transform );\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updatePlanes();\n\n\t}\n\n\tupdatePlanes() {\n\n\t\t_worldMin.copy( this.box.min ).applyMatrix4( this.transform );\n\t\t_worldMax.copy( this.box.max ).applyMatrix4( this.transform );\n\n\t\t_norm.set( 0, 0, 1 ).transformDirection( this.transform );\n\t\tthis.planes[ 0 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 1 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 0, 1, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 2 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 3 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 1, 0, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 4 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 5 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tthis.clampPoint( sphere.center, _norm );\n\t\treturn _norm.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\treturn this._intersectsPlaneShape( frustum.planes, frustum.points );\n\n\t}\n\n\tintersectsOBB( obb ) {\n\n\t\treturn this._intersectsPlaneShape( obb.planes, obb.points );\n\n\t}\n\n\t// takes a series of 6 planes that define and enclosed shape and the 8 points that lie at the corners\n\t// of that shape to determine whether the OBB is intersected with.\n\t_intersectsPlaneShape( otherPlanes, otherPoints ) {\n\n\t\tconst thisPoints = this.points;\n\t\tconst thisPlanes = this.planes;\n\n\t\t// based on three.js' Box3 \"intersects frustum\" function\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = otherPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = thisPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do the opposite check using the obb planes to avoid false positives\n\t\t// this check is not performed by three.js' AABB logic but helps prevent a lot incorrect intersection reports\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = thisPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = otherPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n}\n","import { Matrix4, Vector3, Box3 } from 'three';\nimport { Ellipsoid } from './Ellipsoid.js';\n\n// bounds are lightly inflated to account for floating point error\nconst INFLATE_EPSILON = 1e-13;\nconst PI = Math.PI;\nconst HALF_PI = PI / 2;\n\nconst _orthoX = /* @__PURE__*/ new Vector3();\nconst _orthoY = /* @__PURE__*/ new Vector3();\nconst _orthoZ = /* @__PURE__*/ new Vector3();\nconst _vec = /* @__PURE__*/ new Vector3();\nconst _invMatrix = /* @__PURE__*/ new Matrix4();\nconst _box = /* @__PURE__*/ new Box3();\nconst _matrix = /* @__PURE__*/ new Matrix4();\n\nfunction expandSphereRadiusSquared( vec, target ) {\n\n\ttarget.radius = Math.max( target.radius, vec.distanceToSquared( target.center ) );\n\n}\n\nfunction isTriaxial( radii ) {\n\n\treturn radii.x !== radii.y;\n\n}\n\nexport class EllipsoidRegion extends Ellipsoid {\n\n\tconstructor(\n\t\tx = 1, y = 1, z = 1,\n\t\tlatStart = - HALF_PI, latEnd = HALF_PI,\n\t\tlonStart = 0, lonEnd = 2 * PI,\n\t\theightStart = 0, heightEnd = 0\n\t) {\n\n\t\tsuper( x, y, z );\n\t\tthis.latStart = latStart;\n\t\tthis.latEnd = latEnd;\n\t\tthis.lonStart = lonStart;\n\t\tthis.lonEnd = lonEnd;\n\t\tthis.heightStart = heightStart;\n\t\tthis.heightEnd = heightEnd;\n\n\t}\n\n\tgetBoundingBox( box, matrix ) {\n\n\t\tif ( isTriaxial( this.radius ) ) {\n\n\t\t\tconsole.warn( 'EllipsoidRegion: Triaxial ellipsoids are not supported.' );\n\n\t\t}\n\n\t\tconst {\n\t\t\tlatStart, latEnd,\n\t\t\tlonStart, lonEnd,\n\t\t\theightStart, heightEnd,\n\t\t} = this;\n\n\t\tconst latMid = ( latStart + latEnd ) * 0.5;\n\t\tconst lonMid = ( lonStart + lonEnd ) * 0.5;\n\t\tconst allAboveEquator = latStart > 0.0;\n\t\tconst allBelowEquator = latEnd < 0.0;\n\n\t\tlet nearEquatorLat;\n\t\tif ( allAboveEquator ) {\n\n\t\t\tnearEquatorLat = latStart;\n\n\t\t} else if ( allBelowEquator ) {\n\n\t\t\tnearEquatorLat = latEnd;\n\n\t\t} else {\n\n\t\t\tnearEquatorLat = 0;\n\n\t\t}\n\n\t\t// measure the extents\n\t\tconst { min, max } = box;\n\t\tmin.setScalar( Infinity );\n\t\tmax.setScalar( - Infinity );\n\t\tif ( lonEnd - lonStart <= PI ) {\n\n\t\t\t// extract the axes\n\t\t\tthis.getCartographicToNormal( latMid, lonMid, _orthoZ );\n\t\t\t_orthoY.set( 0, 0, 1 );\n\t\t\t_orthoX.crossVectors( _orthoY, _orthoZ ).normalize();\n\t\t\t_orthoY.crossVectors( _orthoZ, _orthoX ).normalize();\n\n\t\t\t// construct the frame\n\t\t\tmatrix.makeBasis( _orthoX, _orthoY, _orthoZ );\n\t\t\t_invMatrix.copy( matrix ).invert();\n\n\t\t\t// extract x\n\t\t\t// check the most bowing point near the equator relative to the frame\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonStart, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.x = Math.abs( _vec.x );\n\t\t\tmin.x = - max.x;\n\n\t\t\t// extract y\n\t\t\t// check corners and mid points for the top\n\t\t\tthis.getCartographicToPosition( latEnd, lonStart, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.y = _vec.y;\n\n\t\t\tthis.getCartographicToPosition( latEnd, lonMid, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.y = Math.max( _vec.y, max.y );\n\n\t\t\t// check corners and mid points for the bottom\n\t\t\tthis.getCartographicToPosition( latStart, lonStart, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.y = _vec.y;\n\n\t\t\tthis.getCartographicToPosition( latStart, lonMid, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.y = Math.min( _vec.y, min.y );\n\n\t\t\t// extract z\n\t\t\t// check center point\n\t\t\tthis.getCartographicToPosition( latMid, lonMid, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.z = _vec.z;\n\n\t\t\t// check top and bottom reverse points\n\t\t\tthis.getCartographicToPosition( latStart, lonStart, heightStart, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.z = _vec.z;\n\n\t\t\tthis.getCartographicToPosition( latEnd, lonStart, heightStart, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.z = Math.min( _vec.z, min.z );\n\n\t\t} else {\n\n\t\t\t// extract a vector towards the middle of the region\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonMid, heightEnd, _orthoZ );\n\t\t\t_orthoZ.z = 0;\n\t\t\tif ( _orthoZ.length() < 1e-10 ) {\n\n\t\t\t\t_orthoZ.set( 1, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t_orthoZ.normalize();\n\n\t\t\t}\n\n\t\t\t_orthoY.set( 0, 0, 1 );\n\t\t\t_orthoX.crossVectors( _orthoZ, _orthoY ).normalize();\n\n\t\t\t// construct the OBB frame\n\t\t\tmatrix.makeBasis( _orthoX, _orthoY, _orthoZ );\n\t\t\t_invMatrix.copy( matrix ).invert();\n\n\t\t\t// x extents\n\t\t\t// find the furthest point rotated 90 degrees from the center of the region\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonMid + HALF_PI, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.x = Math.abs( _vec.x );\n\t\t\tmin.x = - max.x;\n\n\t\t\t// y extents\n\t\t\t// measure the top of the region, accounting for the diagonal tilt of the edge\n\t\t\tthis.getCartographicToPosition( latEnd, 0, allBelowEquator ? heightStart : heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.y = _vec.y;\n\n\t\t\t// measure the bottom of the region, accounting for the diagonal tilt of the edge\n\t\t\tthis.getCartographicToPosition( latStart, 0, allAboveEquator ? heightStart : heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.y = _vec.y;\n\n\t\t\t// z extends\n\t\t\t// measure the furthest point at the center of the region\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonMid, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmax.z = _vec.z;\n\n\t\t\t// measure the opposite end, which is guaranteed to be at the furthest extents since this lon region extents is > PI\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonEnd, heightEnd, _vec ).applyMatrix4( _invMatrix );\n\t\t\tmin.z = _vec.z;\n\n\t\t}\n\n\t\t// center the frame\n\t\tbox.getCenter( _vec );\n\t\tbox.min.sub( _vec ).multiplyScalar( 1 + INFLATE_EPSILON );\n\t\tbox.max.sub( _vec ).multiplyScalar( 1 + INFLATE_EPSILON );\n\n\t\t_vec.applyMatrix4( matrix );\n\t\tmatrix.setPosition( _vec );\n\n\t}\n\n\tgetBoundingSphere( sphere ) {\n\n\t\tif ( isTriaxial( this.radius ) ) {\n\n\t\t\tconsole.warn( 'EllipsoidRegion: Triaxial ellipsoids are not supported.' );\n\n\t\t}\n\n\t\t// TODO: this could be optimized or the OBB could be generated at the same time since\n\t\t// a lot of the the points are reused\n\n\t\t// use the OBB function to get a reasonable center\n\t\tthis.getBoundingBox( _box, _matrix );\n\t\tsphere.center.setFromMatrixPosition( _matrix );\n\t\tsphere.radius = 0;\n\n\t\tconst {\n\t\t\tlatStart, latEnd,\n\t\t\tlonStart, lonEnd,\n\t\t\theightStart, heightEnd,\n\t\t} = this;\n\n\t\tconst latMid = ( latStart + latEnd ) * 0.5;\n\t\tconst lonMid = ( lonStart + lonEnd ) * 0.5;\n\t\tconst allAboveEquator = latStart > 0.0;\n\t\tconst allBelowEquator = latEnd < 0.0;\n\n\t\tlet nearEquatorLat;\n\t\tif ( allAboveEquator ) {\n\n\t\t\tnearEquatorLat = latStart;\n\n\t\t} else if ( allBelowEquator ) {\n\n\t\t\tnearEquatorLat = latEnd;\n\n\t\t} else {\n\n\t\t\tnearEquatorLat = 0;\n\n\t\t}\n\n\t\t// lon start extremity\n\t\tthis.getCartographicToPosition( nearEquatorLat, lonStart, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check corners and mid points for the top\n\t\tthis.getCartographicToPosition( latEnd, lonStart, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\tthis.getCartographicToPosition( latEnd, lonMid, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check corners and mid points for the bottom\n\t\tthis.getCartographicToPosition( latStart, lonStart, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\tthis.getCartographicToPosition( latStart, lonMid, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check center extremity\n\t\tthis.getCartographicToPosition( latMid, lonMid, heightEnd, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check lower height extremity\n\t\tthis.getCartographicToPosition( latStart, lonStart, heightStart, _vec );\n\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t// check 90 degree offset if range is larger than PI\n\t\tif ( lonEnd - lonStart > PI ) {\n\n\t\t\tthis.getCartographicToPosition( nearEquatorLat, lonMid + PI, heightEnd, _vec );\n\t\t\texpandSphereRadiusSquared( _vec, sphere );\n\n\t\t}\n\n\t\tsphere.radius = Math.sqrt( sphere.radius ) * ( 1 + INFLATE_EPSILON );\n\n\t}\n\n}\n","import { estimateBytesUsed as _estimateBytesUsed } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { TextureUtils } from 'three';\n\nexport function getTextureByteLength( tex ) {\n\n\tif ( ! tex ) {\n\n\t\treturn 0;\n\n\t}\n\n\tconst { format, type, image } = tex;\n\tconst { width, height } = image;\n\n\tlet bytes = TextureUtils.getByteLength( width, height, format, type );\n\tbytes *= tex.generateMipmaps ? 4 / 3 : 1;\n\n\treturn bytes;\n\n}\n\n// Returns the estimated number of bytes used by the object\nexport function estimateBytesUsed( object ) {\n\n\tconst dedupeSet = new Set();\n\n\tlet totalBytes = 0;\n\tobject.traverse( c => {\n\n\t\t// get geometry bytes\n\t\tif ( c.geometry && ! dedupeSet.has( c.geometry ) ) {\n\n\t\t\ttotalBytes += _estimateBytesUsed( c.geometry );\n\t\t\tdedupeSet.add( c.geometry );\n\n\t\t}\n\n\t\t// get material bytes\n\t\tif ( c.material ) {\n\n\t\t\tconst material = c.material;\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tconst value = material[ key ];\n\t\t\t\tif ( value && value.isTexture && ! dedupeSet.has( value ) ) {\n\n\t\t\t\t\ttotalBytes += getTextureByteLength( value );\n\t\t\t\t\tdedupeSet.add( value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn totalBytes;\n\n}\n"],"names":["_spherical","Spherical","_vec","Vector3","_geoResults","swapToGeoFrame","target","x","y","z","swapToThreeFrame","sphericalPhiToLatitude","phi","latitudeToSphericalPhi","latitude","correctGeoCoordWrap","lat","lon","toHoursMinutesSecondsString","value","pos","neg","direction","hours","minDec","minutes","seconds","toLatLonString","decimalFormat","result","latString","lonString","MathUtils","_norm","_vec2","_matrix","Matrix4","_matrix2","_matrix3","_sphere","Sphere","_euler","Euler","_vecX","_vecY","_vecZ","_pos","_ray","Ray","EPSILON12","CENTER_EPS","ENU_FRAME","CAMERA_FRAME","OBJECT_FRAME","Ellipsoid","ray","height","az","el","roll","frame","matrix","vecEast","vecNorth","vecUp","point","rotationMatrix","radius","gamma","heightDelta","invRadiusSqX","invRadiusSqY","invRadiusSqZ","x2","y2","z2","squaredNorm","ratio","intersection","gradient","lambda","correction","func","denominator","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","xMultiplier3","yMultiplier3","zMultiplier3","derivative","elevation","effectiveRadius","semiMajorAxis","eSquared","sinPhiSquared","source","WGS84_ELLIPSOID","WGS84_RADIUS","WGS84_HEIGHT","_worldMin","_worldMax","OBB","box","Box3","transform","Plane","points","inverseTransform","min","max","index","sphere","frustum","obb","otherPlanes","otherPoints","thisPoints","thisPlanes","i","plane","maxDistance","j","v","dist","INFLATE_EPSILON","PI","HALF_PI","_orthoX","_orthoY","_orthoZ","_invMatrix","_box","expandSphereRadiusSquared","vec","isTriaxial","radii","EllipsoidRegion","latStart","latEnd","lonStart","lonEnd","heightStart","heightEnd","latMid","lonMid","allAboveEquator","allBelowEquator","nearEquatorLat","getTextureByteLength","tex","format","type","image","width","bytes","TextureUtils","estimateBytesUsed","object","dedupeSet","totalBytes","c","_estimateBytesUsed","material","key"],"mappings":"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"}